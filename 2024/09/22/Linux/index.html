<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>Linux | KAYER</title><meta name="keywords" content="CPP,Linux"><meta name="author" content="Kayer"><meta name="copyright" content="Kayer"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="Linux"><meta name="application-name" content="Linux"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="Linux"><meta property="og:url" content="http://example.com/2024/09/22/Linux/index.html"><meta property="og:site_name" content="KAYER"><meta property="og:description" content="Linux系统基础Shell 常用的命令解释器 shell - Bourne Shell &amp;#x2F;bin&amp;#x2F;sh   bash - Bourne Again Shell &amp;#x2F;bin&amp;#x2F;bash     当前系统所使用的shell echo $SHELL   当前系统下有哪"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http://example.com/img/404.jpg"><meta property="article:author" content="Kayer"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://example.com/img/404.jpg"><meta name="description" content="Linux系统基础Shell 常用的命令解释器 shell - Bourne Shell &amp;#x2F;bin&amp;#x2F;sh   bash - Bourne Again Shell &amp;#x2F;bin&amp;#x2F;bash     当前系统所使用的shell echo $SHELL   当前系统下有哪"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2024/09/22/Linux/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"KAYER","mode":"local","switchBtn":true,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"不要走！再看看嘛！w(ﾟДﾟ)w","backTitle":"欢迎肥来！♪(^∇^*)"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: {"apiurl":"https://friends.anheyu.com/"},
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🏠 智能家居小能手","🔨 设计开发一条龙","🤝 专修交互与设计","🏃 脚踏实地行动派","🧱 团队小组发动机","💢 壮汉人狠话不多"]},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Kayer","link":"链接: ","source":"来源: KAYER","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'KAYER',
  title: 'Linux',
  postAI: '',
  pageFillDescription: 'Linux系统基础, Shell, Linux基础命令, 光标位置移动, 字符删除, 常见目录, 文件和目录操作相关命令, tree命令, ls（list）命令, cd命令, pwd命令, which命令, touch命令, mkdir命令, rmdir命令, rm命令, cp命令, mv命令, cat命令, more命令, less命令, head命令, tail命令, 软链接, 硬链接, wc命令, whoami, 用户权限用户用户组, 修改文件权限chmod, 修改文件所有者和所属组chown, find命令, grep命令, find和grep命令结合使用, 软件安装与卸载, CentOS, 在线安装, 使用RPM包管理器, 使用压缩包安装, 清理安装包, Ubuntu, 在线安装, 软件包安装, 常用的压缩工具, gzip和bzip2, tar工具, rar工具, zip工具, vi 使用, 命令模式, 光标移动, 删除命令, 撤销和反撤销, 复制粘贴, 可视模式, 替换, 查找, 切换到文本输入模式, 末行模式, 保存退出, 替换, 快速翻屛, 在末行模式下执行命令, 分屏操作, vim的配置文件, gcc编译器, 工作流程, gcc常用参数, 静态库和共享（动态）库, 库的介绍, 库的使用, 静态库, 静态库的制作, 静态库的使用, 动态库, 动态库的制作, 动态库的使用, 两种库的优缺点, 静态库, 动态库, makefile编写和gdb调试, makefile, 基本规则, makefile工作原理, makefile中的变量, 普通变量, 自动变量, 模式规则, makefile函数, makefile的清理操作, gdb调试, 生成调试信息, 启动gdb, 显示源代码, 断点操作, 调试代码, 查看变量的值, 查看修改变量的值, 文件IO操作, C库IO函数的工作流程, C语言操作文件相关问题, 库函数与系统函数的关系, PCB和文件描述符表, openx2Fclose, 文件描述符, open函数, close函数, readx2Fwrite, read函数, write函数, lseek, perrorx2Ferrno, 阻塞和非阻塞, 文件和目录, 文件操作相关函数, statx2Flstat函数, access函数, 目录操作相关函数, opendir函数, readdir函数, closedir函数, 读取目录内容的一般步骤, dupx2Fdup2x2Ffcntl, dup, dup2, fcntl, 进程相关, 进程相关概念, 程序和进程, 并行和并发, PCB-进程控制块, 创建进程, fork函数, psx2Fkill, getpidx2Fgetppid, exec函数族, 函数作用和函数介绍, execl函数, execlp函数, 进程回收, 为什么要进行进程资源回收, 孤儿进程, 僵尸进程, 进程回收函数, wait 函数, waitpid函数, 进程间通信, 进程间通信相关概念, 进程间通信的方式, 管道pipe, 管道的概念, 管道的原理, 管道的局限性, 创建管道pipe函数, 父子进程使用管道通信, 管道的读写行为, 如何设置管道为非阻塞, 查看管道缓冲区大小, FIFO, 介绍, 创建管道, 使用FIFO完成两个进程通信, 内存映射区, 介绍, mmap函数, munmap函数, mmap注意事项, mmap函数的使用总结, 使用 mmap函数建立匿名映射, 信号相关, 介绍, 机制, 信号的状态, 信号的处理方式, 信号的特质, 阻塞信号集和未决信号集, 信号的四要素, 信号相关函数, signal 函数, kill 函数x2F命令, raisex2Fabort函数, alarm函数, setitimer函数, 信号集相关, 未决信号集和阻塞信号集的关系, 信号集相关函数, sigemptyset, sigfillset, sigaddset, sigdelset, sigismember, sigprocmask, sigpending, 信号捕捉函数, SIGCHLD信号, 产生SIGCHLD信号的条件, SIGCHLD 信号的作用, 使用 SIGCHLD 信号完成对子进程的回收, 守护进程和线程, 守护进程, 守护进程介绍, 进程组和会话, 创建守护进程的模型, 线程, 什么是线程, 线程共享资源, 线程非共享资源, 线程优、缺点, pthread_create, pthread_exit, pthread_join, pthread_detach, pthread_cancel, pthread_equal, 进程函数和线程函数比较, 线程属性, 线程同步, 线程同步的概念, 互斥锁主要相关函数, pthread_mutex_t 类型, pthread_mutex_init, pthread_mutex_destroy, pthread_mutex_lock, pthread_mutex_unlock, pthread_mutex_trylock, 加锁和解锁, 互斥锁, 互斥锁的使用步骤, 死锁, 读写锁, 条件变量, 条件变量相关函数, pthread_cond_t cond, int pthread_cond_init, int pthread_cond_destroy, int pthread_cond_wait, int pthread_cond_signal, 使用条件变量的代码片段, 信号量, 信号量介绍, 相关函数, int sem_init, int sem_wait, int sem_post, int sem_trywait, int sem_destroy, Linux网络编程, 网络基础, 协议概念, 典型协议, OSI七层模型 amp TCPx2FIP四层模型, 网络应用程序设计模式, Cx2FS 模式, Bx2FS 模式, 优缺点, Cx2FS, Bx2FS, 以太网帧格式, ARP, IP 段格式, UDP 数据报格式, TCP数据流格式, 三次握手, 发送数据, 四次挥手, 滑动窗口, 函数封装思想, 粘包, 网络字节序, 大小端转换函数, IP 地址转换函数, 点分十进制IP转网络IP, 网络IP转点分十进制IP, SOCKET编程, SOCKET中结构体, SOCKET主要函数, socket, bind, listen, accept, connect, 读取数据和发送数据, 服务端开发流程, 客户端的开发流程, 高并发服务器, TCP状态转换图, 为什么需要2MSL, 端口复用, 半关闭状态, 半关闭的概念, shutdown 函数, 心跳包, 发送心跳过程, 如何让心跳数据和正常的业务数据不混淆?, 高并发服务器模型–select, 配套函数, 优点, 缺点, 多路 IO, poll, epoll, epoll_create, epoll_ctl, epoll_wait, 进阶epoll, epoll反应堆, 线程池系统基础常用的命令解释器当前系统所使用的当前系统下有哪些基础命令上一条命令或下一条命令或显示用户输入的所有命令光标位置移动左移或右移或移动到头部移动到尾部字符删除删除光标前的单个字符或键删除光标后的单个字符或键删除光标前所有内容删除光标后所有内容常见目录普通用户超级用户根目录二进制文件可执行程序命令如等命令存放的是系统管理员使用的系统管理程序如等系统命令下一切皆文件硬盘显卡显示器字符设备文件鼠标键盘块设备文件如在目录下执行移动鼠标会显示有输入运行的时候需要加载的一些库如等手动的挂载目录如盘等外设的自动挂载目录如光驱等的超级用户的家目录类似于的目录目录存放头文件如目录下的小游戏如小火车游戏存放配置文件可以查看文件的格式信息可以查看文件的格式信息系统的配置文件修改该文件会影响这个系统下面的所有用户安装的第三方应用程序比如安装数据库可以在这个目录下操作系统所有用户的家目录用户家目录存放临时文件新建在这个目录下的文件会在系统重启后自动清除文件和目录操作相关命令命令命令只能查看目录内容不能查看普通文件内容以树状形式查看指定目录内容使用该命令需要安装软件命令使用树形结构显示当前目录下的文件信息目录树形结构显示当前指定目录下的文件信息命令查看指定目录下的文件信息显示当前目录下文件信息目录或文件名显示指定目录下文件信息相关参数显示目录下的所有文件包括以开头的隐藏文件如等显示所有文件但不包括当前目录和父目录这两个特殊目录仅列出目录本身而不是目录内的内容通常与一起使用来查看目录的详细信息与一起使用时以人类可读的格式如显示文件大小将结果反向排序例如原本按照文件名从小到大排序使用后会变为从大到小递归地列出目录下的所有文件和子目录按照文件大小排序而不是文件名按照文件修改时间排序最新的文件会排在最前面在列出的文件或目录名后添加类型指示符例如表示可执行文件表示目录控制是否以颜色显示文件类型表示从不以颜色显示表示总是以颜色显示默认表示根据系统设置自动判断以完整的时间格式年月日时分显示文件的修改时间以数字形式显示用户和组而不是用户名和组名显示文件的号是系统中用于存储文件元数据的索引节点以逗号分隔的方式横向列出文件在目录名后添加以区分文件和目录按照文件的访问时间排序而不是修改时间按照自然顺序对文件名进行排序例如数字会按照数值大小而不是字典顺序排序以多列格式横向显示文件列表而不是默认的单列格式以长格式显示文件和目录的详细信息包括文件权限所有者组大小最后修改日期和时间等普通文件符号链接文件也称为链接文件目录文件字符设备文件套接字文件块设备文件管道文件文件持有者权限文件所属组权限其他人权限只读只写可执行文件所有者文件所属组文件大小文件创建日期或最后修改时间参数直接可以结合使用列出当前目录下所有文件的详细信息包括隐藏文件列出当前目录下的文件按照时间逆向排序命令切换目录使用方式路径切换到家目录邻居两个目录直接切换命令查看当前所处的工作目录命令显示命令所在的目录如命令如果文件不存在创建新文件如果文件存在更新文件的最后修改时间命令创建新目录文件夹如果创建多级目录需要添加参数命令删除空目录只能删除空目录命令删除的文件不会放在回收站中数据不易恢复删除文件删除目录参数递归删除目录删除目录必须添加此参数提示用户是否删除文件或目录强制删除命令源文件或目录目标目录或文件若有目录的拷贝需要用参数不存在直接创建新文件存在则用覆盖必须存在把拷贝到目录中不存在必须加参数存在拷贝进且不覆盖原有文件和目录把的属性也拷贝到如时间命令源文件目标文件不存在相当于把改名为存在相当于用覆盖必须存在把移动到里不存在相当于把改名为存在移动到且不覆盖原有文件和目录命令将文件内容一次性输出到终端缺点终端显示的内容有限如果文件太长无法全部显示可用于文件重定向相当于命令文件内容分页显示到终端但是只能一直向下浏览不能回退操作显示下一行回车显示下一页空格退出命令文件内容分页显示到终端可以自由上下浏览操作显示下一行回车显示上一页显示下一页空格显示上一页退出命令行数从文件头部开始查看前行的内容如查看前二十行的内容如果没有指定行数默认显示前行内容命令行数从文件头部开始查看前行的内容如查看前二十行的内容如果没有指定行数默认显示后行内容实时监控文件的变化软链接类似于下的快捷方式创建文件名快捷方式名如目录也可创建软链接如注意事项创建软链接时要用绝对路径如果不适用绝对路径一旦软链接文件发生位置变动就无法找到源文件软链接文件大小是路径源文件名的总字节数硬链接文件名硬链接的名字注意硬链接不能建在目录上硬链接对绝对路径没有要求硬链接不能跨文件系统硬链接文件和源文件的是相同的文件系统的要求唯一跨文件系统可能会使不同所以硬链接不能跨文件系统硬链接本质是不同文件名所在的结点是相同的相同的结点指向了相同的数据块所以他们的文件内容是一样的文件内容会同步文件名可以查看文件的节点文件名可以查看节点信息如图是的硬链接这两个文件指向了同一个同一个指向了相同的数据块文件内容相当与起别名当新创建了一个文件硬链接计数为给文件创建了一个硬链接后硬链接计数加删除一个硬链接后硬链接计数减硬链接应用场景可以起到同步文件作用修改的内容会在其余硬链接文件上同步可以起到保护文件的作用删除文件的时候只要硬链接计数不为零不会真正删除命令显示文件总行数字节数和单词数显示文件的总行数显示文件的总字节数显示文件的总单词数显示当前登录的用户名用户权限用户用户组修改文件权限文字设定法操作对象用户同组用户其他用户所有用户默认操作符添加权限取消权限赋予权限并取消其他权限权限读写执行例给文件的所有者和所属组添加读写权限数字设定法操作符添加权限取消权限赋予权限并取消其他权限数字表示的含义没有权限执行权限写权限读权限例给文件设置修改文件所有者和所属组文件所有者文件名修改文件所有者和所属组修改所属组命令按文件名查询使用参数路径文件名例按文件类型查询使用参数路径类型类型普通文件类型用而不是目录符号链接块设备文件字符设备文件文件管道文件查找指定目录下的普通文件路径按文件大小查询使用参数路径范围范围大于例小于例等于不需要添加符号大小必须大写必须小写表示字节数例等于的文件大于的文件小于的文件大于小于之间的文件按文件日期创建日期天以内天以外修改日期访问日期按深度层数搜索层一下的目录搜索的层数不超过层层数搜索层以上的目录搜索的层数不能小于层高级查找例查找指定目录下所有目录并列出目录中文件详细信息命令命令中间不能有空格比较安全特别是在执行删除文件的时候命令查找的文件结果集大优先用这个命令有目录查找的内容搜索路径若是目录则可以递归搜索可以显示该查找内容所在的行号可以忽略大小写进行查找不显示含有某字符串搜索当前目录下包含字符串的文件显示行号忽略大小写和命令结合使用先试用命令查找文件然后是用命令查找哪些文件包含某个字符串软件安装与卸载在线安装更新软件包列表打开终端或连接到服务器以用户身份登录系统运行以下命令更新软件包列表搜索软件包使用以下命令搜索要安装的软件包安装包名安装软件包找到所需软件包后使用以下命令进行安装安装包名使用包管理器下载包从官方网站或第三方网站下载所需软件的包安装包打开终端以用户身份登录系统使用以下命令安装包安装包名这里的表示安装表示显示安装过程表示显示进度条解决依赖性问题如果安装过程中出现依赖性问题可以使用命令自动解决依赖关系安装包名使用压缩包安装下载压缩包从软件官网下载与兼容的压缩包解压缩压缩包使用命令将压缩包解压到指定目录文件名称对于文件文件名称对于文件编译安装进入解压后的目录通常需要先运行命令进行配置这一步是可选的取决于软件是否提供了该脚本然后执行命令进行编译最后使用命令进行安装注意安装过程中可能需要指定安装路径和配置环境变量清理安装包清理所有缓存的软件包和头文件或者在及更高版本中这个命令会删除或目录下的所有缓存文件包括已下载但尚未安装的软件包已安装软件包的旧版本以及它们的头文件清理临时文件在安装过程中系统可能会创建一些临时文件这些文件通常位于或目录下清理不再需要的软件包如果发现系统中安装了一些不再需要的软件包可以使用或命令来删除它们或者在及更高版本中注意删除软件包时可能会提示删除一些依赖的软件包在线安装安装软件名卸载软件名更新软件列表清理安装包清理的缓存路径软件包安装格式的安装包安装卸载软件名常用的压缩工具和不能压缩目录只能一个一个文件进行压缩压缩之后原文件消失压缩当前目录下所有文件但是目录不能压缩解压当前目录下所有的文件压缩当前目录下所有的文件但是目录不能压缩解压当前目录下所有的文件工具参数用来压缩解压缩文件用来压缩解压缩文件创建新的压缩文件与互斥使用从压缩文件中释放文件与互斥使用详细报告处理的文件信息指定压缩文件的名字查看压缩包中有哪些文件压缩压缩包名字原材料要打包压缩的文件或目录压缩包名字原材料要打包压缩的文件或目录压缩包名字原材料要打包压缩的文件或目录解压缩已有的压缩包已有的压缩包已有的压缩包解压到指定目录添加参数大写工具使用前需安装工具压缩压缩目录打包生成的新文件不需要指定后缀例将压缩到文件中解压缩将解压到当前目录将解压到目录下若解压目录不存在会报错工具压缩压缩包名要压缩的文件或目录使用目录需要使用参数使用该命令不需要指定压缩包后缀生成文件解压缩压缩包名解压缩到指定目录添加参数解压目录解压目录不存在会报错使用命令模式光标移动保存退出代码格式化光标移动移动一个单词光标移动到文件开头光标移动到文件末尾光标移动到行首光标移动到行尾行跳转例跳转到行处删除命令删除光标后一个字符相当于删除光标前一个字符相当好与删除光标开始位置的单词包含光标所在单词删除光标前本行所有内容不包含光标所在字符删除光标后本行所有内容包含光标所在字符删除光标所在行本质剪切从光标当前行向下删除指定行数如使用移动选择内容然后按删除其中是列模式为非列模式撤销和反撤销一步一步撤销相当于反撤销相当于复制粘贴复制当前行复制行在光标所在位置向下新开辟一行粘贴在光标所在位置向上新开辟一行粘贴剪切操作按或者删除然后用可以粘贴可视模式使用移动选择内容然后按删除使用复制替换替换当前字符替换当前行光标后的字符查找从光标所在位置开始搜索按向下搜索按向上搜索从光标所在位置开始搜索按向上搜索按向下搜索将光标移动到待搜索的字符串上然后按向上搜索按向下搜索在待搜索的字符串上按或者可以查看相关帮助文档切换到文本输入模式光标前插入光标后插入在光标所在行的首行插入在光标所在行的行尾插入在光标所在行的下面新创建一行行首插入在光标所在行的上面新创建一行行首插入删除光标后边的字符从光标当前位置插入删除光标所在当前行从行首插入按列模式插入先按进入列模式移动光标选定某列按或者向前插入然后插入字符最后按两次末行模式保存退出退出强制退出不保存内容保存修改内容不退出保存并退出相当于替换下面表示原字符串表示新字符串光标所在行的第一个替换为光标所在行的所有替换为将行至行之间的全部替换为当前文件的所有替换为当前文件的所有替换为当前文件的所有替换为但是每次替换需要用户确认快速翻屛向下翻半屏光标向上移动向上翻半屏光标向下移动向上翻全屏向后翻全屏在末行模式下执行命令命令按两下可回到命令模式分屏操作打开文件之前分屏垂直分屏水平分屏打开文件之后分屏快捷键操作当前文件水平分屏当前文件垂直分屏文件名当前文件和另一个文件水平分屏文件名当前文件和另一个文件垂直分屏在多个窗口切换光标保存保存退出保存退出退出强制退出分屏模式的配置文件用户级别的配置文件修改用户级别的配置文件只会影响当前用户不会影响其他用户系统级别的配置文件修改系统级别的配置文件会影响所有用户常用配置设置缩进个空格设置行号设置缩进个空格默认缩进个空格编译器工作流程编译器将源文件到生成一个可执行程序中间一共经历了四个步骤四个步骤并不是独立完成的而是在内部调用了其他工具从而完成了整个工作流程其中编译最耗时因为要逐行检查语法的工作流程预处理预处理去掉注释展开头文件宏替换编译将源代码文件编译成汇编语言代码汇编将汇编语言代码编译成了二进制文件目标代码链接链接代码中调用的库函数一步生成最终的可执行程序常用参数查看版本号也可以生成预处理文件生成汇编文件只编译生成文件通常称为目标文件指定头文件所在的路径指定库文件所在的路径指定库的名字指定生成的目标文件的名字包含调试信息使用调试需要添加参数编译优化越大优化得越多提示更多警告信息编译时定义宏静态库和共享动态库库的介绍什么是库库是二进制文件是源代码文件的另一种表现形式是加了密的源代码是一些功能相近或者是相似的函数的集合体使用库有什么好处提高代码的可重用性而且还可以提高程序的健壮性可以减少开发者的代码开发量缩短开发周期库的使用头文件包含了库函数的声明库文件包含了库函数的代码实现注意库不能单独使用只能作为其他执行程序的一部分完成某些功能也就是说只能被其他程序调用才能使用静态库静态库可以认为是一些目标代码的集合是在可执行程序运行前就已经加入到执行码中成为执行程序的一部分按照习惯一般以做为文件后缀名静态库的命名一般分为三个部分前缀库名称自定义如后缀最终名字为静态库的制作下面以和三个文件为例讲述静态库的制作和使用其中文件中有函数的声明和中有函数的实现步骤将源文件生成对应的文件或者分别生成文件步骤优用打包工具将准备好的文件打包为文件在使用工具是时候需要添加参数更新创建建立索引命令静态库名文件静态库的使用哪个文件调用了静态库中的函数在生成可执行文件时需要添加参数来找到库函数是对应文件的路径是静态库和中间的名字例动态库共享库在程序编译时并不会被连接到目标代码中而是在程序运行是才被载入不同的应用程序如果调用相同的库那么在内存里只需要有一份该共享库的拷贝规避了空间浪费问题动态库在程序运行时才被载入也解决了静态库对程序的更新部署和发布会带来麻烦用户只需要更新动态库即可增量更新为什么需要动态库其实也是静态库的特点导致按照习惯一般以做为文件后缀名共享库的命名一般分为三个部分前缀库名称自定义如后缀最终名字为动态库的制作生成目标文件此时要加编译选项参数创建与地址无关的编译程序目的就是为够在多个应用程序间共享生成共享库此时要加链接器选项指定生成动态链接库动态库的使用引用动态库编译成可执行文件跟静态库方式一样用到的参数指定要连接的库的所在目录指定链接时需要的动态库去掉前缀和后缀指定文件用到的头文件所在的路径运行发现报错分析为什么在执行的时候找不到库当系统加载可执行代码时候能够知道其所依赖的库的名字但是还需要知道所依赖的库的绝对路径此时就需要系统动态载入器命令可以查看可执行文件依赖的库文件执行可以发现找不到对于格式的可执行程序是由来完成的它先后搜索文件的段环境变量文件列表目录找到库文件后将其载入内存使用命令可以查看文件的类型如何让系统找到共享库拷贝自己制作的共享库到或者临时设置库路径永久设置把库路径设置到文件中然后在执行下列三种办法之一执行使配置文件生效第一个后面有一个空格执行配置文件生效退出当前终端然后再次登陆也可以使配置文件生效永久设置把库路径设置到文件中将其添加到文件中编辑文件加入库文件所在目录的路径运行该命令会重建文件两种库的优缺点静态库优点执行速度快是因为静态库已经编译到可执行文件内部了移植方便不依赖域其他的库文件缺点缺点耗费内存是由于每一个静态库的可执行程序都会加载一次部署更新麻烦因为静态库修改以后所有的调用到这个静态库的可执行文件都需要重新编译动态库优点节省内存部署升级更新方便只需替换动态库即可然后再重启服务缺点加载速度比静态库慢移植性差需要把所有用到的动态库都移植由于由静态库生成的可执行文件是把静态库加载到了其内部所以静态库生成的可执行文件一般会比动态库大编写和调试文件主要是管理项目工程文件通过执行命令命令就会解析并执行文件文件的命名或者基本规则目标依赖命令基本规则三要素目标要生成的目标文件依赖目标文件由哪些文件生成命令通过执行该命令由依赖文件生成目标工作原理若想生成目标检查规则中的所有的依赖文件是否都存在如果有的依赖文件不存在则向下搜索规则看是否有生成该依赖文件的规则如果有规则用来生成该依赖文件则执行规则中的命令生成依赖文件如果没有规则用来生成该依赖文件则报错如果所有依赖都存在检查规则中的目标是否需要更新必须先检查它的所有依赖依赖中有任何一个被更新则目标必须更新检查的规则是哪个时间大哪个最新若目标的时间依赖的时间不更新若目标的时间依赖的时间则更新中的变量在中使用变量有点类似于语言中的宏定义使用该变量相当于内容替换使用变量可以使易于维护修改起来变得简单有三种类型的变量普通变量自带变量自动变量普通变量变量定义直接用使用变量值用变量名例下面是变量的定义和使用定义变量并赋值使用变量变量名定义了两个变量其中的值是变量值的引用除了使用用户自定义变量中也提供了一些变量变量名大写供用户直接使用我们可以直接对其进行赋值预处理的选项编译器的选项链接器选项自动变量自动变量只能用在命令中不能用在条件上表示规则中的目标表示规则中的第一个条件表示规则中的所有条件组成一个列表以空格隔开如果这个列表中有重复的项则消除重复项模式规则至少在规则的目标定义中要包含表示一个或多个在依赖条件中同样可以使用依赖条件中的的取值取决于其目标比如说的简单点就是函数中的函数有很多两个最常用的查找指定目录下的指定类型的文件找到当前目录下所有后缀为的文件赋值给匹配替换把变量里所有后缀为的文件替换成在中所有的函数都是有返回值的当前目录下有等价于等价于的清理操作用途清除编译生成的中间文件和最终目标文件如果当前目录下有同名文件则不执行对应的命令解决方案伪目标声明声明目标为伪目标之后将不会检查该目标是否存在或者该目标是否需要更新命令中的特殊符号此条命令出错也会继续执行后续的命令如强制执行比如若要删除的文件不存在使用不会报错不显示命令本身只显示结果如其它默认执行第一个出现的目标可通过指定要执行的目标执行一个文件名称使用执行指定的调试生成调试信息一般来说主要调试的是的程序要调试的程序首先在编译时我们必须要把调试信息加到可执行文件中使用编译器的参数可以做到这一点如如果没有将看不见程序的函数名变量名所代替的全是运行时的内存地址当你用把调试信息加入之后并成功编译目标代码以后来调试它启动启动也就是执行文件一般在当前目录下设置运行参数可指定运行时参数如命令可以查看设置好的运行参数启动程序程序开始执行如果有断点停在第一个断点处程序向下执行一行在第一条语句处停止显示源代码可以用命令来打印程序的源代码默认打印行命令的用法如下所示打印第行的上下文内容显示函数名为的函数的源程序显示当前行后面的源程序显示当前文件开始处的源程序显示文件下第行显示文件的函数名为的函数的源程序一般是打印当前行的上行和下行如果显示函数是是上行下行默认是行当然你也可以定制显示的范围使用下面命令可以设置一次显示源程序的行数设置一次显示源代码的行数查看当前的设置断点操作简单断点一当前文件设置断点可以简写为设置断点在源程序第行设置断点在函数入口处多文件设置断点一其他文件在进入指定函数时停住在源文件的行处停住在源文件的函数的入口处停住查询所有断点条件断点一般来说为断点设置一个条件使用关键词后面跟其断点条件设置一个条件断点维护断点是断点序号使断点失效使所有断点无效使断点生效使所有断点有效删除断点如删除到序号的断点删除序号是的断点删除序号是的断点删除所有断点调试代码运行程序可简写为单步跟踪函数调用当作一条简单语句执行可简写为单步跟踪函数调进入被调用函数体内可简写为退出进入的函数如果出不去看一下函数体中的循环中是否有断点如果有删掉或者设置无效在一个循环体内单步跟踪时这个命令可以运行程序直到退出循环体可简写为如果出不去看一下函数体中的循环中是否有断点如果有删掉或者设置无效继续运行程序可简写为若有断点则跳到下一个断点处退出调试查看变量的值查看运行时变量的值打印变量字符串表达式等的值可简写为打印的值自动显示变量的值你可以设置一些自动显示的变量当程序停住时或是在你单步跟踪时这些变量会自动显示相关的命令是变量名查看设置的自动显示的信息时显示的编号删除自动显示意为所设置好了的自动显式的编号如果要同时删除几个编号可以用空格分隔如果要删除一个范围内的编号可以用减号表示删除某个自动显示或者删除多个删除一个范围使一个自动显示无效使多个自动显示无效使一个范围的自动显示无效使一个自动显示有效使多个自动显示有效使一个范围的自动显示有效和不删除自动显示的设置而只是让其失效和恢复查看修改变量的值查看变量的类型打印变量的值可以使用命令来告诉不是的参数而是程序的变量名如将变量值设置为在你改变程序变量取值时最好都使用格式的命令文件操作库函数的工作流程使用文件缓冲的目的是为了减少磁盘的读写次数提高磁盘的效率语言操作文件相关问题使用函数打开一个文件返回一个这个指针指向的结构体有三个重要的成员文件描述符通过文件描述可以找到文件的通过可以找到对应的磁盘数据块文件指针读和写共享一个文件指针读或者写都会引起文件指针的变化文件缓冲区读或者写会先通过文件缓冲区主要目的是为了减少对磁盘的读写次数提高读写磁盘的效率头文件的第行处这个接头体定义中有一个成员这个就是文件描述符库函数与系统函数的关系库函数和系统函数的关系是调用和被调用的关系库函数是对系统函数的进一步封装每一个运行的程序进程操作系统都会为其分配一个的地址空间虚拟地址空间虚拟地址空间进程的虚拟地址空间分为用户区和内核区其中内核区是受保护的用户是不能够对其进行读写操作的内核区中很重要的一个就是进程管理进程管理中有一个区域就是本质是一个结构体中有文件描述符表文件描述符表中存放着打开的文件描述符涉及到文件的操作都会用到这个文件描述符和文件描述符表结构体该结构体在一个进程有一个文件描述符表大小前三个被占用分别是文件描述符作用通过文件描述符找到通过找到磁盘数据块虚拟地址空间内核区文件描述表文件描述符文件操作使用文件描述符文件描述符一个进程启动之后默认打开三个文件描述符新打开文件返回文件描述符表中未使用的最小文件描述符调用函数可以打开或创建新文件得到一个文件描述符函数函数描述打开或者新建一个文件函数原型函数参数参数是要打开或创建的文件名和一样既可以是相对路径也可以是绝对路径参数有一系列常数值可供选择可以同时选择多个常数用按位或运算符连接起来所以这些常数的宏定义都以开头表示必选项以下三个常数中必须指定一个且仅允许指定一个只读打开只写打开可读可写打开以下可选项可以同时指定个或多个和必选项按位或起来作为参数可选项有很多这里只介绍几个常用选项表示追加如果文件已有内容这次打开文件所写的数据附加到文件的末尾而不覆盖原来的内容若此文件不存在则创建它使用此选项时需要提供第三表示该文件的访问权限文件最终权限如果同时指定了并且文件已存在则出错返回如果文件已存在将其长度截断为为字节对于设备文件以方式打开可以做非阻塞非阻塞函数返回值成功返回一个最小且未被占用的文件描述符失败返回并设置值函数函数描述关闭文件函数原型函数参数文件描述符函数返回值成功返回失败返回并设置值需要说明的是当一个进程终止时内核对该进程所有尚未关闭的文件描述符调用关闭所以即使用户程序不调用在终止时内核也会自动关闭它打开的所有文件但是对于一个长年累月运行的程序比如网络服务器打开的文件描述符一定要记得关闭否则随着打开的文件越来越多会占用大量文件描述符和系统资源函数函数描述从打开的设备或文件中读取数据函数原型函数参数文件描述符读上来的数据保存在缓冲区中缓冲区存放的最大字节数函数返回值读取到的字节数文件读取完毕出错并设置函数函数描述向打开的设备或文件中写数据函数原型函数参数文件描述符缓冲区要写入文件或设备的数据中数据的长度函数返回值成功返回写入的字节数错误返回并设置所有打开的文件都有一个当前文件偏移量以下简称为通常是一个非负整数用于表明文件开始处到文件当前位置的字节数读写操作通常开始于并且使增大增量为读写的字节数文件被打开时会被初始化为除非使用了使用函数可以改变文件的函数描述移动文件指针函数原型函数参数文件描述符参数的含义取决于参数如果是文件偏移量将设置为如果是文件偏移量将被设置为加上可以为正也可以为负如果是文件偏移量将被设置为文件长度加上可以为正也可以为负函数返回值若成功执行则返回新的偏移量函数常用操作文件指针移动到头部获取文件指针当前位置获取文件长度实现文件拓展从文件尾部开始向后拓展个字节额外执行一次写操作否则文件无法完成拓展数据随便写是一个全局变量当系统调用后若出错会将进行设置一个进程对应一个错误信息可以将对应的描述信息打印出来如如果报错的话打印空格错误信息阻塞和非阻塞普通文件默认是非阻塞的终端设备如默认阻塞管道和套接字默认阻塞文件和目录文件操作相关函数函数函数描述获取文件属性函数原型函数返回值成功返回失败返回位整数其他人权限读权限写权限执行权限掩码过滤中除其他人权限以外的信息所属组权限读权限写权限文件所有者权限读权限写权限执行权限掩码过滤中除文件所有者权限以外的信息为真表明可读为真表明可写为真表明可执行文件类型套接字符号链接软链接普通文件块设备目录字符设备管道掩码过滤中除文件类型以外的信息为真普通文件为真表示普通文件和函数对于普通文件来说函数和函数一样对于软连接文件来说函数获取的是连接文件本身的属性函数获取的是连接文件指向的文件的属性函数判断文件是否存在函数原型目录操作相关函数函数函数函数读取目录内容的一般步骤打开目录循环读取文件关闭目录函数描述复制文件描述符函数原型函数参数要复制的文件描述符函数返回值成功返回最小且没被占用的文件描述符失败返回设置台值当调用函数之后和都指向了同一个文件内核会在内部维护一个计数此时计数为当一个文件描述符之后这个计数变为只有当计数为时文件才会被真正关闭函数描述复制文件描述符函数原型函数参数原来的文件描述符复制成的新的文件描述符函数返回值成功将复制给两个文件描述符指向同一个文件失败返回设置值假设已经指向了一个文件首先原来打开的文件然后指向指向的文件若没有被占用指向指向的文件当调用之后若原来已经打开了一个文件则先关闭这个文件然后指向了和相同的文件若原来没有打开文件则直接指向和相同的文件调用函数之后内核会修改内部的计数计数为函数描述改变已经打开的文件的属性函数原型若为复制文件描述符与相同若为获取文件描述符的属性值若为设置文件描述符的属性函数返回值返回值取决于成功若为返回一个新的文件描述符若为返回文件描述符的值失败返回并设置值函数常用的操作复制一个新的文件描述符获取文件的属性标志设置文件状态标志常用的属性标志设置文件打开为末尾添加设置打开的文件描述符为非阻塞进程相关进程相关概念程序和进程程序是指编译好的二进制文件在磁盘上占用磁盘空间是一个静态的概念进程一个启动的程序进程占用的是系统资源如物理内存终端等是一个动态的概念程序剧本纸进程戏舞台演员灯光道具同一个剧本可以在多个舞台同时上演同样同一个程序也可以加载为不同的进程彼此之间互不影响同一个进程可以在多个终端执行每启动一个进程就会有一个进程即使是相同的程序多次启动也会有不同的并行和并发并发在一个时间段内是在同一个上同时运行多个程序如若将的的时间分成个时间片每个进程执行完一个时间片必须无条件让出的使用权这样中就可以执行个进程并行指两个或两个以上的程序在同一时刻发生需要有多颗进程控制块每个进程在内核中都有一个进程控制块来维护进程相关的信息内核的进程控制块是结构体文件的行处可以查看结构体定义其内部成员有很多重点掌握以下部分即可进程系统中每个进程有唯一的在语言中用类型表示其实就是一个非负整数进程的状态有就绪运行挂起停止等状态进程切换时需要保存和恢复的一些寄存器描述虚拟地址空间的信息描述控制终端的信息当前工作目录掩码文件描述符表包含很多指向结构体的指针和信号相关的信息用户和组会话和进程组进程可以使用的资源上限创建进程函数函数作用创建子进程原型函数参数无返回值调用成功父进程返回子进程的子进程返回调用失败返回设置值函数代码片段实例父进程调用函数创建一个子进程子进程的用户区和父进程的用户区完全一样但是内核区完全一样如父进程的和子进程的不一样函数的返回值父进程返回是子进程的这个值大于子进程返回的是注意并不是一个进程返回两个值而是由父子进程各自返回一个值父子进程的执行逻辑父进程执行的逻辑子进程执行的逻辑父子进程谁先执行谁先抢到时间片谁先执行父子进程不能共享全局变量但是如果父子进程只是对全局变量做读操作则父子进程在内存中只有一份属于共享但是如果父子进程中的任何一个进程对该变量做修改操作会在内存中拷贝一个副本然后在这个副本上进行修改修改完成以后映射回去写时复制读时共享当前系统所有用户的进程查看进程所有者及其他一些信息显示没有控制终端的进程不能与用户进行交互的进程输入输出列出与作业控制相关的信息查看系统有哪些信号杀死某个线程得到当前进程的得到当前进程的父进程的函数族函数作用和函数介绍有的时候需要在一个进程里面执行其他的命令或者是用户自定义的应用程序此时就用到了函数族当中的函数使用方法一般都是在父进程里面调用创建处子进程然后在子进程里面调用函数如果想在一个进程内部执行系统命令或者是应用程序优先应该想到如下方式先然后在子进程里面执行拉起可执行程序或者命令函数函数原型参数介绍要执行的程序的绝对路径变参要执行的程序的需要的参数占位通常写应用程序的名字后面的命令的参数参数写完之后返回值若是成功则不返回不会再执行函数后面的代码若是失败会执行后面的代码可以用打印错误原因函数一般执行自己写的程序函数函数原型参数介绍执行命令的名字根据环境变量来搜索该命令占位后面的命令的参数参数写完之后表明参数结束返回值若是成功则不返回不会再执行函数后面的代码若是失败会执行后面的代码可以用打印错误原因函数一般是执行系统自带的程序或者是命令进程回收为什么要进行进程资源回收当一个进程退出之后进程能够回收自己的用户区的资源但是不能回收内核空间的资源必须由它的父进程调用或者函数完成对子进程的回收避免造成系统资源的浪费孤儿进程孤儿进程的概念若子进程的父进程已经死掉而子进程还存活着这个进程就成了孤儿进程为了保证每个进程都有一个父进程孤儿进程会被进程领养进程成为了孤儿进程的养父进程当孤儿进程退出之后由进程完成对孤儿进程的回收僵尸进程子进程先退出父进程没有完全对子进程的回收此时子进程就变成了僵尸进程解决僵尸进程不能使用杀死僵尸进程原因是僵尸进程是一个死掉的进程应该使用杀死僵尸父进程的方法来解决僵尸进程原因是杀死其父进程可以让进程领养僵尸进程最后由进程回收僵尸进程进程回收函数函数函数原型函数作用阻塞并等待子进程退出回收子进程残留资源获取于进程结束状态退出原因返回值成功清理掉的子进程失败没有子进程参数子进程的退出状态传出参数为非进程正常结束获取进程退出状态为非进程异常终止取得进程终止的信号编号函数函数原型函数作用同函数函数参数参数等待任一子进程与等效等待其进程与相等的子进程等待进程组与目前进程相同的任何子进程也就是说任何和调函数的进程在同一个进程组的进程等待其组等于的绝对值的任一子进程适用于子进程在其他组的情况子进程的退出状态用法同函数设置为函数非阻塞设置为函数阻塞函数返回值返回回收掉的子进程无子进程参为且子进程正在运行进程间通信进程间通信相关概念环境下进程地址空间相互独立每个进程各自有不同的用户地址空间任何一个进程的全局变量在另一个进程中都看不到所以进程和进程之间不能相互访问要交换数据必须通过内核在内核中开辟一块缓冲区进程把数据从用户空间拷到内核缓冲区进程再从内核缓冲区把数据读走内核提供的这种机制称为进程间通信进程间通信的方式在进程间完成数据传递需要借助操作系统提供特殊的方法如文件管道信号共享内存消息队列套接字命名管道等随着计算机的蓬勃发展一些方法由于自身设计缺陷被淘汰或者弃用现今常用的进程间通信方式有管道使用最简单信号开销最小共享映射区无血缘关系本地套接字最稳定管道管道的概念管道是一种最基本的机制也称匿名管道应用于有血缘关系的进程之间完成数据传递调用函数即可创建一个管道特质管道的本质是一块内核缓冲区由两个文件描述符引用一个表示读端一个表示写端规定数据从管道的写端流入管道从读端流出当两个进程都终结的时候管道也自动消失管道的读端和写端默认都是阻塞的管道的原理管道的实质是内核缓冲区内部使用环形队列实现默认缓冲区大小为可以使用命令获取大小实际操作过程中缓冲区会根据数据压力做适当调整管道的局限性数据一旦被读走便不在管道中存在不可反复读取数据只能在一个方向上流动若要实现双向流动必须使用两个管道只能在有血缘关系的进程间使用管道创建管道函数函数作用创建一个管道函数原型函数参数若函数调用成功存放管道的读端存放管道的写端返回值成功返回失败返回并设置值函数调用成功返回读端和写端的文件描述符其中是读端是写端向管道读写数据是通过使用这两个文件描述符进行的读写管道的实质是操作内核缓冲区父子进程使用管道通信一个进程在由创建管道后一般再一个子进程然后通过管道实现父子间的通信只要有共同祖先都可以采用管道的方式进行通信父子进程间具有相同的文件描述符且指向同一个管道其他没有关系的进程不能获得产生的两个文件描述符也就不能利用同一个管道进行通信第一步父进程创建管道之前创建第二步父进程出子进程第三步父进程关闭子进程关闭根据需要例例父子进程间完成管道的读写行为读操作有数据正常读返回读出的字节数无数据写端全部关闭解除阻塞返回相当于读文件读到了尾部写操作读端全部关闭管道破裂进程终止内核给当前进程发信号读端没全部关闭缓冲区写满了阻塞缓冲区没有满继续如何设置管道为非阻塞默认情况下管道的读写两端都是阻塞的若要设置读或者写端为非阻塞参考下列三个步骤进行第步第步第步若是读端设置为非阻塞写端没有关闭管道中没有数据可读则返回写端没有关闭管道中有数据可读则返回实际读到的字节数写端已经关闭管道中有数据可读则返回实际读到的字节数写端已经关闭管道中没有数据可读则返回查看管道缓冲区大小命令函数介绍常被称为命名管道以区分管道管道只能用于有血缘关系的进程间通信但通过不相关的进程也能交换数据是基础文件类型中的一种文件类型为可通过查看文件类型但文件在磁盘上没有数据块文件大小为仅仅用来标识内核中一条通道进程可以打开这个文件进行实际上是在读写内核缓冲区这样就实现了进程间通信创建管道方式使用命令命令格式管道名例如方式使用函数参数说明和返回值可以查看当创建了一个就可以使用函数打开它常见的文件函数都可用于如等严格遵循先进先出对的读总是从开始处返回数据对它们的写则把数据添加到末尾它们不支持诸如等文件定位操作使用完成两个进程通信示意图思路进程创建一个文件调用函数打开文件调用函数写入一个字符串如其实是将数据写入到了内核缓冲区调用函数关闭文件进程调用函数打开文件调用函数读取文件内容其实就是从内核中读取数据此时进程的文件不能关闭关闭则没有数据打印显示读取的内容调用函数关闭文件内存映射区介绍存储映射使一个磁盘文件与存储空间中的一个缓冲区相映射从缓冲区中取数据就相当于读文件中的相应字节将数据写入缓冲区则会将数据写入文件这样就可在不使用和函数的情况下使用地址指针完成操作使用存储映射这种方法首先应通知内核将一个指定文件映射到存储区域中这个映射工作可以通过函数来实现函数函数作用建立存储映射区函数原型函数返回值成功返回创建的映射区首地址失败宏参数指定映射的起始地址通常设为由系统指定映射到内存的文件长度或者函数映射区的保护方式最常用的读写读写对映射区的修改会反映到文件中可以对文件进行修改对映射区的修改不会对文件产生影响打开的文件描述符以文件开始处的偏移量必须是的整数倍通常为表示从文件头开始映射返回值映射区的首地址函数函数作用释放由函数建立的存储映射区函数原型返回值成功返回失败返回设置值函数参数调用函数成功返回的映射区首地址注意事项创建映射区的过程中隐含着一次对映射文件的读操作将文件内容读取到映射区当时要求映射区的权限应文件打开的权限出于对映射区的保护而则无所谓因为中的权限是对内存的限制映射区的释放与文件关闭无关只要映射建立成功文件可以立即关闭特别注意当映射文件大小为时不能创建映射区所以用于映射的文件必须要有实际大小使用时常常会出现总线错误通常是由于共享文件存储空间大小引起的传入的地址一定是的返回地址坚决杜绝指针操作文件偏移量必须为或者的整数倍创建映射区出错概率非常高一定要检查返回值确保映射区建立成功再进行后续操作函数的使用总结第一个参数写成第二个参数要映射的文件大小第三个参数第四个参数或者第五个参数打开的文件对应的文件描述符第六个参数的整数信使用函数建立匿名映射只能用于有血缘关系的进程间通信必须与一起使用而且指定为信号相关查看所有信号介绍信号的概念信号是信息的载体环境下古老经典的通信方式现下依然是主要的通信手段信号的特点简单不能携带大量信息满足某个特点条件才会产生机制进程给进程发送信号进程收到信号之前执行自己的代码收到信号后不管执行到程序的什么位置都要暂停运行去处理信号处理完毕后再继续执行与硬件中断类似异步模式但信号是软件层面上实现的中断早期常被称为软中断每个进程收到的所有信号都是由内核负责发送的进程给进程发送信号示意图信号优先级高于普通操作信号的状态信号有三种状态产生未决和递达信号的产生按键产生如系统调用产生如软件条件产生如定时器硬件异常产生如非法访问内存段错误除浮点数例外内存对齐出错总线错误命令产生如命令未决产生和递达之间的状态主要由于阻塞屏蔽导致该状态递达递送并且到达进程信号的处理方式执行默认动作忽略信号丢弃不处理捕捉信号调用用户的自定义的处理函数信号的特质信号的实现手段导致信号有很强的延时性但对于用户来说时间非常短不易察觉内核的进程控制块是一个结构体除了包含进程状态工作目录用户组文件描述符表还包含了信号相关的信息主要指阻塞信号集和未决信号集阻塞信号集和未决信号集信号的四要素通过可以查看信号相关信息信号的编号使用命令可以查看当前系统有哪些信号不存在编号为的信号其中号信号称之为常规信号也叫普通信号或标准信号称之为实时信号驱动编程与硬件相关信号的名称产生信号的事件信号的默认处理动作终止进程忽略信号默认即时对该种信号忽略操作终止进程生成文件查验死亡原因用于调试停止暂停进程继续运行进程特别需要注意的是几个常用到的信号信号相关函数函数函数作用注册信号捕捉函数函数原型函数参数信号编号信号处理函数函数命令描述给指定进程发送指定信号命令进程函数原型函数返回值成功失败设置函数参数信号参数不推荐直接使用数字应使用宏名因为不同操作系统信号编号可能不同但名称一致参数发送信号给指定的进程发送信号给与调用函数进程属于同一进程组的所有进程取发给对应进程组发送给进程有权限发送的系统中所有进程进程组每个进程都属于一个进程组进程组是一个或多个进程集合他们相互关联共同完成一个实体任务每个进程组都有一个进程组长默认进程组与进程组长相同函数函数函数描述给当前进程发送指定信号自己给自己发函数原型函数返回值成功失败非值函数拓展函数函数描述给自己发送异常终止信号并产生文件函数原型函数拓展函数函数原型函数描述设置定时器闹钟在指定后内核会给当前进程发送信号进程收到该信号默认动作终止每个进程都有且只有唯一的一个定时器函数返回值调用函数后直接返回或剩余的秒数无失败例如常用操作取消定时器返回旧闹钟余下秒数使用的是自然定时法与进程状态无关就绪运行挂起阻塞暂停终止僵尸无论进程处于何种状态都计时闹钟实际执行时间系统时间用户时间损耗时间损耗时间实际执行时间系统时间用户时间原因是调用函数打印数字遇到才会打印打印过程涉及到从用户区到内核区的切换切换次数越多消耗的时间越长效率越低而使用文件重定向由于文件操作是带缓冲的所以涉及到用户区到内核区的切换次数大大减少从而使损耗降低函数函数原型函数描述设置定时器闹钟可代替函数精度微秒可以实现周期定时函数返回值成功失败设置值函数参数指定定时方式自然定时计算自然时间虚拟空间计时用户空间只计算进程占用的时间运行时计时用户内核计算占用及执行系统调用的时间负责设定时间设定第一次执行所延迟的秒数设定以后每几秒执行闹钟触发周期闹钟触发时间秒微秒存放旧的值一般指定为信号集相关未决信号集和阻塞信号集的关系阻塞信号集是当前进程要阻塞的信号的集合未决信号集是当前进程中还处于未决状态的信号的集合这两个集合存储在内核的中下面以为例说明信号未决信号集和阻塞信号集的关系当进程收到一个信号信号编号为首先这个信号会保存在未决信号集合中此时对应的号编号的这个位置上置为表示处于未决状态在这个信号需要被处理之前首先要在阻塞信号集中的编号为的位置上去检查该值是否为如果为表示信号被当前进程阻塞了这个信号暂时不被处理所以未决信号集上该位置上的值保持为表示该信号处于未决状态如果为表示信号没有被当前进程阻塞这个信号需要被处理内核会对信号进行处理执行默认动作忽略或者执行用户自定义的信号处理函数并将未决信号集中编号为的位置上将变为表示该信号已经处理了这个时间非常短暂用户感知不到当信号从阻塞信号集中解除阻塞之后该信号就会被处理上述变量类型的定义的查找有个小窍门可以执行的预处理命令这样头文件就会展开可以直接到文件中看到相关变量类型的定义信号集相关函数由于信号集属于内核的一块区域用户不能直接操作内核空间为此内核提供一些信号集相关的接口函数使用这些函数用户就可以完成对信号集的相关作信号集是一个能表示多个信号的数据类型即一个信号集既然一个集合就需要对集进行添加删除等操作类型的定义在文件中的第行处的定义在文件中的行处信号集相关函数函数说明将某个信号集清函数返回值成功失败设置函数说明将某个信号集置函数返回值成功失败设置函数说明将某个信号加入信号集合中函数返回值成功失败设置函数说明将某信号从信号清出信号集函数返回值成功失败设置函数说明判断某个信号是否在信号集中函数返回值在不在失败设置函数说明用来屏蔽信号解除屏蔽也使用该函数其本质读取或修改进程控制块中的信号屏蔽字阻塞信号集特别注意屏蔽信号只是将信号处理延后执行延至解除屏蔽而忽略表示将信号丢弃处理函数原型函数返回值成功失败设置函数参数参数取值假设当前的信号屏蔽字为当设置为此值表示需要屏蔽的信号相当于当设置为此表示需要解除屏蔽的信号相当于当设置为此表示用于替代原始屏蔽及新屏蔽集相当于若调用解除了对当若千个信号的阻塞则在返回前至少将其中一个信号递达传入参数是一个自定义信号集合由参数来指示如何修改当前信号屏蔽字传出参数保存旧的信号屏蔽字函数原型函数说明读取当前进程的未决信号集函数参数传出参数函数返回值成功失败设置信号捕捉函数函数函数函数说明注册一个信号处理函数函数原型函数参数捕捉的信号传入参数新的处理方式传出参数旧的处理方式信号处理函数信号处理函数信号处理函数执行期间需要阻塞的信号通常为表示使用默认标识总结指定信号捕捉后的处理函数名即注册函数也可赋值为表忽略或表执行默认动作用来指定在信号处理函数执行期间需要被屏蔽的信号特别是当某个信号被处理时它自身会被自动放入进程的信号掩码因此在信号处理函数执行期间这个信号不会再度发生注意仅在处理函数被调用期间屏蔽生效是临时性设置通常设置为使用默认属性已不再使用在信号处理函数执行期间若信号再次产生多次则信号处理函数不会被打断当信号处理函数执行完以后后来产生的信号只会被处理一次信号不支持排队在信号处理函数执行期间前提是中阻塞了信号若收到了多次信号则信号会被阻塞当信号处理函数执行完毕后则信号只会被处理一次内核实现信号捕捉的过程如果信号的处理动作是用户自定义函数在信号递达时就调用这个函数这称为捕捉信号由于信号处理函数的代码是在用户空间的处理过程比较复杂举例如下用户程序注册了信号的处理函数当前正在执行函数这时发生中断或异常切换到内核态在中断处理完毕后要返回用户态的函数之前检查到有信号递达内核决定返回用户态后不是恢复函数的上下文继续执行而是执行函数和函数使用不同的堆栈空间它们之间不存在调用和被调用的关系是两个独立的控制流程函数返回后自动执行特殊的系统调用再次进入内核态如果没有新的信号要递达这次再返回用户态就是恢复函数的上下文继续执行了信号产生信号的条件子进程结束的时候子进程收到信号当子进程停止时收到信号信号的作用子进程退出后内核会给它的父进程发送信号父进程收到这个信号后可以对子进程进行回收使用信号完成对子进程的回收可以避免父进程阻塞等待而不能执行其他操作只有当父进程收到信号之后才去调用信号捕捉函数完成对子进程的回收未收到信号之前可以处理其他操作使用信号完成对子进程的回收注意点有可能还未完成信号处理函数的注册三个子进程都退出了解决办法可以在之前先将信号阻塞当完成信号处理函数的注册后在解除阻塞当信号函数处理期间信号若再次产生是被阻塞的而且若产生了多次则该信号只会被处理一次这样可能会产生僵尸进程解决办法可以在信号处理函数里面使用循环回收这样就有可能出现捕获一次信号但是回收了多个子进程的情况从而可以避免产生僵尸进程守护进程和线程守护进程守护进程介绍精灵进程是中的后台服务进程通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件一般采用以结尾的名字如后台的一些系统服务进程没有控制终端不能直接和用户交互不受用户登录注销的影响一直在运行着他们都是守护进程如预读入缓输出机制的实现服务器服务器等总结守护进程的特点后台服务进程独立于控制终端周期性的执行某种任务不受用户登陆和注销的影响一般采用以结尾的名字进程组和会话进程组进程组是一个或者多个进程的集合每个进程都属于一个进程组引入进程组是为了简化对进程的管理当父进程创建子进程的时候默认子进程与父进程属于同一个进程组进程组第一个进程组长进程如父进程创建了多个子进程父进程和多个子进程同属于一个组而由于父进程是进程组里的第一个进程所以父进程就是这个组的组长组长父进程可以使用进程组负的来将整个进程组内的进程全部杀死只要进程组中有一个进程存在进程组就存在与组长进程是否终止无关进程组生存期从进程组创建到最后一个进程离开会话一个会话是一个或多个进程组的集合创建会话的进程不能是进程组组长创建会话的进程成为一个进程组的组长进程同时也成为会话的会长需要有权限不需要新创建的会话丢弃原有的控制终端建立新会话时先调用父进程终止子进程调用函数可以使用来查看进程组和会话可以出几个子进程然后查看进程组和会话进程组和会话的关系图创建守护进程的模型第步子进程父进程退出子进程继承了父进程的进程组但具有一个新的进程这样就保证了子进程不是一个进程组的组长这对于下面要做的函数的调用是必要的前提条件第步子进程调用函数创建新会话调用这个函数以后该进程成为新会话的首进程是会话的会长成为一个新进程组的组长进程是进程组组长不受控制终端的影响第步改变当前工作目录如在盘上启动这个程序这个程序的当前的工作目录就是这个盘如果盘拔掉后进程的当前工作目录将消失将不能正常工作第步重设文件掩码子进程会继承父进程的掩码增加子进程程序操作的灵活性增加子进程程序操作的灵活性第步关闭文件描述符守护进程不受控制终端的影响所以可以关闭以释放资源第步执行核心工作守护进程的核心代码逻辑线程什么是线程轻量级的进程在环境下线程的本质仍是进程进程拥有独立的地址空间拥有相当于独居线程有但没有独立的地址空间多个线程共享进程空间相当于合租在操作系统下线程最小的执行单位进程最小分配资源单位可看成是只有一个线程的进程线程的特点线程的特点类系统中早期是没有线程概念的年代才引入借助进程机制实现出了线程的概念因此在这类系统中进程和线程关系密切线程是轻量级进程也有创建线程使用的底层函数和进程一样都是从内核里看进程和线程是一样的都有各自不同的进程可以蜕变成线程在下线程最是小的执行单位进程是最小的分配资源单位查看指定线程的号实际上无论是创建进程的还是创建线程的底层实现都是调用同一个内核函数如果复制对方的地址空间那么就产出一个进程如果共享对方的地址空间就产生一个线程内核是不区分进程和线程的只在用户层面上进行区分所以线程所有操作函数是库函数而非系统调用线程共享资源文件描述符表每种信号的处理方式当前工作目录用户和组内存地址空间共享库线程非共享资源线程处理器现场和栈指针内核栈独立的栈空间用户空间栈变量信号屏蔽字调度优先级线程优缺点优点提高程序并发性开销小数据通信共享数据方便缺点库函数不稳定调试编写困难对信号支持不好优点相对突出缺点均不是硬伤下由于实现方法导致进程线程差别不是很大函数作用创建一个新线程函数原型返回值成功返回失败返回函数参数指向类型的指针用于存储新创建的线程的标识符指向类型的指针用于指定线程的属性如果传递则使用默认属性线程属性包括线程栈大小调度策略调度参数等新线程将执行的函数的地址函数指针该函数必须返回类型并接受一个类型的参数传递给函数的参数它的类型是因此可以传递任何类型的数据但在函数内部需要适当地进行类型转换注意点由于的错误码不保存在中因此不能直接用打印错误信息可以先用把错误码转换成错误信息再打印如果任意一个线程调用了或则整个进程的所有线程都终止由于从函数也相当于调用为了防止新创建的线程还没有得到执行就终止我们在函数之前延时秒这只是一种权宜之计即使主线程等待秒内核也不一定会调度新创建的线程执行创建多个线程时不能使多个子线种都共享同一块内存空间应该使每个子线程访问不同的内存空间可以在主线程定义一个数组然后创建线程的时候分别传递不同的数组元素这样每个子线程访问的就是互不相同的内存空间这样就可以打印正确的值如果主线程早于子线程退出则子线程可能得不到执行因为主线程退出整个进程空间都会被回收子线程没有了生存空间所以也就得不到执行线程之间包含主线程和子线程可以共享同一变量包含全局变量或者非全局变量但是非全局变量必须在其有效的生存期内在线程中禁止调用函数否则会导致整个进程退出取而代之的是调用函数这个函数是使一个线程退出如果主线程调用函数也不会使整个进程退出不影响其他线程的执行函数描述将单个线程退出函数原型函数参数表示线程退出状态通常传另注意或者返回的指针所指向的内存单元必须是全局的或者是用分配的不能在线程函数的栈上分配因为当其它线程得到这个返回指针时线程函数已经退出了栈空间就会被回收函数描述阻塞等待线程退出获取线程退出状态其作用对应进程中的函数函数原型函数返回值成功失败错误号函数参数线程存储线程结束状态整个指针和的参数是同一块内存地址线程分离状态指定该状态线程主动与主控线程断开关系线程结束后其退出状态不由其他线程获取而直接自己自动释放网络多线程服务器常用进程若有该机制将不会产生僵尸进程僵尸进程的产生主要由于进程死后大部分资源被释放一点残留资源仍存于系统中导致内核认为该进程仍存在也可使用函数参线程属性来设置线程分离函数是在创建线程之后调用的函数描述实现线程分离函数原型函数返回值成功失败错误号一般情况下线程终止后其终止状态一直保留到其它线程调用获取它的状态为止但是线程也可以被置为状态这样的线程一旦终止就立刻回收它占用的所有资源而不保留终止状态不能对一个已经处于状态的线程调用这样的调用将返回错误也就是说如果已经对一个线程调里了就不能再调用了函数描述杀死取消线程其作用对应进程中函数函数原型函数返回值成功失败错误号注意线程的取消并不是实时的而有一定的延时需要等待线程到达某个取消点检查点类似于玩游戏存档必须到达指定的场所存档点如客栈仓库城里等才能存储进度杀死线程也不是立刻就能完成必须要到达取消点取消点是线程检查是否被取消并按请求进行动作的一个位置通常是一些系统调用执行命令可以查看具备这些取消点的系统调用列表可粗略认为一个系统调用进入内核即为一个取消点还以通过调用函数设置一个取消点函数原型函数描述比较两个线程是否相等函数原型注意这个函数是为了以能够扩展使用的有可能在未来线程类型被修改为结构体实现进程函数和线程函数比较线程属性下线程的属性是可以根据实际项目需要进行设置之前讨论的线程都是采用线程的默认属性默认属性已经可以解决绝大多数开发时遇到的问题如果对程序的性能提出更高的要求则需要设置线程属性本节以设置线程的分离属性为例讲解设置线程属性线程的分离状态决定一个线程以什么样的方式来终止自己有两种状态非分离状态线程的默认属性是非分离状态这种情况下原有的线程等待创建的线程结束只有当函数返回时创建的线程才算终止才能释放自己占用的系统资源分离状态分离线程没有被其他的线程所等待自己运行结束了线程也就终止了马上释放系统资源应该根据自己的需要选择适当的分离状态设置线程属性分为以下步骤第步定义线程属性类型类型的变量第步对线程属性变量进行初始化第步设置线程为分离属性参数线程属性分离非分离这一步完成之后调用函数创建线程则创建出来的线程就是分离线程其实上述三步就是的第二个参数做准备工作第步释放线程属性资源参数线程属性线程同步线程同步的概念线程同步指一个线程发出谋一功能调用时在没有得到结果之前该调用不返回同时其它线程为保证数据一致性不能调用该功能创建两个线程让两个线程共享一个全局变量然后让每个线程数次数看最后打印出这个值是多少数据混乱的原因资源共享独享资源则不会调度随机线程操作共享资源的先后顺序不确定线程间缺乏必要的同步机制线程间缺乏必要的同步机制如何解决问题原子操作的概念原子操作指的是该操作要么不做要么就完成使用互斥锁解决同步问题使用互斥锁其实是模拟原子操作互斥锁示意图中提供一把互斥锁也称之为互斥量每个线程在对资源操作前都尝试先加锁成功加锁才能操作操作结束解锁资源还是共享的线程间也还是竞争的但通过锁就将资源的访问变成互斥操作而后与时间有关的错误也不会再产生了线程访问共享资源的时候要先判断锁是否锁着如果锁着就阻塞等待若锁是解开的就将这把锁加锁此时可以访问共享资源访问完成后释放锁这样其他线程就有机会获得锁应该注意图中同一时刻只能有一个线程持有该锁只要该线程未完成操作就不释放锁使用互斥锁之后两个线程由并行操作变成了串行操作效率降低了但是数据不一致的问题得到解决了互斥锁主要相关函数类型其本质是一个结构体为简化理解应用时可忽略其实现细节简单当成整数看待变量只有两种取值函数描述初始化一个互斥锁互斥量初值可看作函数原型函数参数传出参数调用时应传互斥锁属性是一个传入参数通常传选用默认属性线程间共享关键字只用于限制指针告诉编译器所有修改该指针指向内存中内容的操作只能通过本指针完成不能通过除本指针以外的其他变量或指针修改互斥量的两种初始化方式静态初始化如果互斥锁是静态分配的定义在全局或加了关键字修饰可以直接使用宏进行初始化动态初始化局部变量应采用动态初始化函数描述销毁一个互斥锁函数原型函数参数互锁变量函数描述阻塞函数对互斥所加锁可理解为将函数原型函数参数互斥锁变量函数描述对互斥所解锁可理解为将函数原型函数描述尝试加锁函数原型函数参数互斥锁变量加锁和解锁尝试加锁如果加锁不成功线程阻塞阻塞到持有该互斥量的其他线程解锁为止主动解锁函数同时将阻塞在该锁上的所有线程全部唤醒至于哪个线程先被唤醒取决于优先级调度默认先阻塞先唤醒互斥锁互斥锁的使用步骤第步创建一把互斥锁初始化互斥锁相当于在代码中寻找共享资源也称为临界区临界区代码释放互斥锁资源注意必须在所有操作共享资源的线程上都加上锁否则不能起到同步的效果死锁死锁并不是提供给用户的一种使用方法而是由于用户使用互斥锁不当引起的一种现象常见的死锁有两种第一种自己锁自己如下图代码片段加锁解锁第二种线程拥有锁请求获得锁线程拥有锁请求获得锁这样造成线程和线程都不释放自己的锁而且还想得到对方的锁从而产生死锁如下图所示如何解决死锁让线程按照一定的顺序去访问共享资源在访问其他锁的时候需要先将自己的锁解开调用如果加锁不成功会立刻返回读写锁什么是读写锁读写锁也叫共享独占锁当读写锁以读模式锁住时它是以共享模式锁住的当它以写模式锁住时它是以独占模式锁住的写独占读共享读写锁使用场合读写锁非常适合于对数据结构读的次数远大于写的情况读写锁特性读写锁是写模式加锁时解锁前所有对该锁加锁的线程都会被阻塞读写锁是读模式加锁时如果线程以读模式对其加锁会成功如果线程以写模式加锁会阻塞读写锁是读模式加锁时既有试图以写模式加锁的线程也有试图以读模式加锁的线程那么读写锁会阻塞随后的读模式锁请求优先满足写模式锁读锁写锁并行阻塞写锁优先级高读写锁主要操作函数定义一把读写锁初始化读写锁函数参数读写锁读写锁属性传为默认属性销毁读写锁加读锁尝试加读锁条件变量条件本身不是锁但它也可以造成线程阻塞通常与互斥锁配合使用给多线程提供一个会合的场所使用互斥量保护共享数据使用条件变量可以使线程阻塞等待某个条件的发生当条件满足的时候解除阻塞条件变量的两个动作条件不满足阻塞线程条件满足通知阻塞的线程解除阻塞开始工作条件变量相关函数定义一个条件变量函数原型函数描述初始化条件变量函数参数条件变量条件变量属性通常传函数返回值成功返回失败返回错误号函数原型函数描述销毁条件变量函数参数条件变量返回值成功返回失败返回错误号函数原型函数描述条件不满足引起线程阻塞并解锁条件满足解除线程阻塞并加锁函数参数条件变量互斥锁变量函数返回值成功返回失败返回错误号函数原型函数描述唤醒至少一个阻塞在该条件变量上的线程函数参数条件变量函数返回值成功返回失败返回错误号使用条件变量的代码片段上述代码中生产者线程调用函数会使消费者线程处解除阻塞条件变量定义条件变量初始化条变量在生成者线程中调用在消费者线程中调用释放条件变量多个生成者和多个消费者程序在执行的时候掉的原因分析假若只有一个生产者生产了一个节点此时会调用通知消费者线程此时若有多个消费者被唤醒了则最终只有一个消费者获得锁然后进行消费此时会将置为然后其余的几个消费者线程只会有一个线程获得锁然后读取的内容就会掉在使用条件变量的线程中能够引起线程的阻塞的地方有两个在条件变量处引起阻塞这个阻塞会被解除阻塞互斥锁也会使线程引起阻塞其他线程解锁会使该线程解除阻塞信号量信号量介绍信号量相当于多把锁可以理解为是加强版的互斥锁相关函数定义信号量函数原型函数描述初始化信号量函数参数信号量变量表示线程同步表示进程同步最多有几个线程操作共享数据函数返回值成功返回失败返回并设置值函数原型函数描述调用该函数一次相当于当为的时候引起阻塞函数参数信号量变量函数返回值成功返回失败返回并设置值函数原型函数描述调用一次相当于函数参数信号量变量函数返回值成功返回失败返回并设置值函数原型函数描述尝试加锁若失败直接返回不阻塞函数参数信号量变量函数返回值成功返回失败返回并设置值函数原型函数描述销毁信号量函数参数信号量变量函教返回值成功返回失败返回并设置值网络编程网络基础协议概念概念协议事先约定好大家共同遵守的一组规则从应用程序的角度看协议可理解为数据传输和数据解释的规则可以简单的理解为各个主机之间进行通信所使用的共同语言假设双方欲传输文件规定第一次传输文件名接收方接收到文件名应答给传输方第二次发送文件的尺寸接收方接收到该数据再次应答一个第三次传输文件内容同样接收方接收数据完成后应答表示文件内容接收成功这种在和之间被遵守的协议称之为原始协议后来经过不断增加完善改进最终形成了一个稳定的完整的传输协议被广泛应用于各种文件传输该协议逐渐就成了一个标准协议典型协议传输层常见协议有协议应用层常见的协以有协议协议网络层常见协议有协议协议议网络接口层常见办议有协议协议传输控制协议是一种面向连接的可靠的基于字节流的传输层通信协议用户数据报协议是参考模型中一种无连接的传输层协议提供而向事务的简单不可靠信息传送服务超文本传输协议是互联网上应用最为广泛的一种网络协议文件传输协议协议是因特网互联协议办议是控制报文协议它是协议族的一个子协议用于在主机路由器之间传递控制消息协议是组管理协议是因特网协议家族中的一个组播协该协议运行在主机和组播路由器之间协议是正向地址解析协议通过已知的寻找对应主机的地址是反向地址转换协议通过地址确定地址七层模型四层模型是的缩写意为开放式系统互联国际标准化组织制定了模型该模型定义了不同计算机互联的标准是设计和描述计算机网络通信的基本框架网络分层层模型物数网传会表应物理层双绞线光纤传输介质将模拟信号转换为数字信号数据链路层数据校验定义了网络传输的基本单位帧网络层定义网络两台机器之间传输的路径选择点到点的传输传输层传输数据端到端的传输会话层通过传输层建立数据传输的通道表示层编解码翻译工作应用层为客户提供各种应用服务服务服务服务网络应用程序设计模式模式传统的网络应用设计模式客户机服务器模式需要在通讯两端各自部署客户机和服务器来完成数据通信模式浏览器服务器模式只需在一端部署服务器而另外一端使用每台都默认配置的浏览器即可完成数据的传输优缺点对于模式来说其优点明显客户端位于目标主机上可以保证性能将数据缓存至客户端本地从而提高数据传输效率且一般来说客户端和服务器程序由一个开发团队创作所以他们之间所采用的协议相对灵活可以在标准协议的基础上根据需求裁剪及定制例如腾讯公司所采用的通信协议即为协议的修改剪裁版因此传统的网络应用程序及较大型的网络应用程序都首选模式进行开发如知名的网络游戏魔兽世界画面数据量庞大使用模式可以提前在本地进行大量数据的缓存处理从而提高观感模式的缺点也较突出由于客户端和服务器都需要有一个开发团队来完成开发工作量将成倍提升开发周期较长另外从用户角度出发需要将客户端安插至用户主机上对用户主机的安全性构成威胁这也是很多用户不愿使用模式应用程序的重要原因模式相比模式而言由于它没有独立的客户端使用标准浏览器作为客户端其工作开发量较小只需开发服务器端即可另外由于其采用浏览器显示数据因此移植性非常好不受平台限制如早期的偷菜游戏在各个平台上都可以完美运行模式的缺点也较明量由于使用第三方浏览器因此网络应用支持受限另外没有客户端放到对方主机上缓存数据不尽如人意从而传输数据量受到限制应用的观感大打折扣第三必须与浏览器一样采用标准协议进行通信协议选择不灵活因此在开发式中模式的选择由上述各自的特点决定根据实际需求选择应用程序设计模式以太网帧格式以太网帧格式就是包装在网络接口层数据链路层的协议以为例介绍以太网帧格式目的端地址是通过发送端发送广播接收到该数据的主机先判断是否是自己的若是则应答一个应答报文并将地址填入应答报文中若目的不是自己的主机则直接丢弃该请求报文例不知道目标地址用段格式协议版本位总长度最大位生存时间网络连接下一跳的次数为了防止网络阻塞位源地址共个字节我们熟悉的都是点分十进制的字节每字节对应一个点分位最大为实际上就是整形数位目的地址位协议用来区分上层协议是还是协议位首部校验和只校验首部数据的校验由更高层协议负责数据报格式通过地址来确定网络环境中的唯一的一台主机主机上使用端口号来区分不同的应用程序端口唯一确定唯一一台主机上的一个应用程序数据流格式表示请求表示确认服务端发送的和客户端发送的本身也会占位三次握手和四次挥手的过程都是在内核实现的稳定的安全的可靠的序号是安全可靠的每个数据包都带有序号当数据包丢失的时候需要重传要使用序号进行重传控制数据有序丢包重传确认序号使用确认序号可以知道对方是否已经收到了通过确认序号可以知道哪个序号的数据需要重传位窗口大小滑动窗口主要进行流量控制为什么是面向连接的安全可靠的传输是面向连接的安全的数据传输在客户端与服务端建立建立的时候要经过三次握手的过程在客户端与服务端断开连接的时候要经历四次挥手的过程下图是客户端与服务端三次握手建立连接数据传输和断开连接四次挥手的全过程是指最大报文段长度它是协议的一个选项用于在连接建立时收发双方协商通信时每一个报文段所能承载的最大数据长度不包括文段头的设定对于连接的传输效率有重要影响因为它决定了层每次能够传输的最大数据分段大小对方一次可以接受多少数据最大传输单元通信术语及大传输单元是指一种通信协议的某一层上面所能通过的最大数据包大小以字节为单位最大传输单元这个参数通常与通信接口有关网络接口卡串口等这个值如果设置为太大会导致丢包重传的时候重传的数据量较大图中的最大值是其实是一个经验值三次握手发送数据四次挥手测试过程中可以使用命令查看监听状态和连接状态命令表示显示所有表示显示的时候以数字的方式来显示表示显示进程信息进程名和进程滑动窗口主要作用滑动窗口主要是进行流量控制的见下图如果发送端发送的速度较快接收端接收到数据后处理的速度较慢而接收缓冲区的大小是固定的就会导致接收缓冲区满而丢失数据协议通过滑动窗口机制解决这一问题函数封装思想函数封装的思想处理异常情况结合和进行封装在封装的时候起名可以把第一个函数名的字母大写如可以封装成这样可以按进行搜索搜索函数说明的时候不区分大小写使用也可以査看对大小写不区分像这样的能够引起阻塞的函数若被信号打断由于信号的优先级较高会优先处理信号信号处理完成后会使或者解除阻塞然后返回此时返回值为设置表示连接被打断异常宏在文件中包含了所有的宏和对应的错误描述信息粘包多次数据发送收尾相连接收端接收的时候不能正确区分第一次发送多少第二次发送多少即这次读的数据有上一次的数据粘包问题分析和解决方案包头数据如位的数据长度数据其中表示数据长度表示个字节长度的数据另外发送端和接收端可以协商更为复杂的报文结构这个报文结构就相当于双方约定的一个协议方案添加结尾标记如结尾最后一个字符为等方案数据包定长如发送方和接收方约定每次只发送个字节的内容接收方接收定长个字节就可以了网络字节序大端和小端的概念大端高端字节序网络字节序低位地址存放高位数据高位地址存放低位数据小端低端字节序低位地址存放低位数据高位地址存放高位数据大端和小端的使用使用场合大端和小端只是对数据类型长度是两个及以上的如对于单字节没限制在网络中经常需要考虑大端和小端的是和端口例可以看出这台机器是小端低位放在低位中大小端转换函数网络传输用的是大端法如果机器用的是小端法则需要进行大小端的转换下面个函数就是进行大小端转换的函数函数名的表示主机表示网络表示表示上述的几个函数如果本来不需要转换函数内部就不会做转换地址转换函数点分十进制转网络函数说明将字符串形式的点分十进制转换为大端模式的网络整型字节数表示点分十进制的字符串形式到表示网络参数说明字符串形式的点分十进制的地址存放转换后的变量的地址例如网络转点分十进制函数说明网络转换为字符串形式的点分十进制的参数说明网络的整形的地址转换后的地址一般为字符串数组的长度返回值成功返回指向的指针失败返回并设置例如地址为转换为点分十进制的格式由于从网络中的地址是高端模式所以转换为点分十进制后应该为编程传统的进程间通信借助内核提供的机制进行但是只能限于本机通信若要跨机通信就必须使用网络通信本质上借助内核内核提供了伪文件的机制实现通信实际上是使用文件描述符这就需要用到内核提供给用户的函数库既然提到伪文件所以可以使用文件描述符相关的函数可以对比管道讲述文件描述符的区别使用会建立一个如下图一个文件描述符操作两个缓冲区这点跟管道是不同的管道是两个文件描述符操作一个内核缓冲区中结构体通过可以查看相关说明主要函数函数原型函数描述创建参数说明协议版本本地套接字使用协议类型流式默认使用的协议是协议报式默认使用的是协议一般填表示使用对应类型的默认协议返回值成功返回一个大于的文件描述符用于监听失败返回并设置当调用函数以后返回一个文件描述符内核会提供与该文件描述符相对应的读和写缓冲区同时还有两个队列分别是请求连接队列和已连接队列函数原型函数描述将文件描述符和绑定参数说明调用函数返回的文件描述符本地服务器的地址和表示使用本机任意有效的可用变量的占用的内存大小返回值成功返回失败返回并设置函数原型函数描述将套接字由主动态变为被动态参数说明调用函数返回的文件描述符同时请求连接的最大个数还未建立连接返回值成功返回失败返回并设置函数原型函数说明获得一个连接若当前没有连接则会阻塞等待函数参数调用函数返回的文件描述符传出参数保存客户端的地址信息传入传出参数变量所占内存空间大小返回值成功返回一个新的文件描述符通信描述符用于和客户端通信失败返回并设置值函数是一个阻塞函数若没有新的连接请求则一直阻塞从已连接队列中获取一个新的连接并获得一个新的文件描述符该文件描述符用于和客户端通信内核会负责将请求队列中的连接拿到已连接队列中函数原型函数说明连接服务器函数参数调用函数返回的文件描述符服务端的地址信息变量的内存大小返回值成功返回失败返回并设置值读取数据和发送数据对应和这两个函数直接填就可以了注意如果写缓冲区已满也会阻塞读操作的时候若读缓冲区没有数据会引起阻塞当读文件描述符为非阻塞状态的时候若对方没有发送数据会立刻返回设置为这个错误我们要忽略服务端开发流程创建返回一个文件描述符该文件描述符用于监听客户端连接将和进行绑定将由主动变为被动监听接受一个新的连接得到一个文件描述符该文件描述符是用于和客户端进行通信的接收数据或者发送数据或者关闭文件描述符客户端的开发流程创建返回一个文件描述符该文件描述符是用于和服务端通信连接服务端发送数据或者接收数据或者高并发服务器如何支持多个客户端支持多并发的服务器由于和函数都会阻塞如当的时候不能调用接受新的连接当阻塞等待的时候不能读数据第一种方案使用多进程可以让父进程接受新连接让子进程处理与客户端通信思路让父进程接受新连接然后子进程让子进程处理通信子进程处理完成后退出父进程使用信号回收子进程代码实现创建子进程关闭通信文件描述符关闭监听文件描述符收发数据防止子进程继续创建进程注意点或者函数是阻塞函数会被信号打断此时不应该视为一个错误第二种方案使用多线程让主线程接受新连接让子线程处理与客户端通信使用多线程要将线程设置为分离属性让线程在退出之后自己回收资源多线程版本的服务器开发流程创建得到一个监听的文件描述符将和端口进行绑定设置监听接受新的客户端连接请求创建一个子线程设置线程为分离属性子线程执行函数获得参数通信文件描述符读数据通过数组开辟不同内存状态转换图三次握手过程客户端服务端当三次握手完成后都处于状态数据传输过程中状态不发生变化都是状态四次挥手过程主动关闭方被动关闭方的种状态及其含义服务器端等待来自客户端的连接请求客户端发送连接请求后等待服务器的确认服务器收到客户端的连接请求并发送确认等待客户端的最终确认客户端和服务器的连接已经建立可以开始数据传输发起连接终止请求等待对方的确认在状态下收到对方的确认后进入此状态等待对方的连接终止请求对方发起连接终止请求本地端等待关闭连接双方同时尝试关闭连接等待对方确认关闭请求等待对方确认最后的关闭请求等待足够的时间以确保对方收到连接终止请求的确认连接完全关闭不再处于任何其他状态为什么需要原因之一让四次挥手的过程更可靠确保最后一个发送给对方的到达若对方没有收到应答对方会再次发送请求关闭此时在时间内被动关闭方仍然可以发送给对方原因之二为了保证在时间内不能启动相同的一定是出现在主动关闭的一方也就是说是针对主动关闭一方来说的由于有可能存在丢包重传丢包重传若发给了已经断开连接之后相同的该连接是新建的与原来的完全相同双方使用的是相同的和端口这样会对之后的连接造成困扰严重可能引起程序异常的概念客户端与服务端连接其实是一个连接对可以通过使用端口号进行查看如何避免问题呢很多操作系统实现的时候只要端口被占用服务就不能启动端口复用解决端口复用的问题发生这种情况是在服务端主动关闭连接以后接着立刻启动就会报这种错误函数参数标识了选项应用的协议如果选项是通用的套接字层选项设置成否则设置成控制这个选项的协议号例如对于选项这是对于选项这是参数根据选项的不同指向一个数据结构或者一个整数一些选项是开关如果整数非零那么选项被启用如果整数为零那么该选项被禁止参数指定了指向的对象的大小可以使用函数来发现选项的当前值套接字选项例半关闭状态半关闭的概念如果一方另一方没有则认为是半关闭状态处于半关闭状态的时候可以接收数据但是不能发送数据相当于把文件描述符的写缓冲区操作关闭了注意半关闭一定是出现在主动关闭的一方函数长连接和端连接的概念连接建立之后一直不关闭为长连接连接收发数据完毕之后就关闭为短连接和的区别可以实现半关闭不行关闭的时候不考虑文件描述符的引用计数是直接彻底关闭考虑文件描述符的引用计数调用一次只是将引用计数减只有减小到的时候才会真正关闭心跳包主要用于检测与对方的网络连接是否正常主要用于长连接方法由于不能实时的检测网络情况一般不用这种方法方法在应用程序中自己定义心跳包使用灵活能实时把控发送心跳过程服务给发送心跳数据服务收到之后给回复此时收到之后认为连接正常假如连续发送了多次如次之后仍然没有收到的回复则认为连接异常异常之后应该重建连接先原来的连接然后在重新连接就可以了如何让心跳数据和正常的业务数据不混淆解决办法双方可以协商协议如个字节长度具体数据如果发送心跳数据应该如果发送业务数据对方收数据的时候先收个字节的报头数据然后计算长度若最后计算长度为且数据为则认为是心跳数据则服务会组织应答数据给高并发服务器模型多路技术同时监听多个文件描述符将监控的操作交给内核去处理数据类型文件描述符集合本质是位图关于集合可联想一个信号集函数介绍委托内核监控该文件描述符对应的读写或者错误事件的发生参数说明最大的文件描述符读集合是一个传入传出参数传入指的是告诉内核哪些文件描述符需要监控输出参数内核告诉应用程序哪些文件描述符有变化输入参数告诉内核要监控哪些文件描述符输出参数内核告诉应用程序哪些文件描述符有变化输入输出参数一般表示异常事件超时时间表示永久阻塞直到有事件发生表示不阻塞不管有没有事件发生都会立刻返回表示阻塞的时长若没有超过时长则一直阻塞若在时长内有事件发生则立刻返回若超过时长则立刻返回返回值成功返回发生变化的文件描述符个数配套函数说明从集合中清除说明判断是否在集合中说明将添加到集合中说明清空文件描述符集问题如果有效的文件描述符比较少会使循环的次数太多解决办法可以将有效的文件描述符放到一个数组当中这样遍历效率就高优点一个进程可以支持多个客户端支持跨平台缺点代码编写困难会涉及到用户区到内核区的来回拷贝当客户端多个连接但少数活跃的情况效率较低例如作为极端的一种情况文件描述符全部打开但是只有有发送数据就显得效率低下最大支持个客户端连接最大支持个客户端连接不是有文件描述符表最多可以支持个文件描述符限制的而是由限制的使用了该宏当然可以修改内核然后再重新编译内核一般不建议这么做注意不仅可以监控文件描述符也可以监视标准输入多路函数原型函数说明跟类似监控多路但不能跨平台参数说明传入传出参数实际上是一个结构体数组输入参数表示告诉内核要监控的事件读写事件异常事件输出参数表示内核告诉应用程序有哪些文件描述符有事情发生要监控的文件描述符读事件写事件返回的事件数组实际有效内容的个数告诉内核监控的范围具体是数组下标的最大值超时时间单位是毫秒永久阻塞直到监控的事件发生不管是否有事件发生立刻返回表示阻塞时长在时长范围内若有事件发生会立刻返回如果超过了时长也会立刻返回函数返回值发生变化的文件描述符的个数没有文件描述符发生变化表示异常说明当函数返回的时候结构体当中的和没有发生变化究竟有没有事件发生由来判断所以是请求和返回分离结构体中的成员若赋值为则不会监控相对于没有本质上的改变但是可以突破的限制在查看一个进程可以打开的描述符上限如果需要可以修改配置文件加入如下配置信息然后重启终端即可生效和分别表示命令可以修改的最小限制和最大限制将检测文件描述符的变化委托给内核去处理然后内核将发生变化的文件描述符对应的事件返回给应用程序函数原型函数说明创建一个树根参数说明最大节点数此参数在已被忽略但必须传递一个大于的数返回值成功返回一个大于的文件描述符代表整个树的树根失败返回并设置值函数原型函数说明将要监听的节点在树上添加删除和修改参数说明树根添加事件节点到树上从树上删除事件节点修改树上对应的事件节点事件节点对应的文件描述符要操作的事件节点可读事件可写事件异常事件函数原型函数说明委托内核监控树的事件节点参数说明树根节点传出参数结构体数组数组大小表示阻塞表示不阻塞表示阻塞超时时长进阶介绍的两种工作模式的两种模式和模式水平触发高电平代表只要缓冲区中有数据就一直通知默认情况下是模式在这种模式下若读数据一次性没有读完缓冲区中还有可读数据则还会再次通知边缘触发电平有变化就代表缓冲区中有数据只会通知一次之后再有数据才会通知若是读数据的时候没有读完则剩余的数据不会再通知直到有断的数据到来若将设置为模式若读数据的时候一次性没有读完则不再通知直到下次有新的数据发来边缘非阻寒模式提高效率在模式下如何在返回一次的情况下读完数据循环读数据直到读完数据但是读完数据之后会阻塞若能够一次性读完还需要设置什么将通信文件描述符设置为非阻塞模式反应堆或线程池什么是线程池是一个抽象的概念若干个线程组合到一起形成线程池为什么需要线程池多线程版服务器一个客户端就需要创建一个线程若客户端太多显然不太合适什么时候需要创建线程池简单的说如果一个应用需要频繁的创建和销毁线程而任务执行的时间又非常短这样线程创建和销毁的带来的开销就不容忽视这时也是线程池该出场的机会了如果线程创建和销毁时间相比任务执行时间可以忽略不计则没有必要使用线程池了实现的时候类似于生产者和消费者线程池和任务池任务池相当于共享资源所以需要使用互斥锁当任务池中没有任务的时候需要让线程阻塞所以需要使用条件变量如何让线程执行不同的任务使用回到函数在任务中设置任务执行函数这样可以起到不同的任务执行不同的函数子线程负责从任务池冲获取任务每一个任务有一个回调函数每于个回调函数执行不同操作',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-21 13:25:43',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://bu.dusays.com/2021/01/15/249d178a78c81.png"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://kayer.cn/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">KAYER</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=9350162041&amp;server=tencent"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/CPP/" style="font-size: 1.05rem;">CPP<sup>2</sup></a><a href="/tags/Linux/" style="font-size: 1.05rem;">Linux<sup>2</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/10/"><span class="card-archive-list-date">十月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">九月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/" itemprop="url">Linux</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/CPP/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>CPP</span></a><a class="article-meta__tags" href="/tags/Linux/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>Linux</span></a></span></div></div><h1 class="post-title" itemprop="name headline">Linux</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-09-22T08:42:21.000Z" title="发表于 2024-09-22 16:42:21">2024-09-22</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-10-21T05:25:43.096Z" title="更新于 2024-10-21 13:25:43">2024-10-21</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="Linux"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为郑州"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>郑州</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="/img/404.jpg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2024/09/22/Linux/"><header><a class="post-meta-categories" href="/categories/Linux/" itemprop="url">Linux</a><a href="/tags/CPP/" tabindex="-1" itemprop="url">CPP</a><a href="/tags/Linux/" tabindex="-1" itemprop="url">Linux</a><h1 id="CrawlerTitle" itemprop="name headline">Linux</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Kayer</span><time itemprop="dateCreated datePublished" datetime="2024-09-22T08:42:21.000Z" title="发表于 2024-09-22 16:42:21">2024-09-22</time><time itemprop="dateCreated datePublished" datetime="2024-10-21T05:25:43.096Z" title="更新于 2024-10-21 13:25:43">2024-10-21</time></header><h1 id="Linux系统基础"><a href="#Linux系统基础" class="headerlink" title="Linux系统基础"></a>Linux系统基础</h1><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><ol>
<li>常用的命令解释器<ul>
<li>shell - Bourne Shell<ul>
<li>&#x2F;bin&#x2F;sh</li>
</ul>
</li>
<li>bash - Bourne Again Shell<ul>
<li>&#x2F;bin&#x2F;bash</li>
</ul>
</li>
</ul>
</li>
<li>当前系统所使用的shell<ul>
<li>echo $SHELL</li>
</ul>
</li>
<li>当前系统下有哪些shell<ul>
<li>cat &#x2F;etc&#x2F;shells</li>
</ul>
</li>
</ol>
<h2 id="Linux基础命令"><a href="#Linux基础命令" class="headerlink" title="Linux基础命令"></a>Linux基础命令</h2><p>上一条命令：ctrl+p 或 ↑</p>
<p>下一条命令：ctrl+n 或 ↓</p>
<p>history : 显示用户输入的所有命令</p>
<h3 id="光标位置移动"><a href="#光标位置移动" class="headerlink" title="光标位置移动"></a>光标位置移动</h3><p>左移：ctrl+b或←</p>
<p>右移：ctrl+f 或→</p>
<p>移动到头部：ctrl+a（home）</p>
<p>移动到尾部：ctrl+e（end）</p>
<h3 id="字符删除"><a href="#字符删除" class="headerlink" title="字符删除"></a>字符删除</h3><p>删除光标前的单个字符：ctrl+h 或 BackSpace键</p>
<p>删除光标后的单个字符：ctrl+d 或 Delete键</p>
<p>删除光标前所有内容：ctrl+u</p>
<p>删除光标后所有内容：ctrl+k</p>
<h3 id="常见目录"><a href="#常见目录" class="headerlink" title="常见目录"></a>常见目录</h3><p>普通用户：$</p>
<p>超级用户：#</p>
<ul>
<li><p>&#x2F;：根目录</p>
</li>
<li><p>&#x2F;bin：（binary）二进制文件，可执行程序，shell命令	</p>
<ul>
<li><p>如：ls，rm，mv，cp等命令</p>
</li>
<li><p>&#x2F;</p>
</li>
</ul>
<p>	</p>
</li>
<li><p>&#x2F;sbin：（SuperUser）存放的是系统管理员使用的系统管理程序</p>
<ul>
<li>如ifconfig，halt，shutdown，reboot等系统命令</li>
</ul>
</li>
<li><p>&#x2F;dev：（device）Linux下一切皆文件</p>
<ul>
<li>硬盘，显卡，显示器</li>
<li>字符设备文件（鼠标，键盘），块设备文件<ul>
<li>如在input目录下执行：sudo cat mouse0，移动鼠标会显示有输入</li>
</ul>
</li>
</ul>
</li>
<li><p>&#x2F;lib：（library）Linux运行的时候需要加载的一些库</p>
<ul>
<li>如：libc.so，libpthread.so等</li>
</ul>
</li>
<li><p>&#x2F;mnt：手动的挂载目录，如U盘等</p>
</li>
<li><p>&#x2F;media：外设的自动挂载目录，如光驱等</p>
</li>
<li><p>&#x2F;root：Linux的超级用户root的家目录</p>
</li>
<li><p>&#x2F;usr：（unix system resource）类似于Windows的program files目录</p>
<ul>
<li>include目录存放头文件，如stdio.h，string.h，pthread.h</li>
<li>games目录下的小游戏，如sl小火车游戏</li>
</ul>
</li>
<li><p>&#x2F;etc：存放配置文件</p>
<ul>
<li>&#x2F;etc&#x2F;passwd<ul>
<li>可以查看passwd文件的格式信息</li>
</ul>
</li>
<li>&#x2F;etc&#x2F;group<ul>
<li>man 5 group可以查看group文件的格式信息</li>
</ul>
</li>
<li>&#x2F;etc&#x2F;profile<ul>
<li>系统的配置文件，修改该文件会影响这个系统下面的所有用户</li>
</ul>
</li>
</ul>
</li>
<li><p>&#x2F;opt：安装的第三方应用程序</p>
<ul>
<li>比如安装MySql数据库可以在这个目录下</li>
</ul>
</li>
<li><p>&#x2F;home：Linux操作系统所有用户的家目录</p>
<ul>
<li>用户家目录</li>
</ul>
</li>
<li><p>&#x2F;tmp：存放临时文件</p>
<ul>
<li>新建在这个目录下的文件会在系统重启后自动清除</li>
</ul>
</li>
</ul>
<p>​	</p>
<h3 id="文件和目录操作相关命令"><a href="#文件和目录操作相关命令" class="headerlink" title="文件和目录操作相关命令"></a>文件和目录操作相关命令</h3><h4 id="tree命令"><a href="#tree命令" class="headerlink" title="tree命令"></a>tree命令</h4><ul>
<li>tree命令只能查看目录内容，不能查看普通文件内容</li>
<li>以树状形式查看指定目录内容，使用该命令需要安装软件tree<ul>
<li>apt-get update	apt-get install tree</li>
<li>yum install tree</li>
</ul>
</li>
<li>命令使用<ul>
<li>tree：树形结构显示当前目录下的文件信息</li>
<li>tree 目录：树形结构显示当前指定目录下的文件信息</li>
</ul>
</li>
</ul>
<h4 id="ls（list）命令"><a href="#ls（list）命令" class="headerlink" title="ls（list）命令"></a>ls（list）命令</h4><ul>
<li>查看指定目录下的文件信息<ul>
<li>ls：显示当前目录下文件信息</li>
<li>ls 目录或文件名：显示指定目录下文件信息</li>
</ul>
</li>
<li>相关参数<ul>
<li><strong>-a, –all</strong>：显示目录下的所有文件，包括以<code>.</code>开头的隐藏文件（如<code>.bashrc</code>、<code>.ssh</code>等）。</li>
<li><strong>-A, –almost-all</strong>：显示所有文件，但不包括<code>.</code>（当前目录）和<code>..</code>（父目录）这两个特殊目录。</li>
<li><strong>-d</strong>：仅列出目录本身，而不是目录内的内容。通常与<code>-l</code>一起使用来查看目录的详细信息。</li>
<li><strong>-h</strong>：与<code>-l</code>一起使用时，以人类可读的格式（如KB、MB）显示文件大小。</li>
<li><strong>-r</strong>：将结果反向排序，例如，原本按照文件名从小到大排序，使用<code>-r</code>后会变为从大到小。</li>
<li><strong>-R, –recursive</strong>：递归地列出目录下的所有文件和子目录。</li>
<li><strong>-S</strong>：按照文件大小排序，而不是文件名。</li>
<li><strong>-t</strong>：按照文件修改时间排序，最新的文件会排在最前面。</li>
<li><strong>-F</strong>：在列出的文件或目录名后添加类型指示符，例如<code>*</code>表示可执行文件，<code>/</code>表示目录。</li>
<li><strong>–color&#x3D;never&#x2F;always&#x2F;auto</strong>：控制是否以颜色显示文件类型。<code>never</code>表示从不以颜色显示，<code>always</code>表示总是以颜色显示，<code>auto</code>（默认）表示根据系统设置自动判断。</li>
<li><strong>–full-time</strong>：以完整的时间格式（年-月-日 时:分）显示文件的修改时间。</li>
<li><strong>-n</strong>：以数字形式显示用户ID（UID）和组ID（GID），而不是用户名和组名。</li>
<li><strong>-i</strong>：显示文件的inode号。inode是Linux系统中用于存储文件元数据的索引节点。</li>
<li><strong>-m</strong>：以逗号分隔的方式横向列出文件。</li>
<li><strong>-p</strong>：在目录名后添加<code>/</code>，以区分文件和目录。</li>
<li><strong>-u</strong>：按照文件的访问时间排序，而不是修改时间。</li>
<li><strong>-v</strong>：按照自然顺序对文件名进行排序，例如，数字会按照数值大小而不是字典顺序排序。</li>
<li><strong>-x</strong>：以多列格式横向显示文件列表，而不是默认的单列格式。</li>
<li><strong>-l</strong>：以长格式显示文件和目录的详细信息，包括文件权限、所有者、组、大小、最后修改日期和时间等。<ul>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240903180044915.png" alt="image-20240903180044915"></li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240903180216575.png" alt="image-20240903180216575"></li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240903180329813.png" alt="image-20240903180329813"></li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240903180447531.png" alt="image-20240903180447531"></li>
<li>-：普通文件（Regular File）</li>
<li>l：符号链接文件（Symbolic Link File，也称为链接文件Link）</li>
<li>d：目录文件（Directory File）</li>
<li>c：字符设备文件（Character Device File）</li>
<li>s：套接字文件（Socket File）</li>
<li>b：块设备文件（Block Device File）</li>
<li>p：管道文件（Pipe File）</li>
<li>rwx：文件持有者权限，文件所属组权限，其他人权限<ul>
<li>r：只读</li>
<li>w：只写</li>
<li>x：可执行</li>
</ul>
</li>
<li>文件所有者：root</li>
<li>文件所属组：root（disk）</li>
<li>文件大小</li>
<li>文件创建日期或最后修改时间</li>
</ul>
</li>
<li>参数直接可以结合使用<ul>
<li>ls -la：列出当前目录下所有文件的详细信息，包括隐藏文件</li>
<li>ls -ltr：列出当前目录下的文件，按照时间逆向排序</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>​				</p>
<h4 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h4><p>切换目录（change directory）</p>
<p>使用方式：cd + 路径</p>
<ul>
<li>切换到家目录<ul>
<li>cd</li>
<li>cd ~</li>
<li>cd &#x2F;home&#x2F;</li>
<li>cd $HOME</li>
</ul>
</li>
<li>邻居两个目录直接切换<ul>
<li>cd -</li>
</ul>
</li>
</ul>
<h4 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h4><p>（printf working directory）查看当前所处的工作目录</p>
<h4 id="which命令"><a href="#which命令" class="headerlink" title="which命令"></a>which命令</h4><p>显示命令所在的目录，如which，which up</p>
<h4 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h4><p>touch file</p>
<p>如果文件不存在，创建新文件，如果文件存在，更新文件的最后修改时间</p>
<h4 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h4><p>创建新目录（文件夹）</p>
<p>如果创建多级目录需要添加参数 -p（parent）</p>
<h4 id="rmdir命令"><a href="#rmdir命令" class="headerlink" title="rmdir命令"></a>rmdir命令</h4><p>rmdir dir：删除空目录，<strong>只能删除空目录</strong></p>
<h4 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h4><p>rm删除的文件不会放在回收站中，数据不易恢复</p>
<ul>
<li>删除文件：rm file</li>
<li>删除目录：rm -r dir</li>
<li>参数<ul>
<li>-r：递归删除目录，删除目录必须添加此参数</li>
<li>-i：提示用户是否删除文件或目录</li>
<li>-f：强制删除</li>
</ul>
</li>
</ul>
<h4 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h4><p>cp 源文件或目录 目标目录或文件</p>
<p>若有目录的拷贝需要用-r参数</p>
<ul>
<li><p>cp file1 file2</p>
<ul>
<li><p>file2不存在，直接创建新文件</p>
</li>
<li><p>file2存在，则用file1覆盖file2</p>
</li>
</ul>
</li>
<li><p>cp file dir（必须存在）</p>
<ul>
<li>把file拷贝到dir目录中</li>
</ul>
</li>
<li><p>cp dir1 dir2（不存在）</p>
<ul>
<li>必须加-r参数</li>
</ul>
</li>
<li><p>cp dir1 dir2（存在）</p>
<ul>
<li>dir1拷贝进dir2，且不覆盖dir2原有文件和目录</li>
</ul>
</li>
<li><p>cp -a file1 file2</p>
<ul>
<li>把file1的属性也拷贝到file2，如时间</li>
</ul>
</li>
</ul>
<h4 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h4><p>mv 源文件 目标文件</p>
<ul>
<li><p>mv file1 file2（不存在）</p>
<ul>
<li>相当于把file1改名为file2</li>
</ul>
</li>
<li><p>mv file1 file2（存在）</p>
<ul>
<li>相当于用file1覆盖file2</li>
</ul>
</li>
<li><p>mv file dir（必须存在）</p>
<ul>
<li>把file移动到dir里</li>
</ul>
</li>
<li><p>mv dir1 dir2（不存在）</p>
<ul>
<li>相当于把dir1 改名为dir2</li>
</ul>
</li>
<li><p>mv dir dir（存在）</p>
<ul>
<li>dir1移动到dir2，且不覆盖dir2原有文件和目录</li>
</ul>
</li>
</ul>
<h4 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h4><ul>
<li>cat file</li>
<li>将文件内容一次性输出到终端</li>
<li>缺点：终端显示的内容有限。如果文件太长无法全部显示</li>
<li>可用于文件重定向：cat file1 &gt; file2，相当于cp file1 file2</li>
</ul>
<h4 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a>more命令</h4><ul>
<li>more file</li>
<li>文件内容分页显示到终端，但是只能一直向下浏览，不能回退</li>
<li>操作<ul>
<li>显示下一行：回车</li>
<li>显示下一页：空格</li>
<li>退出：q（ctrl+c）</li>
</ul>
</li>
</ul>
<h4 id="less命令"><a href="#less命令" class="headerlink" title="less命令"></a>less命令</h4><ul>
<li>less file</li>
<li>文件内容分页显示到终端，可以自由上下浏览</li>
<li>操作<ul>
<li>显示下一行：回车，ctrl+p，↓</li>
<li>显示上一页：ctrl+n，↑</li>
<li>显示下一页：空格，PageDown</li>
<li>显示上一页：PageUp</li>
<li>退出：q（ctrl+c）</li>
</ul>
</li>
</ul>
<h4 id="head命令"><a href="#head命令" class="headerlink" title="head命令"></a>head命令</h4><ul>
<li>head -num(行数) file</li>
<li>从文件头部开始查看前n行的内容<ul>
<li>如head -20 a.txt：查看前二十行的内容</li>
</ul>
</li>
<li>如果没有指定行数，默认显示前10行内容</li>
</ul>
<h4 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h4><ul>
<li>tail -num(行数) file</li>
<li>从文件头部开始查看前n行的内容<ul>
<li>如tail -20 a.txt：查看前二十行的内容</li>
</ul>
</li>
<li>如果没有指定行数，默认显示后10行内容</li>
<li>tail -f file：实时监控file文件的变化</li>
</ul>
<h4 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h4><ul>
<li><p>类似于Windows下的快捷方式</p>
</li>
<li><p>创建 (-s (soft)）</p>
<ul>
<li>ln -s 文件名 快捷方式名<ul>
<li>如：ln -s a a.link</li>
<li>目录也可创建软链接<ul>
<li>如：ln -s tmp tmp.link</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>注意事项</p>
<ul>
<li>ln创建软链接时要用绝对路径，如果不适用绝对路径，一旦软链接文件发生位置变动，就无法找到源文件</li>
<li>软链接文件大小是：路径+源文件名的总字节数</li>
</ul>
</li>
</ul>
<h4 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h4><ul>
<li><p>ln 文件名 硬链接的名字</p>
</li>
<li><p>注意</p>
<ul>
<li>硬链接不能建在目录上</li>
<li>硬链接对绝对路径没有要求</li>
<li>硬链接不能跨文件系统<ul>
<li>硬链接文件和源文件的inode是相同的，文件系统的inode要求唯一，跨文件系统可能会使inode不同，所以硬链接不能跨文件系统</li>
</ul>
</li>
</ul>
</li>
<li><p>硬链接本质</p>
<ul>
<li><p>是不同文件名所在的inode结点是相同的，相同的inode结点指向了相同的数据块，所以他们的文件内容是一样的，文件内容会同步</p>
<ul>
<li><p>ls -i 文件名：可以查看文件的i节点</p>
</li>
<li><p>stat 文件名：可以查看i节点信息</p>
<ul>
<li><p>如图，file.hard是file的硬链接，这两个文件指向了同一个inode，同一个inode指向了相同的数据块（文件内容）。相当与起别名</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240903202209110.png" alt="image-20240903202209110"></p>
<ul>
<li>当新创建了一个文件，硬链接计数为1</li>
<li>给文件创建了一个硬链接后，硬链接计数加1</li>
<li>删除一个硬链接后，硬链接计数减1</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>硬链接应用场景</p>
<ul>
<li>可以起到同步文件作用<ul>
<li>修改file的内容，会在其余硬链接文件上同步</li>
</ul>
</li>
<li>可以起到保护文件的作用<ul>
<li>删除文件的时候，只要硬链接计数不为零，不会真正删除</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="wc命令"><a href="#wc命令" class="headerlink" title="wc命令"></a>wc命令</h4><p>word count</p>
<ul>
<li>wc file：显示文件总行数，字节数和单词数</li>
<li>wc -l file：显示文件的总行数</li>
<li>wc -c file：显示文件的总字节数</li>
<li>wc -w file：显示文件的总单词数</li>
</ul>
<h4 id="whoami"><a href="#whoami" class="headerlink" title="whoami"></a>whoami</h4><ul>
<li>显示当前登录的用户名</li>
<li>echo $USER</li>
</ul>
<h3 id="用户权限，用户，用户组"><a href="#用户权限，用户，用户组" class="headerlink" title="用户权限，用户，用户组"></a>用户权限，用户，用户组</h3><h4 id="修改文件权限chmod"><a href="#修改文件权限chmod" class="headerlink" title="修改文件权限chmod"></a>修改文件权限chmod</h4><ul>
<li><p>文字设定法</p>
<ul>
<li>chmod [who] [+|-|&#x3D;] [mode] file<ul>
<li>操作对象【who】<ul>
<li>u：用户（user）</li>
<li>g：同组用户（group）</li>
<li>o：其他用户 （other）</li>
<li>a：所有用户（all）（默认）</li>
</ul>
</li>
<li>操作符【+-&#x3D;】<ul>
<li>+：添加权限</li>
<li>-：取消权限</li>
<li>&#x3D;：赋予权限并取消其他权限</li>
</ul>
</li>
<li>权限【mode】<ul>
<li>r：读</li>
<li>w：写</li>
<li>x：执行</li>
</ul>
</li>
</ul>
</li>
<li>例：给文件file.txt的所有者和所属组添加读写权限<ul>
<li>chmod ug+wr file.txt</li>
<li>chmod u+rw,g+rw file.txt</li>
</ul>
</li>
</ul>
</li>
<li><p>数字设定法</p>
<ul>
<li>chmod [+|-|&#x3D;] [mode] file<ul>
<li>操作符【+-&#x3D;】<ul>
<li>+：添加权限</li>
<li>-：取消权限</li>
<li>&#x3D;：赋予权限并取消其他权限</li>
</ul>
</li>
<li>数字表示的含义<ul>
<li>0：没有权限（-）</li>
<li>1：执行权限（x）</li>
<li>2：写权限（w）</li>
<li>4：读权限（r）</li>
</ul>
</li>
</ul>
</li>
<li>例：给file.txt文件设置rw-rw-r–<ul>
<li>chmod 664 file.txt</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="修改文件所有者和所属组chown"><a href="#修改文件所有者和所属组chown" class="headerlink" title="修改文件所有者和所属组chown"></a>修改文件所有者和所属组chown</h4><ul>
<li><p>chown 文件所有者 文件名</p>
<ul>
<li>chown kayer file.txt</li>
</ul>
</li>
<li><p>修改文件所有者和所属组</p>
<ul>
<li>chown kayer:kayer file.txt</li>
<li>chown kayer.kayer file.txt</li>
</ul>
</li>
<li><p>修改所属组</p>
<ul>
<li>chgrp kayer file.txt</li>
</ul>
</li>
</ul>
<h3 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h3><ul>
<li><p>按文件名查询：使用参数 -name</p>
<ul>
<li>find 路径 -name “文件名”</li>
<li>例：find &#x2F;home -name “*.c”</li>
</ul>
</li>
<li><p>按文件类型查询：使用参数-tyoe</p>
<ul>
<li>find 路径 -type 类型</li>
<li>类型：<ul>
<li>普通文件类型用f而不是-</li>
<li>d：目录</li>
<li>l：符号链接</li>
<li>b：块设备文件</li>
<li>c：字符设备文件</li>
<li>s：socket文件</li>
<li>p：管道文件</li>
</ul>
</li>
<li>查找指定目录下的普通文件：find 路径 -type f</li>
</ul>
</li>
<li><p>按文件大小查询：使用参数-size</p>
<ul>
<li><p>find 路径 -size 范围</p>
</li>
<li><p>范围：</p>
<ul>
<li><p>大于：+</p>
<ul>
<li>例：+100k</li>
</ul>
</li>
<li><p>小于：-</p>
<ul>
<li>例：-100k</li>
</ul>
</li>
<li><p>等于：不需要添加符号</p>
</li>
</ul>
</li>
<li><p>大小</p>
<ul>
<li>M必须大写（1M）</li>
<li>k必须小写（1k）</li>
</ul>
</li>
<li><p>c表示字节数</p>
</li>
<li><p>例：</p>
<ul>
<li>等于100k的文件：find ~&#x2F; -size 100k</li>
<li>大于1M的文件：find ~&#x2F; -size +1M</li>
<li>小于50k的文件：find ~&#x2F; -size -50k</li>
<li>大于10k小于20k之间的文件：find ~&#x2F; +size -10k -size 20k</li>
</ul>
</li>
</ul>
</li>
<li><p>按文件日期</p>
<ul>
<li><p>创建日期：-ctime -n&#x2F;+n</p>
<ul>
<li>-n：n天以内</li>
<li>+n：n天以外</li>
</ul>
</li>
<li><p>修改日期：-mtime -n&#x2F;+n</p>
</li>
<li><p>访问日期：-atime -n&#x2F;+n</p>
</li>
</ul>
</li>
<li><p>按深度</p>
<ul>
<li><p>-maxdepth n(层数)</p>
<ul>
<li>搜索n层一下的目录，搜索的层数不超过n层</li>
</ul>
</li>
<li><p>-mindepth n(层数)</p>
<ul>
<li>搜索n层以上的目录，搜索的层数不能小于n层</li>
</ul>
</li>
</ul>
</li>
<li><p>高级查找</p>
<ul>
<li><p>例：查找指定目录下所有目录，并列出目录中文件详细信息</p>
<ul>
<li><p>find .&#x2F; -type d -exec shell 命令 {} ;</p>
<p>find .&#x2F; -type d -exec ls -l {} ;</p>
</li>
<li><p>find .&#x2F; -type d -ok shell 命令 {} ;</p>
<p>find .&#x2F; -type d -ok ls -l {} ;</p>
<ul>
<li>{}中间不能有空格</li>
<li>ok比较安全，特别是在执行rm删除文件的时候</li>
</ul>
</li>
<li><p>find .&#x2F; -type d |xargs shell 命令</p>
<p>find .&#x2F; -type d |xargs ls -l</p>
<p>查找的文件结果集大优先用这个</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h3><ul>
<li>grep -r（有目录） “查找的内容” 搜索路径<ul>
<li>-r：若是目录，则可以递归搜索</li>
<li>-n：可以显示该查找内容所在的行号</li>
<li>-i：可以忽略大小写进行查找</li>
<li>-v：不显示含有某字符串</li>
</ul>
</li>
<li>搜索当前目录下包含hello world字符串的文件<ul>
<li>grep -r -n “hello world” .&#x2F;					显示行号</li>
<li>grep -r -i -n “HELLO WORLD” .&#x2F;          忽略大小写</li>
</ul>
</li>
</ul>
<h3 id="find和grep命令结合使用"><a href="#find和grep命令结合使用" class="headerlink" title="find和grep命令结合使用"></a>find和grep命令结合使用</h3><ul>
<li>先试用find命令查找文件，然后是用grep命令查找哪些文件包含某个字符串<ul>
<li>find . -name “*.c” | xargs grep -n “main”</li>
</ul>
</li>
</ul>
<h3 id="软件安装与卸载"><a href="#软件安装与卸载" class="headerlink" title="软件安装与卸载"></a>软件安装与卸载</h3><h4 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h4><h5 id="在线安装"><a href="#在线安装" class="headerlink" title="在线安装"></a>在线安装</h5><ul>
<li><p><strong>更新软件包列表</strong>：<br>打开终端或SSH连接到CentOS服务器，以root用户身份登录系统，运行以下命令更新YUM软件包列表：</p>
<p><code>yum update -y</code></p>
</li>
<li><p><strong>搜索软件包</strong>：<br>使用以下命令搜索要安装的软件包：</p>
<p><code>yum search [安装包名]</code></p>
</li>
<li><p><strong>安装软件包</strong>：<br>找到所需软件包后，使用以下命令进行安装：</p>
<p><code>yum install [安装包名] -y</code></p>
</li>
</ul>
<h5 id="使用RPM包管理器"><a href="#使用RPM包管理器" class="headerlink" title="使用RPM包管理器"></a>使用RPM包管理器</h5><ul>
<li><p><strong>下载RPM包</strong>：<br>从官方网站或第三方网站下载所需软件的RPM包。</p>
</li>
<li><p><strong>安装RPM包</strong>：<br>打开终端，以root用户身份登录系统，使用以下命令安装RPM包：</p>
<p><code>rpm -ivh [安装包名].rpm</code></p>
<ul>
<li>这里的<code>-i</code>表示安装，<code>-v</code>表示显示安装过程，<code>-h</code>表示显示进度条。</li>
</ul>
</li>
<li><p><strong>解决依赖性问题</strong>：<br>如果安装过程中出现依赖性问题，可以使用YUM命令自动解决依赖关系：</p>
<p><code>yum install [安装包名].rpm</code></p>
</li>
</ul>
<h5 id="使用压缩包安装"><a href="#使用压缩包安装" class="headerlink" title="使用压缩包安装"></a>使用压缩包安装</h5><ul>
<li><p><strong>下载压缩包</strong>：<br>从软件官网下载与CentOS兼容的压缩包。</p>
</li>
<li><p><strong>解压缩压缩包</strong>：<br>使用tar命令将压缩包解压到指定目录：</p>
<p>tar -zxvf [文件名称].tar.gz  # 对于.tar.gz文件   </p>
<p>tar -jxvf [文件名称].tar.bz2 # 对于.tar.bz2文件</p>
</li>
<li><p><strong>编译安装</strong>：<br>进入解压后的目录，通常需要先运行<code>./configure</code>命令进行配置（这一步是可选的，取决于软件是否提供了该脚本），然后执行<code>make</code>命令进行编译，最后使用<code>make install</code>命令进行安装。注意，安装过程中可能需要指定安装路径和配置环境变量。</p>
</li>
</ul>
<h5 id="清理安装包"><a href="#清理安装包" class="headerlink" title="清理安装包"></a>清理安装包</h5><ul>
<li><p><strong>清理所有缓存的软件包和头文件</strong>：</p>
<ul>
<li><p><code>yum clean all</code>  </p>
</li>
<li><p>或者在CentOS 8及更高版本中  </p>
<p><code>dnf clean all</code></p>
<p>这个命令会删除<code>/var/cache/yum</code>（或<code>/var/cache/dnf</code>）目录下的所有缓存文件，包括已下载但尚未安装的软件包、已安装软件包的旧版本以及它们的头文件。</p>
</li>
</ul>
</li>
<li><p><strong>清理临时文件</strong></p>
<p>在安装过程中，系统可能会创建一些临时文件。这些文件通常位于<code>/tmp</code>或<code>/var/tmp</code>目录下。</p>
<p>rm -rf &#x2F;tmp&#x2F;*  </p>
<p>rm -rf &#x2F;var&#x2F;tmp&#x2F;*</p>
</li>
<li><p><strong>清理不再需要的软件包</strong></p>
<p>如果发现系统中安装了一些不再需要的软件包，可以使用YUM或DNF命令来删除它们。</p>
<p><code>sudo yum remove &lt;package_name&gt;</code></p>
<p>或者在CentOS 8及更高版本中  </p>
<p><code>sudo dnf remove &lt;package_name&gt;</code></p>
<p>注意，删除软件包时，可能会提示删除一些依赖的软件包。</p>
</li>
</ul>
<h4 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h4><h5 id="在线安装-1"><a href="#在线安装-1" class="headerlink" title="在线安装"></a>在线安装</h5><ul>
<li>安装：<code>apt-get install 软件名</code></li>
<li>卸载：<code>apt-get remove 软件名</code></li>
<li>更新软件列表：<code>apt-get update</code></li>
<li>清理安装包：<code>apt-get clean</code><ul>
<li>清理的缓存路径：&#x2F;var&#x2F;cache&#x2F;apt&#x2F;archives</li>
</ul>
</li>
</ul>
<h5 id="软件包安装"><a href="#软件包安装" class="headerlink" title="软件包安装"></a>软件包安装</h5><ul>
<li>deb格式的安装包</li>
<li>安装：<code>dpkg -i xxx.deb</code></li>
<li>卸载：<code>dpkg -r 软件名</code></li>
</ul>
<h3 id="常用的压缩工具"><a href="#常用的压缩工具" class="headerlink" title="常用的压缩工具"></a>常用的压缩工具</h3><h4 id="gzip和bzip2"><a href="#gzip和bzip2" class="headerlink" title="gzip和bzip2"></a>gzip和bzip2</h4><ul>
<li>不能压缩目录，只能一个一个文件进行压缩，压缩之后原文件消失</li>
<li>gzip *：压缩当前目录下所有文件，但是目录不能压缩</li>
<li>gunzip *：解压当前目录下所有的.gz文件</li>
<li>bzip2 *：压缩当前目录下所有的文件，但是目录不能压缩</li>
<li>bunzip2 *：解压当前目录下所有的.bz2文件</li>
</ul>
<h4 id="tar工具"><a href="#tar工具" class="headerlink" title="tar工具"></a>tar工具</h4><ul>
<li><p>参数</p>
<ul>
<li>z：用gzip来压缩&#x2F;解压缩文件</li>
<li>j：用bzip2来压缩&#x2F;解压缩文件</li>
<li>c：create，创建新的压缩文件，与x互斥使用</li>
<li>x：从压缩文件中释放文件，与c互斥使用</li>
<li>v：详细报告tar处理的文件信息</li>
<li>f：指定压缩文件的名字</li>
<li>t：查看压缩包中有哪些文件</li>
</ul>
</li>
<li><p>压缩</p>
<ul>
<li><p>tar cvf 压缩包名字.tar 原材料（要打包压缩的文件或目录）</p>
</li>
<li><p>tar zcvf 压缩包名字.tar.gz 原材料（要打包压缩的文件或目录）</p>
</li>
<li><p>tar jcvf 压缩包名字.tar.bz2 原材料（要打包压缩的文件或目录）</p>
</li>
</ul>
</li>
<li><p>解压缩</p>
<ul>
<li>tar xvf 已有的压缩包（.gz）</li>
<li>tar zxvf 已有的压缩包（.gz）</li>
<li>tar jxvf 已有的压缩包（.bz2）<ul>
<li>解压到指定目录，添加参数 -C（大写）<ul>
<li>tar zxvf test.tar.gz -C path</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="rar工具"><a href="#rar工具" class="headerlink" title="rar工具"></a>rar工具</h4><ul>
<li>使用前需安装rar工具<ul>
<li><code>apt-get install rar</code></li>
</ul>
</li>
<li>压缩<ul>
<li>rar a -r file&#x2F;path</li>
<li>-r：压缩目录</li>
<li>打包生成的新文件不需要指定后缀<ul>
<li>例：rar a -r test aa bb dir → 将aa bb dir 压缩到test.rar文件中</li>
</ul>
</li>
</ul>
</li>
<li>解压缩<ul>
<li>rar x xxx.rar path<ul>
<li>rar x test.rar：将test.rar解压到当前目录</li>
<li>rar x test.rar test：将test.rar解压到test目录下<ul>
<li>若解压目录不存在会报错</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="zip工具"><a href="#zip工具" class="headerlink" title="zip工具"></a>zip工具</h4><ul>
<li><p>压缩：zip -r 压缩包名 要压缩的文件或目录</p>
<ul>
<li>使用目录需要使用参数-r</li>
<li>使用该命令不需要指定压缩包后缀<ul>
<li>zip -r xxx file dir：生成xxx.zip文件</li>
</ul>
</li>
</ul>
</li>
<li><p>解压缩：unzip 压缩包名</p>
<ul>
<li><p>解压缩到指定目录：添加参数-d 解压目录</p>
<ul>
<li><p>unzip xxx.zip -d path</p>
<p>解压目录不存在会报错</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>​	</p>
<h2 id="vi-使用"><a href="#vi-使用" class="headerlink" title="vi 使用"></a>vi 使用</h2><h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><h5 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h5><ul>
<li><p>zz：保存退出</p>
</li>
<li><p>gg&#x2F;G：代码格式化</p>
</li>
<li><p>光标移动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">	 ^</span><br><span class="line">     k              Hint:  The h key is at the left and moves left.</span><br><span class="line">&lt; h     l &gt;                The l key is at the right and moves right.</span><br><span class="line">     j                     The j key looks like a down arrow.</span><br><span class="line">     v</span><br></pre></td></tr></table></figure>
</li>
<li><p>w：移动一个单词</p>
</li>
<li><p>gg：光标移动到文件开头</p>
</li>
<li><p>G：光标移动到文件末尾</p>
</li>
<li><p>0：光标移动到行首</p>
</li>
<li><p>$：光标移动到行尾</p>
</li>
<li><p>nG：行跳转，例6G，跳转到6行处</p>
</li>
</ul>
<h5 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h5><ul>
<li>x：删除光标后一个字符，相当于Del</li>
<li>X：删除光标前一个字符，相当好与BackSpace</li>
<li>dw：删除光标开始位置的单词，包含光标所在单词</li>
<li>d0：删除光标前本行所有内容，不包含光标所在字符</li>
<li>D[d$]：删除光标后本行所有内容，包含光标所在字符</li>
<li>dd：删除光标所在行（本质剪切）</li>
<li>ndd：从光标当前行向下删除指定行数，如6dd</li>
<li>v&#x2F;ctrl+v：使用h，j，k，l移动选择内容，然后按d删除，其中ctrl+v是列模式，v为非列模式</li>
</ul>
<h5 id="撤销和反撤销"><a href="#撤销和反撤销" class="headerlink" title="撤销和反撤销"></a>撤销和反撤销</h5><ul>
<li>u：一步一步撤销，相当于ctrl+z</li>
<li>ctrl+r：反撤销，相当于ctrl+y</li>
</ul>
<h5 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h5><ul>
<li><p>yy：复制当前行</p>
</li>
<li><p>nyy：复制n行</p>
</li>
<li><p>p：在光标所在位置向下新开辟一行，粘贴</p>
</li>
<li><p>P：在光标所在位置向上新开辟一行，粘贴</p>
</li>
<li><p>剪切操作：按dd或者ndd删除，然后用p&#x2F;P可以粘贴</p>
</li>
</ul>
<h5 id="可视模式"><a href="#可视模式" class="headerlink" title="可视模式"></a>可视模式</h5><ul>
<li>v&#x2F;ctrl+v：使用h，j，k，l移动选择内容，然后按d删除，使用y复制</li>
</ul>
<h5 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h5><ul>
<li>r：替换当前字符</li>
<li>R：替换当前行光标后的字符</li>
</ul>
<h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><ul>
<li>&#x2F;：&#x2F;xxx，从光标所在位置开始搜索，按n向下搜索，按N向上搜索</li>
<li>?：?xxx，从光标所在位置开始搜索，按n向上搜索，按N向下搜索</li>
<li>#：将光标移动到待搜索的字符串上，然后按n向上搜索，按N向下搜索</li>
<li>shift+k：在待搜索的字符串上按shift+k或者K，可以查看相关帮助文档</li>
</ul>
<h5 id="切换到文本输入模式"><a href="#切换到文本输入模式" class="headerlink" title="切换到文本输入模式"></a>切换到文本输入模式</h5><ul>
<li><p>i：光标前插入</p>
</li>
<li><p>a：光标后插入</p>
</li>
<li><p>I：在光标所在行的首行插入</p>
</li>
<li><p>A：在光标所在行的行尾插入</p>
</li>
<li><p>o：在光标所在行的下面新创建一行，行首插入</p>
</li>
<li><p>O：在光标所在行的上面新创建一行，行首插入</p>
</li>
<li><p>s：删除光标后边的字符，从光标当前位置插入</p>
</li>
<li><p>S：删除光标所在当前行，从行首插入</p>
</li>
<li><p>按列模式插入：先按ctrl+v进入列模式，移动光标选定某列，按I或者shift+i向前插入，然后插入字符，最后按两次esc</p>
</li>
</ul>
<h4 id="末行模式"><a href="#末行模式" class="headerlink" title="末行模式"></a>末行模式</h4><h5 id="保存退出"><a href="#保存退出" class="headerlink" title="保存退出"></a>保存退出</h5><ul>
<li>q：退出</li>
<li>q!：强制退出，不保存内容</li>
<li>w：保存修改内容，不退出</li>
<li>wq：保存并退出</li>
<li>x：相当于wq</li>
</ul>
<h5 id="替换-1"><a href="#替换-1" class="headerlink" title="替换"></a>替换</h5><p>下面old表示原字符串，new表示新字符串</p>
<ul>
<li>:s&#x2F;old&#x2F;new&#x2F;：光标所在行的第一个old替换为new</li>
<li>:s&#x2F;old&#x2F;new&#x2F;g：光标所在行的所有old替换为new</li>
<li>:m,ns&#x2F;old&#x2F;new&#x2F;g：将m行至n行之间的old全部替换为new</li>
<li>:%s&#x2F;old&#x2F;new&#x2F;g：当前文件的所有old替换为new</li>
<li>:1,$s&#x2F;old&#x2F;new&#x2F;g：当前文件的所有old替换为new</li>
<li>:%s&#x2F;old&#x2F;new&#x2F;gc：当前文件的所有old替换为new，但是每次替换需要用户确认</li>
</ul>
<h5 id="快速翻屛"><a href="#快速翻屛" class="headerlink" title="快速翻屛"></a>快速翻屛</h5><ul>
<li>ctrl+u：向下翻半屏（up）光标向上移动</li>
<li>ctrl+d：向上翻半屏（down）光标向下移动</li>
<li>ctrl+f：向上翻全屏（front）</li>
<li>ctrl+b：向后翻全屏（back）</li>
</ul>
<h4 id="在末行模式下执行命令"><a href="#在末行模式下执行命令" class="headerlink" title="在末行模式下执行命令"></a>在末行模式下执行命令</h4><ul>
<li>!shell 命令</li>
<li>按两下esc可回到命令模式</li>
</ul>
<h4 id="分屏操作"><a href="#分屏操作" class="headerlink" title="分屏操作"></a>分屏操作</h4><ul>
<li><p>打开文件之前分屏</p>
<ul>
<li>vim -o file1… 垂直分屏</li>
<li>vim -O file1…水平分屏</li>
</ul>
</li>
<li><p>打开文件之后分屏</p>
<table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="center">操作</th>
</tr>
</thead>
<tbody><tr>
<td align="center">sp</td>
<td align="center">当前文件水平分屏</td>
</tr>
<tr>
<td align="center">vsp</td>
<td align="center">当前文件垂直分屏</td>
</tr>
<tr>
<td align="center">sp 文件名</td>
<td align="center">当前文件和另一个文件水平分屏</td>
</tr>
<tr>
<td align="center">vsp 文件名</td>
<td align="center">当前文件和另一个文件垂直分屏</td>
</tr>
<tr>
<td align="center">ctrl+w</td>
<td align="center">在多个窗口切换光标</td>
</tr>
<tr>
<td align="center">wall&#x2F;wqall&#x2F;xall&#x2F;qall&#x2F;qall!</td>
<td align="center">保存&#x2F;保存退出&#x2F;保存退出&#x2F;退出&#x2F;强制退出分屏模式</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="vim的配置文件"><a href="#vim的配置文件" class="headerlink" title="vim的配置文件"></a>vim的配置文件</h4><ul>
<li><p>用户级别的配置文件</p>
<ul>
<li>~&#x2F;.vimrc，修改用户级别的配置文件只会影响当前用户，不会影响其他用户</li>
</ul>
</li>
<li><p>系统级别的配置文件</p>
<ul>
<li>&#x2F;etc&#x2F;vim&#x2F;vimrc，修改系统级别的配置文件会影响所有用户</li>
</ul>
</li>
<li><p>常用配置</p>
<ul>
<li>set tabstop&#x3D;4：设置缩进4个空格</li>
<li>set nu：设置行号</li>
<li>set shiftwidth&#x3D;4：设置gg&#x2F;G缩进4个空格，默认缩进8个空格</li>
</ul>
</li>
</ul>
<h2 id="gcc编译器"><a href="#gcc编译器" class="headerlink" title="gcc编译器"></a>gcc编译器</h2><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>gcc编译器将c源文件到生成一个可执行程序，中间一共经历了四个步骤</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240904124852437.png" alt="image-20240904124852437"></p>
<p>四个步骤并不是gcc 独立完成的,而是在内部调用了其他工具,从而完成了整个工作流程，其中编译最耗时，因为要逐行检查语法.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240904125042543.png" alt="image-20240904125042543"></p>
<p>gcc的工作流程:</p>
<ul>
<li><p>预处理:cpp预处理，去掉注释，展开头文件，宏替换</p>
<p><code>gcc -E test.c -o test.i</code></p>
</li>
<li><p>编译：gcc，将源代码文件编译成汇编语言代码</p>
<p><code>gcc -S test.i -o test.s</code></p>
</li>
<li><p>汇编：as，将汇编语言代码编译成了二进制文件(目标代码)<br><code>gcc -c test.s -o test.o</code></p>
</li>
<li><p>链接:ld，链接test.c代码中调用的库函数</p>
<p><code>gcc -o test test.o</code></p>
</li>
</ul>
<p>一步生成最终的可执行程序</p>
<p><code>gcc test.c -o test</code></p>
<h3 id="gcc常用参数"><a href="#gcc常用参数" class="headerlink" title="gcc常用参数"></a>gcc常用参数</h3><ul>
<li>-v：查看 gcc版本号,–version 也可以</li>
<li>-E：生成预处理文件</li>
<li>-S：生成汇编文件</li>
<li>-c：只编译，生成o文件，通常称为目标文件</li>
<li>-I：指定头文件所在的路径</li>
<li>-L：指定库文件所在的路径</li>
<li>-l：指定库的名字</li>
<li>-o：指定生成的目标文件的名字</li>
<li>-g：包含调试信息，使用 gdb,调试需要添加-g 参数</li>
<li>-On n&#x3D;0~3 编译优化,n越大优化得越多</li>
<li>-Wall：提示更多警告信息</li>
<li>-D：编译时定义宏</li>
</ul>
<h3 id="静态库和共享（动态）库"><a href="#静态库和共享（动态）库" class="headerlink" title="静态库和共享（动态）库"></a>静态库和共享（动态）库</h3><h4 id="库的介绍"><a href="#库的介绍" class="headerlink" title="库的介绍"></a>库的介绍</h4><ul>
<li><p>什么是库</p>
<ul>
<li>库是二进制文件，是源代码文件的另一种表现形式，是加了密的源代码;是一些功能相近或者是相似的函数的集合体.</li>
</ul>
</li>
<li><p>使用库有什么好处</p>
<ul>
<li><p>提高代码的可重用性，而且还可以提高程序的健壮性;</p>
</li>
<li><p>可以减少开发者的代码开发量，缩短开发周期.</p>
</li>
</ul>
</li>
</ul>
<h4 id="库的使用"><a href="#库的使用" class="headerlink" title="库的使用"></a>库的使用</h4><ul>
<li>头文件—包含了库函数的声明</li>
<li>库文件—包含了库函数的代码实现</li>
<li>注意:库不能单独使用，只能作为其他执行程序的一部分完成某些功能，也就是说只能被其他程序调用才能使用</li>
</ul>
<h4 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h4><p>​		静态库可以认为是一些目标代码的集合,是在可执行程序运行前就已经加入到执行码中，成为执行程序的一部分，按照习惯，一般以.a做为文件后缀名。</p>
<p>静态库的命名一般分为三个部分</p>
<ul>
<li>前缀：lib</li>
<li>库名称：自定义，如test</li>
<li>后缀：.a</li>
</ul>
<p>最终名字为libtest.a</p>
<h5 id="静态库的制作"><a href="#静态库的制作" class="headerlink" title="静态库的制作"></a>静态库的制作</h5><p>下面以fun1.c，fun2.c和head.h三个文件为例讲述静态库的制作和使用，其中 head.h 文件中有函数的声明，fun1.c和fun2.c中有函数的实现.</p>
<ul>
<li><p>步骤1:</p>
<ul>
<li><p>将c源文件生成对应的.o文件</p>
<p><code>gcc -c fun1.c fun2.c</code></p>
</li>
<li><p>或者分别生成.o 文件:</p>
<p><code>gcc -c fun1.c -o fun1.o</code></p>
<p><code>gcc -c fun2.c -o fun2.o</code></p>
</li>
</ul>
</li>
<li><p>步骤2:</p>
<ul>
<li>优用打包工具ar将准备好的.o 文件打包为.a 文件<ul>
<li>在使用 ar工具是时候需要添加参数rcs：r更新、c 创建、s 建立索引</li>
</ul>
</li>
<li>命令:ar rcs 静态库名 .o 文件<ul>
<li><code>ar rcs libtest.a fun1.o fun2.o</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="静态库的使用"><a href="#静态库的使用" class="headerlink" title="静态库的使用"></a>静态库的使用</h5><p>哪个文件调用了静态库中的函数，在生成可执行文件时需要添加参数，来找到库函数</p>
<p><code>gcc -o main.c main -Ipath -Lpath -lname</code></p>
<p>path是对应文件的路径</p>
<p>name是静态库lib和.a中间的名字</p>
<p>例：libtest.a：<code>gcc -o main main.c -I./ -L./ -ltest</code></p>
<h4 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h4><p>​		共享库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入，不同的应用程序如果调用相同的库,那么在内存里只需要有一份该共享库的拷贝,规避了空间浪费问题。动态库在程序运行时才被载入，也解决了静态库对程序的更新、部署和发布会带来麻烦，用户只需要更新动态库即可，增量更新。</p>
<p>为什么需要动态库,其实也是静态库的特点导致，按照习惯，一般以”.so”做为文件后缀名.共享库的命名一般分为三个部分:</p>
<ul>
<li>前缀：lib</li>
<li>库名称：自定义，如test</li>
<li>后缀：.so</li>
</ul>
<p>最终名字为libtest.so</p>
<h5 id="动态库的制作"><a href="#动态库的制作" class="headerlink" title="动态库的制作"></a>动态库的制作</h5><ul>
<li><p>生成目标文件.o，此时要加编译选项:-fPIC(fpic)</p>
<p><code>gcc -fpic -c fun1.c fun2.c</code></p>
<p>参数：-fpic 创建与地址无关的编译程序(pic,position independent code)，目的就是为够在多个应用程序间共享.</p>
</li>
<li><p>生成共享库，此时要加链接器选项：-shared（指定生成动态链接库）</p>
<p><code>gcc -shared fun1.o fun2.o -o libtest.so</code></p>
</li>
</ul>
<h5 id="动态库的使用"><a href="#动态库的使用" class="headerlink" title="动态库的使用"></a>动态库的使用</h5><p>引用动态库编译成可执行文件(跟静态库方式一样):</p>
<p>用到的参数:</p>
<ul>
<li><p>-L:指定要连接的库的所在目录</p>
</li>
<li><p>-l:指定链接时需要的动态库，去掉前缀和后缀</p>
</li>
<li><p>-I:指定main.c文件用到的头文件 head.h 所在的路径</p>
</li>
<li><p><code>gcc -I./ -L./ -ltest -o main main.c</code></p>
</li>
<li><p>运行.&#x2F;main，发现报错</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240904202723169.png" alt="image-20240904202723169"></p>
<ul>
<li>分析为什么在执行的时候找不到 libtest.so 库</li>
</ul>
<p>​	当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道所依赖的库的绝对路径。此	时就需要系统动态载入器(dynamiclinker&#x2F;loader)。</p>
<p>​	Idd 命令可以查看可执行文件依赖的库文件，执行ldd main2，可以发现libtest.so 找不到</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240904202835160.png" alt="image-20240904202835160"></p>
<ul>
<li><p>对于elf 格式的可执行程序,是由ld-linux.so*来完成的,它先后搜索elf文件的 DT RPATH段–环境变量LD LIBRARY PATH – &#x2F;etc&#x2F;ld.so.cache 文件列表 – &#x2F;lib&#x2F;,&#x2F;usr&#x2F;lib 目录找到库文件后将其载入内存。</p>
<p>使用file 命令可以查看文件的类型: file main</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240904203257962.png" alt="image-20240904203257962"></p>
<ul>
<li>如何让系统找到共享库<ul>
<li><p>拷贝自己制作的共享库到&#x2F;lib 或者&#x2F;usr&#x2F;lib</p>
</li>
<li><p>临时设置 LD_LIBRARY_PATH:</p>
<ul>
<li>export LD_LIBRARY_PATH&#x3D;$LD_LIBRARY_PATH：库路径</li>
</ul>
</li>
<li><p><strong>永久设置：把export LD_LIBRARY_PATH&#x3D;$LD_LIBRARY_PATH:库路径，设置到~&#x2F;.bashrc 文件中，然后在执行下列三种办法之一:</strong><br><strong>执行. ~&#x2F;.bashrc,使配置文件生效(第一个.后面有一个空格)</strong></p>
<p><strong>执行source ~&#x2F;.bashrc 配置文件生效</strong><br><strong>退出当前终端，然后再次登陆也可以使配置文件生效</strong></p>
</li>
<li><p>永久设置，把export LD_LIBRARY_PATH&#x3D;$LD_LIBRARY_PATH：库路径,设置到&#x2F;etc&#x2F;profile文件中</p>
</li>
<li><p>将其添加到 &#x2F;etc&#x2F;ld.so.cache 文件中</p>
</li>
<li><p>编辑&#x2F;etc&#x2F;ld.so.conf 文件，加入库文件所在目录的路径</p>
<ul>
<li>运行ldconfig -v，该命令会重建&#x2F;etc&#x2F;ld.so.cache 文件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="两种库的优缺点"><a href="#两种库的优缺点" class="headerlink" title="两种库的优缺点"></a>两种库的优缺点</h4><h5 id="静态库-1"><a href="#静态库-1" class="headerlink" title="静态库"></a>静态库</h5><ul>
<li><p>优点</p>
<ul>
<li>执行速度快，是因为静态库已经编译到可执行文件内部了2</li>
<li>移植方便，不依赖域其他的库文件缺点:</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>耗费内存，是由于每一个静态库的可执行程序都会加载一次</li>
<li>部署更新麻烦，因为静态库修改以后所有的调用到这个静态库的可执行文<br>件都需要重新编译</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240904210347911.png" alt="image-20240904210347911"></p>
</li>
</ul>
<h5 id="动态库-1"><a href="#动态库-1" class="headerlink" title="动态库"></a>动态库</h5><ul>
<li>优点<ul>
<li>节省内存</li>
<li>部署升级更新方便，只需替换动态库即可，然后再重启服务</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240904210601874.png" alt="image-20240904210601874"></p>
<ul>
<li>缺点<ul>
<li>加载速度比静态库慢</li>
<li>移植性差，需要把所有用到的动态库都移植!</li>
</ul>
</li>
</ul>
<p>由于由静态库生成的可执行文件是把静态库加载到了其内部，所以静态库生成的可执<br>行文件一般会比动态库大.</p>
<h2 id="makefile编写和gdb调试"><a href="#makefile编写和gdb调试" class="headerlink" title="makefile编写和gdb调试"></a>makefile编写和gdb调试</h2><h3 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h3><blockquote>
<p>makefile文件主要是管理项目工程文件，通过执行make命令，make命令就会解析并执行makefile文件。</p>
<p>makefile文件的命名：makefile或者Makefile</p>
</blockquote>
<h4 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h4><blockquote>
<p>目标：依赖</p>
<p>(tab)	命令</p>
</blockquote>
<p>基本规则三要素：</p>
<ul>
<li>目标：要生成的目标文件</li>
<li>依赖：目标文件由哪些文件生成</li>
<li>命令：通过执行该命令由依赖文件生成目标</li>
</ul>
<h4 id="makefile工作原理"><a href="#makefile工作原理" class="headerlink" title="makefile工作原理"></a>makefile工作原理</h4><ul>
<li><p>若想生成目标，检查规则中的所有的依赖文件是否都存在:、</p>
<ul>
<li><p>如果有的依赖文件不存在，则向下搜索规则，看是否有生成该依赖文件的规则</p>
<p>如果有规则用来生成该依赖文件，则执行规则中的命令生成依赖文件</p>
<p>如果没有规则用来生成该依赖文件，则报错。</p>
</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240905190759802.png" alt="image-20240905190759802"></p>
<ul>
<li>如果所有依赖都存在，检查规则中的目标是否需要更新，必须先检查它的所有依赖，依赖中有任何一个被更新，则目标必须更新.(检查的规则是哪个时间大哪个最新)<ul>
<li>若目标的时间&gt;依赖的时间，不更新</li>
<li>若目标的时间&lt;依赖的时间，则更新</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240905191040212.png" alt="image-20240905191040212"></p>
<h4 id="makefile中的变量"><a href="#makefile中的变量" class="headerlink" title="makefile中的变量"></a>makefile中的变量</h4><p>在 makefile ，中使用变量有点类似于C语言中的宏定义，使用该变量相当于内容替换,使用变量可以使makefile易于维护，修改起来变得简单。makefile 有三种类型的变量:</p>
<ul>
<li>普通变量</li>
<li>自带变量</li>
<li>自动变量</li>
</ul>
<h5 id="普通变量"><a href="#普通变量" class="headerlink" title="普通变量"></a>普通变量</h5><ul>
<li>变量定义直接用&#x3D;</li>
<li>使用变量值用 $(变量名)</li>
</ul>
<blockquote>
<p>例：下面是变量的定义和使用</p>
<p>​		<code>foo = abc</code>				&#x2F;&#x2F; 定义变量并赋值</p>
<p>​		<code>bar = $(foo)</code> 		&#x2F;&#x2F; 使用变量，$(变量名)</p>
<p>定义了两个变量: foo、bar, 其中 bar 的值是 foo 变量值的引用。除了使用用户自定义变量，makefile,中也提供了一些变量(变量名大写)供用户直接使用，我们可以直接对其进行赋值：</p>
<p>​		CC&#x3D; gcc #arm-linux-gcc<br>​		CPPFLAGS： C预处理的选项 <code>-I</code><br>​		CFLAGS：	 C编译器的选项 <code>-Wall -g -c</code><br>​		LDFLAGS：   链接器选项 <code>-L -l</code></p>
</blockquote>
<h5 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h5><blockquote>
<p>自动变量只能用在命令中，不能用在条件上</p>
</blockquote>
<ul>
<li><code>$@</code>：表示规则中的目标</li>
<li><code>$&lt;</code>：表示规则中的第一个条件</li>
<li><code>$^</code>：表示规则中的所有条件，组成一个列表，以空格隔开，如果这个列表中有重复的项则消除重复项。</li>
</ul>
<h5 id="模式规则"><a href="#模式规则" class="headerlink" title="模式规则"></a>模式规则</h5><blockquote>
<p>至少在规则的目标定义中要包含%，%表示一个或多个，在依赖条件中同样可以使用%，依赖条件中的%的取值取决于其目标</p>
<p>比如：</p>
<p>​		main.o:main.c </p>
<p>​		fun1.0:fun1.c </p>
<p>​		fun2.o:fun2.c，</p>
<p>说的简单点就是: xxx.0:xxx.C</p>
</blockquote>
<h4 id="makefile函数"><a href="#makefile函数" class="headerlink" title="makefile函数"></a>makefile函数</h4><p>makefile中的函数有很多，两个最常用的：</p>
<ul>
<li>wildcard：查找指定目录下的指定类型的文件</li>
</ul>
<p>​		<code>src=$(wildcard *.c)</code>	&#x2F;&#x2F;找到当前目录下所有后缀为.c的文件，赋值给 src</p>
<ul>
<li>patsubst：匹配替换</li>
</ul>
<p>​		<code>obj=$(patsubst %.c,%o,$(src))</code>	&#x2F;&#x2F;把src变量里所有后缀为.c的文件替换成.o</p>
<p>在makefile 中所有的函数都是有返回值的。当前目录下有main.c fun1.c fun2.c sum.c</p>
<p><code>src=$(wildcard*.c)</code>等价于 src&#x3D;main.c fun1.c fun2.c sum.c </p>
<p><code>obj=S(patsubst %.c,%o,$(src))</code>等价于 obj&#x3D;main.o fun1.o fun2.o sum.o</p>
<h4 id="makefile的清理操作"><a href="#makefile的清理操作" class="headerlink" title="makefile的清理操作"></a>makefile的清理操作</h4><blockquote>
<p>用途:清除编译生成的中间.o文件和最终目标文件</p>
<p>make clean 如果当前目录下有同名 clean 文件,则不执行 clean 对应的命令，解决方案：</p>
<p>伪目标声明：.PHONY:clean</p>
<p>声明目标为伪目标之后，makefile,将不会检查该目标是否存在或者该目标是否需要更新</p>
</blockquote>
<p>clean 命令中的特殊符号:</p>
<ul>
<li><code>-</code>此条命令出错，make 也会继续执行后续的命令。如：-rm main.o</li>
</ul>
<p>​		rm -f：强制执行，比如若要删除的文件不存在，使用-f 不会报错</p>
<ul>
<li><p>@不显示命令本身，只显示结果。如：@echo clean done</p>
</li>
<li><p>其它<br>make 默认执行第一个出现的目标，可通过 make dest 指定要执行的目标</p>
</li>
<li><p>make -f：-f 执行一个 makefile 文件名称，</p>
<p>使用 make 执行指定的makefile：make -fmainmak</p>
</li>
</ul>
<h3 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h3><h4 id="生成调试信息"><a href="#生成调试信息" class="headerlink" title="生成调试信息"></a>生成调试信息</h4><ul>
<li><p>一般来说 GDB 主要调试的是 C&#x2F;C++的程序。要调试 C&#x2F;C++的程序，首先在编译时，我们必须要把调试信息加到可执行文件中。使用编译器(cc&#x2F;gcc&#x2F;g++)的 -g 参数可以做到这一点。如：<code>gcc -g hello.c -o hello</code></p>
<p>如果没有-g，将看不见程序的函数名、变量名，所代替的全是运行时的内存地址。当你用-g把调试信息加入之后，并成功编译目标代码以后，来调试它。</p>
</li>
</ul>
<h4 id="启动gdb"><a href="#启动gdb" class="headerlink" title="启动gdb"></a>启动gdb</h4><ul>
<li><p>启动gdb：gdb program</p>
<ul>
<li>program 也就是执行文件，一般在当前目录下。</li>
</ul>
</li>
<li><p>设置运行参数</p>
<ul>
<li><p><code>set args</code>可指定运行时参数。(如:set args 10 20 30 40 50)</p>
</li>
<li><p><code>show args</code> 命令可以查看设置好的运行参数。</p>
</li>
</ul>
</li>
<li><p>启动程序</p>
<ul>
<li>run：程序开始执行，如果有断点，停在第一个断点处</li>
<li>start：程序向下执行一行。(在第一条语句处停止)</li>
</ul>
</li>
</ul>
<h4 id="显示源代码"><a href="#显示源代码" class="headerlink" title="显示源代码"></a>显示源代码</h4><p>可以用 list 命令来打印程序的源代码，默认打印 10 行，list 命令的用法如下所示：<br>list linenum：打印第 linenum 行的上下文内容,</p>
<ul>
<li>list function：显示函数名为 function 的函数的源程序。</li>
<li>list：显示当前行后面的源程序。</li>
<li>list -：显示当前文件开始处的源程序。</li>
<li>list file:linenum：显示file 文件下第n行</li>
<li>list file:function：显示file 文件的函数名为 function 的函数的源程序</li>
</ul>
<p>一般是打印当前行的上5行和下5行,如果显示函数是是上2行下8行,默认是 10 行，当然，你也可以定制显示的范围，使用下面命令可以设置一次显示源程序的行数。</p>
<ul>
<li>set listsize count：设置一次显示源代码的行数。</li>
<li>show listsize：查看当前 listsize 的设置。</li>
</ul>
<h4 id="断点操作"><a href="#断点操作" class="headerlink" title="断点操作"></a>断点操作</h4><p>简单断点一当前文件</p>
<ul>
<li>break 设置断点，可以简写为 b<ul>
<li>b 10 设置断点,在源程序第 10 行</li>
<li>b func 设置断点，在func 函数入口处</li>
</ul>
</li>
</ul>
<p>多文件设置断点一其他文件</p>
<ul>
<li>在进入指定函数时停住：<ul>
<li>b filename:linenum – 在源文件 filename 的 linenum 行处停住</li>
<li>b filename:function – 在源文件 filename 的function 函数的入口处停住</li>
</ul>
</li>
</ul>
<p>查询所有断点</p>
<ul>
<li>info b &#x3D;&#x3D; info break &#x3D;&#x3D; i break &#x3D; i b</li>
</ul>
<p>条件断点</p>
<ul>
<li>一般来说，为断点设置一个条件，使用if关键词，后面跟其断点条件。</li>
<li>设置一个条件断点：b test.c:8 if intValue &#x3D;&#x3D; 5</li>
</ul>
<p>维护断点</p>
<p>num是断点序号</p>
<ul>
<li>使断点失效<ul>
<li>disable num</li>
<li>disable [range…]</li>
<li>disable num1,num2,num3…</li>
<li>disable：使所有断点无效</li>
</ul>
</li>
<li>使断点生效<ul>
<li>enable num</li>
<li>enable [range…]</li>
<li>enable num1,num2,num3…</li>
<li>enable：使所有断点有效</li>
</ul>
</li>
<li>删除断点<ul>
<li>delete [range..]：如delete 1-4，删除1到4序号的断点</li>
<li>delete num：删除序号是num的断点</li>
<li>delete num1,num2,num3…：删除序号是num1,num2,num3…的断点</li>
<li>delete ：删除所有断点</li>
</ul>
</li>
</ul>
<h4 id="调试代码"><a href="#调试代码" class="headerlink" title="调试代码"></a>调试代码</h4><ul>
<li>run：运行程序，可简写为r</li>
<li>next：单步跟踪，函数调用当作一条简单语句执行，可简写为n</li>
<li>step：单步跟踪，函数调进入被调用函数体内，可简写为s</li>
<li>finish：退出进入的函数,如果出不去,看一下函数体中的循环中是否有断点，如果有删掉，或者设置无效</li>
<li>until：在一个循环体内单步跟踪时,这个命令可以运行程序直到退出循环体,可简写为 u如果出不去，看一下函数体中的循环中是否有断点，如果有删掉，或者设置无效</li>
<li>continue：继续运行程序，可简写为c(若有断点则跳到下一个断点处)</li>
<li>quit：退出gdb调试</li>
</ul>
<h4 id="查看变量的值"><a href="#查看变量的值" class="headerlink" title="查看变量的值"></a>查看变量的值</h4><ul>
<li><p>查看运行时变量的值</p>
<ul>
<li><p>print 打印变量、字符串、表达式等的值，可简写为p</p>
</li>
<li><p>p count —– 打印 count 的值</p>
</li>
</ul>
</li>
<li><p>自动显示变量的值</p>
<ul>
<li><p>你可以设置一些自动显示的变量，当程序停住时,或是在你单步跟踪时，这些变量会自动显示。相关的 GDB 命令是 display。</p>
</li>
<li><p>display 变量名</p>
</li>
<li><p>info display：查看 display 设置的自动显示的信息。</p>
</li>
<li><p>undisplay num(info display 时显示的编号)</p>
</li>
<li><p>delete display dnums……：删除自动显示,dnums,意为所设置好了的自动显式的编号。如果要同时删除几个，编号可以用空格分隔,如果要删除一个范围内的编号，可以用减号表示</p>
<ul>
<li>删除某个自动显示：undisplay num 或者 delete display num</li>
<li>删除多个：delete display num1 num2</li>
<li>删除一个范围：delete display m-n</li>
</ul>
</li>
<li><p>disable display dnums…</p>
<ul>
<li><p>使一个自动显示无效：disable display num</p>
</li>
<li><p>使多个自动显示无效：delete display num1 num2</p>
</li>
<li><p>使一个范围的自动显示无效：delete display m-n</p>
</li>
</ul>
</li>
<li><p>enable display dnums…</p>
<ul>
<li>使一个自动显示有效: enable display num</li>
<li>使多个自动显示有效:enable display num1num2</li>
<li>使一个范围的自动显示有效:enable display m-n</li>
</ul>
</li>
<li><p>disable 和enalbe 不删除自动显示的设置，而只是让其失效和恢复。</p>
</li>
</ul>
</li>
</ul>
<h4 id="查看修改变量的值"><a href="#查看修改变量的值" class="headerlink" title="查看修改变量的值"></a>查看修改变量的值</h4><ul>
<li><p>ptype width：查看变量 width 的类型</p>
<ul>
<li>type &#x3D; double</li>
</ul>
</li>
<li><p>p width：打印变量 width 的值</p>
<ul>
<li>$4&#x3D; 13</li>
</ul>
</li>
</ul>
<p>可以使用 set var 命令来告诉 GDB, width 不是 GDB 的参数，而是程序的变量名，</p>
<p>如<code>set var width=47</code> &#x2F;&#x2F; 将变量 var 值设置为 47</p>
<p>在你改变程序变量取值时，最好都使用 set var 格式的 GDB 命令</p>
<h2 id="文件IO操作"><a href="#文件IO操作" class="headerlink" title="文件IO操作"></a>文件IO操作</h2><h3 id="C库IO函数的工作流程"><a href="#C库IO函数的工作流程" class="headerlink" title="C库IO函数的工作流程"></a>C库IO函数的工作流程</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240905210833071.png" alt="image-20240905210833071"></p>
<p><strong>使用文件缓冲的目的是为了减少磁盘的读写次数，提高磁盘的效率</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240905212815371.png" alt="image-20240905212815371"></p>
<h3 id="C语言操作文件相关问题"><a href="#C语言操作文件相关问题" class="headerlink" title="C语言操作文件相关问题"></a>C语言操作文件相关问题</h3><p>使用fopen函数打开一个文件，返回一个FILE *fp，这个指针指向的结构体有三个重要的成员</p>
<ul>
<li><p>文件描述符：通过文件描述可以找到文件的inode，通过inode 可以找到对应的磁盘数据块</p>
</li>
<li><p>文件指针：读和写共享一个文件指针，读或者写都会引起文件指针的变化</p>
</li>
<li><p>文件缓冲区：读或者写会先通过文件缓冲区，主要目的是为了减少对磁盘的读写次数,，提高读写磁盘的效率.</p>
</li>
<li><p>头文件 struct_FILE.h 的第49行处：<code>struct _IO_FILE&#123;...&#125;</code>，这个接头体定义中有一个 fileno.成员，这个就是文件描述符</p>
</li>
</ul>
<h3 id="库函数与系统函数的关系"><a href="#库函数与系统函数的关系" class="headerlink" title="库函数与系统函数的关系"></a>库函数与系统函数的关系</h3><p>库函数和系统函数的关系是：调用和被调用的关系</p>
<p>库函数是对系统函数的进一步封装</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240906162521271.png" alt="image-20240906162521271"></p>
<p>Linux 每一个运行的程序(进程)操作系统都会为其分配一个0~4G的地址空间(虚拟地址空间)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240906163757061.png" alt="image-20240906163757061"></p>
<p>​			<code>#define NULL (void*) 0</code></p>
<p>虚拟地址空间：</p>
<ul>
<li>进程的虚拟地址空间分为用户区和内核区，其中内核区是受保护的，用户是不能够对其进行读写操作的;</li>
<li>内核区中很重要的一个就是进程管理，进程管理中有一个区域就是PCB(本质是一个结构体);PCB 中有文件描述符表，文件描述符表中存放着打开的文件描述符，涉及到文件的IO操作都会用到这个文件描述符.</li>
</ul>
<h3 id="PCB和文件描述符表"><a href="#PCB和文件描述符表" class="headerlink" title="PCB和文件描述符表"></a>PCB和文件描述符表</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240906165153083.png" alt="image-20240906165153083"></p>
<p>pcb：</p>
<p>结构体：task_stuct，该结构体在：&#x2F;usr&#x2F;src&#x2F;linux-headers-4.4.0-97&#x2F;include&#x2F;linux&#x2F;sched.h:1390</p>
<p>一个进程有一个文件描述符表：1024大小</p>
<ul>
<li>前三个被占用，分别是STDIN_FILENO，STDOUT_FILENO，STDERR_FILENO</li>
<li>文件描述符作用:通过文件描述符找到inode,通过inode,找到磁盘数据块</li>
</ul>
<p>虚拟地址空间→内核区→PCB→文件描述表→文件描述符→文件 10 操作使用文件描述符</p>
<h3 id="open-close"><a href="#open-close" class="headerlink" title="open&#x2F;close"></a>open&#x2F;close</h3><h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>一个进程启动之后，默认打开三个文件描述符:</p>
<ul>
<li>#define STDIN FILENO</li>
<li>#define STDOUT FILENO</li>
<li>#define STDERR FILENO</li>
</ul>
<p>新打开文件返回文件描述符表中未使用的最小文件描述符，调用 open 函数可以打开或创建新<br>文件，得到一个文件描述符.</p>
<h4 id="open函数"><a href="#open函数" class="headerlink" title="open函数"></a>open函数</h4><ul>
<li><p>函数描述：打开或者新建一个文件</p>
</li>
<li><p>函数原型:</p>
<ul>
<li>int open(const char *pathname, int flags);</li>
<li>int open(const char *pathname, int flags, mode_t mode);</li>
</ul>
</li>
<li><p>函数参数:</p>
<ul>
<li><p>pathname 参数是要打开或创建的文件名,和fopen 一样,pathname 既可以是相对路径也可以是绝对路径。</p>
</li>
<li><p>flags 参数有一系列常数值可供选择,可以同时选择多个常数用按位或运算符连接起来，所以这些常数的宏定义都以O_开头,表示 or。</p>
</li>
<li><p>必选项:以下三个常数中必须指定一个，且仅允许指定一个</p>
<ul>
<li><p>O_RDONLY 只读打开</p>
</li>
<li><p>O_WRONLY 只写打开</p>
</li>
<li><p>O_RDWR 可读可写打开</p>
</li>
</ul>
</li>
<li><p>以下可选项可以同时指定0个或多个，和必选项按位或起来作为flags参数。</p>
</li>
<li><p>可选项有很多，这里只介绍几个常用选项：</p>
<ul>
<li><p>O_APPEND 表示追加。如果文件已有内容，这次打开文件所写的数据附加到文件的末尾而不覆盖原来的内容。</p>
</li>
<li><p>O_CREAT 若此文件不存在则创建它。使用此选项时需要提供第三mode,表示该文件的访问权限。</p>
</li>
<li><p><strong>文件最终权限:mode&amp;~umask</strong></p>
</li>
<li><p>O_EXCL 如果同时指定了 O_CREAT,并且文件已存在,则出错返回。</p>
</li>
<li><p>O_TRUNC 如果文件已存在，将其长度截断为为0字节。</p>
</li>
<li><p>O_NONBLOCK 对于设备文件，以O_NONBLOCK方式打开可以做非阻塞I&#x2F;O(Nonblockl&#x2F;O),非阻塞 I&#x2F;O。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>函数返回值：</p>
<ul>
<li><p>成功：返回一个最小且未被占用的文件描述符</p>
</li>
<li><p>失败：返回-1，并设置errno 值</p>
</li>
</ul>
</li>
</ul>
<h4 id="close函数"><a href="#close函数" class="headerlink" title="close函数"></a>close函数</h4><ul>
<li><p>函数描述：关闭文件</p>
</li>
<li><p>函数原型：int close(int fd);</p>
</li>
<li><p>函数参数：fd 文件描述符</p>
</li>
<li><p>函数返回值：</p>
<ul>
<li><p>成功返回 0</p>
</li>
<li><p>失败返回-1，并设置 errno 值.</p>
</li>
</ul>
</li>
</ul>
<p>​		需要说明的是,当一个进程终止时,内核对该进程所有尚未关闭的文件描述符调用 close 关闭,所以即使用户程序不调用close，在终止时内核也会自动关闭它打开的所有文件。但是对于一个长年累月运行的程序(比如网络服务器)，打开的文件描述符一定要记得关闭，否则随着打开的文件越来越多，会占用大量文件描述符和系统资源。</p>
<h3 id="read-write"><a href="#read-write" class="headerlink" title="read&#x2F;write"></a>read&#x2F;write</h3><h4 id="read函数"><a href="#read函数" class="headerlink" title="read函数"></a>read函数</h4><ul>
<li><p>函数描述：从打开的设备或文件中读取数据</p>
</li>
<li><p>函数原型：ssize_t read(int fd, void *buf, size_t count);</p>
</li>
<li><p>函数参数：</p>
<ul>
<li><p>fd：文件描述符</p>
</li>
<li><p>buf：读上来的数据保存在缓冲区 buf中</p>
</li>
<li><p>count：buf缓冲区存放的最大字节数</p>
</li>
</ul>
</li>
<li><p>函数返回值:</p>
<ul>
<li><p><code>&gt;0</code>：读取到的字节数</p>
</li>
<li><p>&#x3D;0：文件读取完毕</p>
</li>
<li><p>-1：出错，并设置 errno</p>
</li>
</ul>
</li>
</ul>
<h4 id="write函数"><a href="#write函数" class="headerlink" title="write函数"></a>write函数</h4><ul>
<li>函数描述：向打开的设备或文件中写数据</li>
<li>函数原型：ssize_t write(int fd, const void *buf, size_t count);</li>
<li>函数参数：<ul>
<li>fd：文件描述符</li>
<li>buf：缓冲区，要写入文件或设备的数据</li>
<li>count：buf中数据的长度</li>
</ul>
</li>
<li>函数返回值：<ul>
<li>成功：返回写入的字节数</li>
<li>错误：返回-1 并设置 errno</li>
</ul>
</li>
</ul>
<h3 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h3><p>​		所有打开的文件都有一个当前文件偏移量(currentfile offset)，以下简称为 cfo。cfo 通常是一个非负整数，用于表明文件开始处到文件当前位置的字节数，读写操作通常开始于 cfo并且使 cfo 增大，增量为读写的字节数，文件被打开时，cfo 会被初始化为 0，除非使用了O_APPEND。</p>
<p>使用 lseek 函数可以改变文件的 cfo.</p>
<blockquote>
<p>#include &lt;sys&#x2F;types.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>off_t_lseek(int fd, off_t offset, int whence);</p>
</blockquote>
<ul>
<li><p>函数描述：移动文件指针</p>
</li>
<li><p>函数原型：off_t_lseek(int fd, off_t offset,int whence);</p>
</li>
<li><p>函数参数:</p>
<ul>
<li>fd:文件描述符</li>
</ul>
</li>
<li><p>参数 offset 的含义取决于参数 whence</p>
<ul>
<li>如果 whence 是SEEK_SET，文件偏移量将设置为 offset。</li>
<li>如果 whence 是 SEEK_CUR，文件偏移量将被设置为 cfo 加上 offset，offset可以为正也可以为负。</li>
<li>如果 whence 是 SEEK_END，文件偏移量将被设置为文件长度加上 offset,offset 可以为正也可以为负。</li>
</ul>
</li>
<li><p>函数返回值：若lseek成功执行，则返回新的偏移量。</p>
</li>
<li><p>Iseek函数常用操作</p>
<ul>
<li><p>文件指针移动到头部</p>
<ul>
<li>Iseek(fd, 0, SEEK_SET);</li>
</ul>
</li>
<li><p>获取文件指针当前位置</p>
<ul>
<li>int len&#x3D; lseek(fd,0, SEEK_CUR);</li>
</ul>
</li>
<li><p>获取文件长度</p>
<ul>
<li>int len&#x3D; lseek(fd, 0, SEEK_END);</li>
</ul>
</li>
<li><p>lseek实现文件拓展</p>
<p>off_t_currpos;</p>
<p>&#x2F;&#x2F; 从文件尾部开始向后拓展 1000 个字节</p>
<p>currpos&#x3D;lseek(fd,1000,SEEK END);</p>
<p>&#x2F;&#x2F; 额外执行一次写操作，否则文件无法完成拓展</p>
<p>write(fd,“a”,1); &#x2F;&#x2F; 数据随便写</p>
</li>
</ul>
</li>
</ul>
<h3 id="perror-errno"><a href="#perror-errno" class="headerlink" title="perror&#x2F;errno"></a>perror&#x2F;errno</h3><p>errno 是一个全局变量，当系统调用后若出错会将errno 进行设置</p>
<p>一个进程对应一个errno（错误信息）</p>
<p>perror 可以将errno 对应的描述信息打印出来。</p>
<p>如:perror(“open”);如果报错的话打印: open:(空格)错误信息</p>
<h3 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h3><ul>
<li>普通文件:hello.c<ul>
<li>默认是非阻塞的</li>
</ul>
</li>
<li>终端设备:如 &#x2F;dev&#x2F;tty<ul>
<li>默认阻塞</li>
</ul>
</li>
<li>管道（pipe）和套接字（socket）<ul>
<li>默认阻塞</li>
</ul>
</li>
</ul>
<h2 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h2><h3 id="文件操作相关函数"><a href="#文件操作相关函数" class="headerlink" title="文件操作相关函数"></a>文件操作相关函数</h3><h4 id="stat-lstat函数"><a href="#stat-lstat函数" class="headerlink" title="stat&#x2F;lstat函数"></a>stat&#x2F;lstat函数</h4><ul>
<li>函数描述：获取文件属性</li>
<li>函数原型：<ul>
<li>int stat(const char *pathname, struct stat *buf);</li>
<li>int lstat(const char *pathname, struct stat *buf);</li>
</ul>
</li>
<li>函数返回值:<ul>
<li>成功返回 0</li>
<li>失败返回 -1</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">stat</span> &#123;</span><br><span class="line">               <span class="type">dev_t</span>     st_dev;         <span class="comment">/* ID of device containing file */</span></span><br><span class="line">               <span class="type">ino_t</span>     st_ino;         <span class="comment">/* Inode number */</span></span><br><span class="line">               <span class="type">mode_t</span>    st_mode;        <span class="comment">/* File type and mode */</span></span><br><span class="line">               <span class="type">nlink_t</span>   st_nlink;       <span class="comment">/* Number of hard links */</span></span><br><span class="line">               <span class="type">uid_t</span>     st_uid;         <span class="comment">/* User ID of owner */</span></span><br><span class="line">               <span class="type">gid_t</span>     st_gid;         <span class="comment">/* Group ID of owner */</span></span><br><span class="line">               <span class="type">dev_t</span>     st_rdev;        <span class="comment">/* Device ID (if special file) */</span></span><br><span class="line">               <span class="type">off_t</span>     st_size;        <span class="comment">/* Total size, in bytes */</span></span><br><span class="line">               <span class="type">blksize_t</span> st_blksize;     <span class="comment">/* Block size for filesystem I/O */</span></span><br><span class="line">               <span class="type">blkcnt_t</span>  st_blocks;      <span class="comment">/* Number of 512B blocks allocated */</span></span><br><span class="line"></span><br><span class="line">               <span class="comment">/* Since Linux 2.6, the kernel supports nanosecond</span></span><br><span class="line"><span class="comment">                  precision for the following timestamp fields.</span></span><br><span class="line"><span class="comment">                  For the details before Linux 2.6, see NOTES. */</span></span><br><span class="line"></span><br><span class="line">               <span class="keyword">struct</span> <span class="title class_">timespec</span> st_atim;  <span class="comment">/* Time of last access */</span></span><br><span class="line">               <span class="keyword">struct</span> <span class="title class_">timespec</span> st_mtim;  <span class="comment">/* Time of last modification */</span></span><br><span class="line">               <span class="keyword">struct</span> <span class="title class_">timespec</span> st_ctim;  <span class="comment">/* Time of last status change */</span></span><br><span class="line"></span><br><span class="line">           <span class="meta">#<span class="keyword">define</span> st_atime st_atim.tv_sec      <span class="comment">/* Backward compatibility */</span></span></span><br><span class="line">           <span class="meta">#<span class="keyword">define</span> st_mtime st_mtim.tv_sec</span></span><br><span class="line">           <span class="meta">#<span class="keyword">define</span> st_ctime st_ctim.tv_sec</span></span><br><span class="line">           &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>st_mode - 16 位整数</p>
<ul>
<li><p>0-2 bit- 其他人权限</p>
<ul>
<li>S_IROTH		 00004	读权限</li>
<li>S_IWOTH		00002	写权限</li>
<li>S_IXOTH		 00001	执行权限</li>
<li>S_IRWXO		00007掩码，过滤 st_mode 中除其他人权限以外的信息</li>
</ul>
</li>
<li><p>3-5 bit - 所属组权限</p>
<ul>
<li><p>S_IRGRP		 00040		读权限</p>
</li>
<li><p>S_IWGRP		00020		写权限</p>
</li>
</ul>
</li>
<li><p>6-8 bit– 文件所有者权限</p>
<ul>
<li><p>S_IRUSR		 00400		读权限</p>
</li>
<li><p>S_IWUSR		00200		写权限</p>
</li>
<li><p>S_IXUSR		 00100		执行权限</p>
</li>
<li><p>S_IRWXU		00700		掩码，过滤 st_mode 中除文件所有者权限以外的信息</p>
</li>
<li><p>If(st_mode &amp; S_IRUSR)–为真表明可读</p>
</li>
<li><p>If(st_mode &amp; S_IWUSR)—为真表明可写</p>
</li>
<li><p>If(st_mode &amp; S_IXUSR)—为真表明可执行</p>
</li>
</ul>
</li>
<li><p>12-15 bit- 文件类型</p>
<ul>
<li>S_IFSOCK	  0140000      套接字</li>
<li>S_IFLNK		0120000       符号链接(软链接)</li>
<li>S_IFREG		0100000       普通文件</li>
<li>S_IFBLK		0060000		块设备</li>
<li>S_IFDIR		 0040000		目录</li>
<li>S_IFCHR		0020000	   字符设备</li>
<li>S_IFIFO		 0010000		管道</li>
<li>S_IFMT		 0170000		掩码,过滤 st_mode 中除文件类型以外的信息</li>
<li>If((st_mode&amp;S_IFMT)&#x3D;&#x3D;S_IFREG)—为真普通文件</li>
<li>if(S_ISREG(st_mode))–为真表示普通文件</li>
</ul>
</li>
</ul>
<p>lstat和stat函数:</p>
<ul>
<li>对于普通文件来说，lstat函数和stat函数一样</li>
<li>对于软连接文件来说，lstat函数获取的是连接文件本身的属性，stat函数获取的是连接文件指向的文件的属性，</li>
</ul>
<h4 id="access函数"><a href="#access函数" class="headerlink" title="access函数"></a>access函数</h4><p>判断文件是否存在</p>
<ul>
<li><p>函数原型</p>
<ul>
<li>int access(const char *pathname, int mode);</li>
</ul>
</li>
<li><p>mode：</p>
<ul>
<li>F_OK tests for the existence of the file.  </li>
<li>R_OK, W_OK, and X_OK test whether  the  file  exists  and  grants  read,write, and execute permissions, respectively.</li>
</ul>
</li>
<li><p>return</p>
<ul>
<li>On success (all requested permissions granted, or mode is F_OK and the file exists), zero is returned.  </li>
<li>On  error  (at least one bit in mode asked for a permission that is denied, or mode is<br>F_OK and the file does not exist, or some other error occurred), -1 is returned,  and  errno  is set appropriately.</li>
</ul>
</li>
</ul>
<h4 id="目录操作相关函数"><a href="#目录操作相关函数" class="headerlink" title="目录操作相关函数"></a>目录操作相关函数</h4><h5 id="opendir函数"><a href="#opendir函数" class="headerlink" title="opendir函数"></a>opendir函数</h5><p>DIR *opendir(const char *name);</p>
<p>return a pointer to the directory stream.  On error, NULL is returned,  and errno is set appropriately.</p>
<h5 id="readdir函数"><a href="#readdir函数" class="headerlink" title="readdir函数"></a>readdir函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">dirent</span> *<span class="built_in">readdir</span>(DIR *dirp);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dirent</span> &#123;</span><br><span class="line">               <span class="type">ino_t</span>          d_ino;       <span class="comment">/* Inode number */</span></span><br><span class="line">               <span class="type">off_t</span>          d_off;       <span class="comment">/* Not an offset; see below */</span></span><br><span class="line">               <span class="type">unsigned</span> <span class="type">short</span> d_reclen;    <span class="comment">/* Length of this record */</span></span><br><span class="line">               <span class="type">unsigned</span> <span class="type">char</span>  d_type;      <span class="comment">/* Type of file; not supported</span></span><br><span class="line"><span class="comment">                                              by all filesystem types */</span></span><br><span class="line">               <span class="type">char</span>           d_name[<span class="number">256</span>]; <span class="comment">/* Null-terminated filename */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">d_type:</span><br><span class="line">DT_BLK      This is a block device.</span><br><span class="line">DT_CHR      This is a character device.</span><br><span class="line">DT_DIR      This is a directory.</span><br><span class="line"><span class="function">DT_FIFO     This is a named <span class="title">pipe</span> <span class="params">(FIFO)</span>.</span></span><br><span class="line"><span class="function">DT_LNK      This is a symbolic link.</span></span><br><span class="line"><span class="function">DT_REG      This is a regular file.</span></span><br><span class="line"><span class="function">DT_SOCK     This is a UNIX domain socket.</span></span><br><span class="line"><span class="function">DT_UNKNOWN  The file type could <span class="keyword">not</span> be determined.</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>



<h5 id="closedir函数"><a href="#closedir函数" class="headerlink" title="closedir函数"></a>closedir函数</h5><p>int closedir(DIR *dirp);</p>
<p>The closedir() function returns 0 on success.  On error, -1 is returned, and errno is set appropriately.</p>
<h5 id="读取目录内容的一般步骤"><a href="#读取目录内容的一般步骤" class="headerlink" title="读取目录内容的一般步骤"></a>读取目录内容的一般步骤</h5><ul>
<li>DIR *pDir &#x3D; opendir(“dir”); &#x2F;&#x2F;打开目录</li>
<li>while((p&#x3D;readdir(pDir))!&#x3D;NULL){} &#x2F;&#x2F;循环读取文件</li>
<li>closedir(pDir); &#x2F;&#x2F;关闭目录</li>
</ul>
<h3 id="dup-dup2-fcntl"><a href="#dup-dup2-fcntl" class="headerlink" title="dup&#x2F;dup2&#x2F;fcntl"></a>dup&#x2F;dup2&#x2F;fcntl</h3><h4 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h4><ul>
<li>函数描述：复制文件描述符</li>
<li>函数原型：int dup(int oldfd);</li>
<li>函数参数：oldfd-要复制的文件描述符函数返回值:<ul>
<li>成功：返回最小且没被占用的文件描述符</li>
<li>失败：返回-1，设置台rno 值</li>
</ul>
</li>
</ul>
<p>当调用dup函数之后,newfd和fd都指向了同一个文件test.log,内核会在内部维护一个计数，此时计数为2,当close一个文件描述符之后这个计数变为1,只有当计数为0时,文件才会被真正关闭</p>
<h4 id="dup2"><a href="#dup2" class="headerlink" title="dup2"></a>dup2</h4><ul>
<li>函数描述：复制文件描述符</li>
<li>函数原型：int dup2(int oldfd, int newfd);</li>
<li>函数参数：<ul>
<li>oldfd - 原来的文件描述符</li>
<li>newfd - 复制成的新的文件描述符</li>
</ul>
</li>
<li>函数返回值:<ul>
<li>成功：将 oldfd 复制给 newfd,两个文件描述符指向同一个文件</li>
<li>失败：返回-1，设置 errno 值</li>
</ul>
</li>
<li>假设newfd 已经指向了一个文件，首先close 原来打开的文件，然后newfd指向 oldfd指向<br>的文件.</li>
<li>若 newfd 没有被占用，newfd 指向 oldfd 指向的文件,</li>
</ul>
<p>当调用dup2(oldfd, newfd);之后：</p>
<ul>
<li>若newfd原来已经打开了一个文件,则先关闭这个文件,然后newfd指向了和oldfd相同的文件;</li>
<li>若newfd原来没有打开文件,则newfd直接指向和oldfd相同的文件调用dup2函数之后,内核会修改内部的计数,计数为2</li>
</ul>
<h4 id="fcntl"><a href="#fcntl" class="headerlink" title="fcntl"></a>fcntl</h4><ul>
<li><p>函数描述：改变已经打开的文件的属性</p>
</li>
<li><p>函数原型：int fcntl(int fd,int cmd, . &#x2F;* arg*&#x2F;);</p>
<ul>
<li>若 cmd 为F_DUPFD,复制文件描述符,与 dup 相同</li>
<li>若 cmd 为F_GETFL，获取文件描述符的 flag 属性值</li>
<li>若 cmd 为 F_SETFL,设置文件描述符的 flag 属性函数</li>
</ul>
</li>
<li><p>返回值：返回值取决于 cmd</p>
<ul>
<li><p>成功</p>
<ul>
<li>若 cmd 为F_DUPFD,返回一个新的文件描述符</li>
<li>若 cmd 为F_GETFL,返回文件描述符的 flags 值</li>
</ul>
</li>
<li><p>失败返回-1，并设置 errno 值。</p>
</li>
</ul>
</li>
<li><p>fcntl函数常用的操作:</p>
<ul>
<li>复制一个新的文件描述符：int newfd &#x3D; fcntl(fd,F_DUPFD, 0);</li>
<li>获取文件的属性标志：int flag &#x3D; fcntl(fd,F_GETFL, 0);</li>
<li>设置文件状态标志：flag &#x3D; flag | O_APPEND;fcntl(fd, F_SETFL, flag)</li>
<li>常用的属性标志：<ul>
<li>O_APPEND – 设置文件打开为末尾添加</li>
<li>O_NONBLOCK – 设置打开的文件描述符为非阻塞</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="进程相关"><a href="#进程相关" class="headerlink" title="进程相关"></a>进程相关</h2><h3 id="进程相关概念"><a href="#进程相关概念" class="headerlink" title="进程相关概念"></a>进程相关概念</h3><h4 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a>程序和进程</h4><p>程序：是指编译好的二进制文件，在磁盘上，占用磁盘空间，是一个静态的概念</p>
<p>进程：一个启动的程序，进程占用的是系统资源，如:物理内存，CPU，终端等，是一个动态的概念</p>
<p>程序 → 剧本(纸)</p>
<p>进程 - 戏(舞台、演员、灯光、道具…)</p>
<p>同一个剧本可以在多个舞台同时上演。同样，同一个程序也可以加载为不同的进程(彼此之间互不影响)</p>
<p>同一个进程可以在多个终端执行</p>
<p>每启动一个进程就会有一个进程PID，即使是相同的程序多次启动也会有不同的PID</p>
<h4 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h4><ul>
<li>并发：在一个时间段内，是在同一个cpu上，同时运行多个程序。如:若将CPU的1S的时间分成1000个时间片，每个进程执行完一个时间片必须无条件让出 CPU 的使用权，这样1S 中就可以执行1000 个进程。</li>
<li>并行：指两个或两个以上的程序在同一时刻发生(需要有多颗)</li>
</ul>
<h4 id="PCB-进程控制块"><a href="#PCB-进程控制块" class="headerlink" title="PCB-进程控制块"></a>PCB-进程控制块</h4><p>​		每个进程在内核中都有一个进程控制块(PCB)来维护进程相关的信息，Linux内核的进程控制块是 task_struct 结构体。</p>
<p>&#x2F;usr&#x2F;src&#x2F;linux-headers-4.4.0-96&#x2F;include&#x2F;linux&#x2F;sched.h文件的1390行处可以查看 struct task_struct 结构体定义。其内部成员有很多重点掌握以下部分即可：</p>
<ul>
<li>进程id：系统中每个进程有唯一的id，在C语言中用 pid_t类型表示，其实就是一个非负整数。</li>
<li>进程的状态：有就绪、运行、挂起、停止等状态</li>
<li>进程切换时需要保存和恢复的一些 CPU 寄存器。</li>
<li>描述虚拟地址空间的信息。</li>
<li>描述控制终端的信息。</li>
<li>当前工作目录(Current Working Directory)<ul>
<li>getcwd – pwd</li>
</ul>
</li>
<li>umask掩码。</li>
<li>文件描述符表，包含很多指向file 结构体的指针。</li>
<li>和信号相关的信息。</li>
<li>用户 id 和组 id。</li>
<li>会话(Session)和进程组。</li>
<li>进程可以使用的资源上限(Resource Limit)。<ul>
<li>ulimit -a</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240907152047060.png" alt="image-20240907152047060"></p>
<h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><h4 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h4><ul>
<li>函数作用：创建子进程</li>
<li>原型: pid_t fork(void);<ul>
<li>函数参数:无</li>
<li>返回值：<ul>
<li>调用成功：父进程返回子进程的PID，子进程返回0</li>
<li>调用失败：返回-1，设置 errno值。</li>
</ul>
</li>
</ul>
</li>
<li>fork 函数代码片段实例</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240907153203430.png" alt="image-20240907153203430"></p>
<ul>
<li>父进程调用fork函数创建一个子进程，子进程的用户区和父进程的用户区完全一样，但是内核区完全一样，如父进程的PID和子进程的PID不一样.</li>
<li>pid t fork(void);</li>
<li>fork函数的返回值<ul>
<li>父进程返回是子进程的PID，这个值大于0;</li>
<li>子进程返回的是0;</li>
<li>注意: 并不是一个进程返回两个值，而是由父子进程各自返回一个值</li>
</ul>
</li>
<li>父子进程的执行逻辑：<ul>
<li>父进程执行pid&gt;0的逻辑，子进程执行pid&#x3D;&#x3D;0的逻辑</li>
</ul>
</li>
<li>父子进程谁先执行？<ul>
<li>谁先抢到cpu时间片谁先执行</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240907165014676.png" alt="image-20240907165014676"></p>
<p>父子进程不能共享全局变量，但是如果父子进程只是对全局变量做读操作，则父子进程在内存中只有一份,属于共享,但是如果父子进程中的任何一个进程对该变量做修改操作,会在内存中拷贝一个副本,然后在这个副本上进行修改,修改完成以后映射回去<br><strong>写时复制，读时共享</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240907163756828.png" alt="image-20240907163756828"></p>
<h4 id="ps-kill"><a href="#ps-kill" class="headerlink" title="ps&#x2F;kill"></a>ps&#x2F;kill</h4><ul>
<li>ps aux | grep ‘xxx’</li>
<li>ps ajx | grep “xxx”<ul>
<li>-a：(all)当前系统所有用户的进程</li>
<li>-u：查看进程所有者及其他一些信息</li>
<li>-x：显示没有控制终端的进程 - 不能与用户进行交互的进程【输入、输出】</li>
<li>-j：列出与作业控制相关的信息</li>
</ul>
</li>
<li><code>kill -l</code> 查看系统有哪些信号</li>
<li>kill -9 pid 杀死某个线程</li>
</ul>
<h4 id="getpid-getppid"><a href="#getpid-getppid" class="headerlink" title="getpid&#x2F;getppid"></a>getpid&#x2F;getppid</h4><ul>
<li>getpid-得到当前进程的 PID<ul>
<li>pid_t getpid(void);</li>
</ul>
</li>
<li>getppid-得到当前进程的父进程的PID<ul>
<li>pid_t getppid(void);</li>
</ul>
</li>
</ul>
<h3 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h3><h4 id="函数作用和函数介绍"><a href="#函数作用和函数介绍" class="headerlink" title="函数作用和函数介绍"></a>函数作用和函数介绍</h4><p>有的时候需要在一个进程里面执行其他的命令或者是用户自定义的应用程序,此时就用到了 exec 函数族当中的函数。使用方法一般都是在父进程里面调用fork 创建处子进程，然后在子进程里面调用 exec函数。</p>
<p>如果想在一个进程内部执行系统命令或者是应用程序，优先应该想到如下方式:</p>
<p>先fork()，然后在子进程里面执行execl拉起可执行程序或者命令</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">	<span class="built_in">execl</span>(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="execl函数"><a href="#execl函数" class="headerlink" title="execl函数"></a>execl函数</h4><ul>
<li>函数原型: int execl(const char *path, const char <em>arg,. &#x2F;</em>(char *) NULL *&#x2F;);</li>
<li>参数介绍:<ul>
<li>path：要执行的程序的绝对路径</li>
<li>变参 alg：要执行的程序的需要的参数</li>
<li>arg：占位，通常写应用程序的名字</li>
<li>arg后面的：命令的参数</li>
<li>参数写完之后：NULL</li>
</ul>
</li>
<li>返回值：若是成功，则不返回，不会再执行exec函数后面的代码；若是失败，会执行execl后面的代码，可以用perror 打印错误原因。</li>
<li>execl函数一般执行自己写的程序。</li>
</ul>
<h4 id="execlp函数"><a href="#execlp函数" class="headerlink" title="execlp函数"></a>execlp函数</h4><ul>
<li>函数原型：int execlp(const char *file,const char <em>arg,..&#x2F;</em>(char <em>)NULL</em>&#x2F;);</li>
<li>参数介绍：<ul>
<li>file：执行命令的名字，根据 PATH 环境变量来搜索该命令</li>
<li>arg：占位</li>
<li>arg后面的：命令的参数</li>
<li>参数写完之后：NULL（表明参数结束）</li>
</ul>
</li>
<li>返回值：若是成功，则不返回，不会再执行exec函数后面的代码；若是失败，会执行exec后面的代码，可以用perror打印错误原因。</li>
<li>execlp函数一般是执行系统自带的程序或者是命令。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240907165955604.png" alt="image-20240907165955604"></p>
<h3 id="进程回收"><a href="#进程回收" class="headerlink" title="进程回收"></a>进程回收</h3><h4 id="为什么要进行进程资源回收"><a href="#为什么要进行进程资源回收" class="headerlink" title="为什么要进行进程资源回收"></a>为什么要进行进程资源回收</h4><p>当一个进程退出之后,进程能够回收自己的用户区的资源,但是不能回收内核空间的 PCB资源，必须由它的父进程调用 wait 或者 waitpid,函数完成对子进程的回收，避免造成系统资源的浪费。</p>
<h4 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h4><ul>
<li>孤儿进程的概念:<ul>
<li>若子进程的父进程已经死掉，而子进程还存活着，这个进程就成了孤儿进程。为了保证每个进程都有一个父进程，孤儿进程会被init 进程领养，init 进程成为了孤儿进程的养父进程，当孤儿进程退出之后，由init 进程完成对孤儿进程的回收。</li>
</ul>
</li>
</ul>
<h4 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h4><ul>
<li>子进程先退出，父进程没有完全对子进程的回收，此时子进程就变成了僵尸进程</li>
<li>解决僵尸进程：<ul>
<li>不能使用kill -9杀死僵尸进程，原因是僵尸进程是一个死掉的进程。应该使用杀死僵尸父进程的方法来解决僵尸进程。</li>
</ul>
</li>
<li>原因是：<ul>
<li>杀死其父进程可以让init进程领养僵尸进程，最后由init进程回收僵尸进程。</li>
</ul>
</li>
</ul>
<h4 id="进程回收函数"><a href="#进程回收函数" class="headerlink" title="进程回收函数"></a>进程回收函数</h4><h5 id="wait-函数"><a href="#wait-函数" class="headerlink" title="wait 函数"></a>wait 函数</h5><p>函数原型：<code>pid_t wait(int *status)</code></p>
<ul>
<li><p>函数作用：</p>
<ul>
<li>阻塞并等待子进程退出</li>
<li>回收子进程残留资源</li>
<li>获取于进程结束状态(退出原因)。</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功：清理掉的子进程ID;</li>
<li>失败：-1(没有子进程)</li>
</ul>
</li>
<li><p>status 参数：子进程的退出状态 – 传出参数</p>
<ul>
<li><p>WIFEXITED(status)：为非0 → 进程正常结束</p>
</li>
<li><p>WEXITSTATUS(status)：获取进程退出状态</p>
</li>
<li><p>WIFSIGNALED(status)：为非0 → 进程异常终止</p>
</li>
<li><p>WTERMSIG(status)：取得进程终止的信号编号。</p>
</li>
</ul>
</li>
</ul>
<h5 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a>waitpid函数</h5><ul>
<li><p>函数原型：<code>pid_t waitpid(pid_t pid, int *status, in options);</code></p>
</li>
<li><p>函数作用</p>
<ul>
<li>同 wait 函数</li>
</ul>
</li>
<li><p>函数参数</p>
<ul>
<li>参数：<ul>
<li>pid：<ul>
<li>pid &#x3D; -1 [等待任一子进程。与 wait 等效。</li>
<li>pid &gt; 0 等待其进程ID 与 pid,相等的子进程。</li>
<li>pid &#x3D; 0 等待进程组ID 与目前进程相同的任何子进程，也就是说任何和调waitpid()函数的进程在同一个进程组的进程。</li>
<li>pid&lt;-1 等待其组ID 等于 pid,的绝对值的任一子进程。(适用于子进程在其他<br>组的情况)</li>
</ul>
</li>
<li>status：子进程的退出状态，用法同wait函数。</li>
<li>options:设置为WNOHANG，函数非阻塞，设置为0，函数阻塞。</li>
</ul>
</li>
</ul>
</li>
<li><p>函数返回值</p>
<ul>
<li><p><code>&gt;0</code>：返回回收掉的子进程 ID</p>
</li>
<li><p>-1：无子进程</p>
</li>
<li><p>&#x3D;0：参3为WNOHANG，且子进程正在运行。</p>
</li>
</ul>
</li>
</ul>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><h3 id="进程间通信相关概念"><a href="#进程间通信相关概念" class="headerlink" title="进程间通信相关概念"></a>进程间通信相关概念</h3><p>Linux 环境下，进程地址空间相互独立，每个进程各自有不同的用户地址空间。任何一个进程的全局变量在另一个进程中都看不到，所以进程和进程之间不能相互访问，要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区,进程2再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信(IPC,InterProcess Communication)。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240908143827950.png" alt="image-20240908143827950"></p>
<h3 id="进程间通信的方式"><a href="#进程间通信的方式" class="headerlink" title="进程间通信的方式"></a>进程间通信的方式</h3><p>在进程间完成数据传递需要借助操作系统提供特殊的方法，如:文件、管道、信号、共享内存、消息队列、套接字、命名管道等。随着计算机的蓬勃发展，一些方法由于自身设计缺陷被淘汰或者弃用。现今常用的进程间通信方式有:</p>
<ul>
<li>管道(使用最简单)</li>
<li>信号(开销最小)</li>
<li>共享映射区(无血缘关系)</li>
<li>本地套接字(最稳定)</li>
</ul>
<h3 id="管道pipe"><a href="#管道pipe" class="headerlink" title="管道pipe"></a>管道pipe</h3><h4 id="管道的概念"><a href="#管道的概念" class="headerlink" title="管道的概念"></a>管道的概念</h4><p>管道是一种最基本的IPC机制，也称匿名管道，应用于有血缘关系的进程之间，完成数据传递。调用 pipe 函数即可创建一个管道。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240908144230400.png" alt="image-20240908144230400"></p>
<ul>
<li><p>特质：</p>
<ul>
<li><p>管道的本质是一块内核缓冲区</p>
</li>
<li><p>由两个文件描述符引用，一个表示读端，一个表示写端。</p>
</li>
<li><p>规定数据从管道的写端流入管道，从读端流出。</p>
</li>
<li><p>当两个进程都终结的时候，管道也自动消失。</p>
</li>
<li><p><strong>管道的读端和写端默认都是阻塞的</strong></p>
</li>
</ul>
</li>
</ul>
<h4 id="管道的原理"><a href="#管道的原理" class="headerlink" title="管道的原理"></a>管道的原理</h4><ul>
<li>管道的实质是内核缓冲区，内部使用环形队列实现。</li>
<li>默认缓冲区大小为 4K，可以使用 ulimit-a 命令获取大小。</li>
<li>实际操作过程中缓冲区会根据数据压力做适当调整。</li>
</ul>
<h4 id="管道的局限性"><a href="#管道的局限性" class="headerlink" title="管道的局限性"></a>管道的局限性</h4><ul>
<li>数据一旦被读走，便不在管道中存在，不可反复读取。</li>
<li>数据只能在一个方向上流动，若要实现双向流动，必须使用两个管道</li>
<li>只能在有血缘关系的进程间使用管道。</li>
</ul>
<h4 id="创建管道pipe函数"><a href="#创建管道pipe函数" class="headerlink" title="创建管道pipe函数"></a>创建管道pipe函数</h4><ul>
<li>函数作用:<ul>
<li>创建一个管道</li>
</ul>
</li>
<li>函数原型:<ul>
<li>int pipe(int fd[2]);</li>
</ul>
</li>
<li>函数参数:<ul>
<li>若函数调用成功，fd[0]存放管道的读端，fd[1]存放管道的写端</li>
</ul>
</li>
<li>返回值:<ul>
<li>成功返回 0;</li>
<li>失败返回-1，并设置 errno 值。</li>
</ul>
</li>
</ul>
<p>​		函数调用成功返回读端和写端的文件描述符，其中f[0]是读端， fd[1]是写端，向管道读写数据是通过使用这两个文件描述符进行的，读写管道的实质是操作内核缓冲区</p>
<h4 id="父子进程使用管道通信"><a href="#父子进程使用管道通信" class="headerlink" title="父子进程使用管道通信"></a>父子进程使用管道通信</h4><p>​		一个进程在由pipe()创建管道后，一般再fork一个子进程，然后通过管道实现父子间的通信，（只要有共同祖先，都可以采用管道的方式进行通信），父子进程间具有相同的文件描述符，且指向同一个管道pipe，其他没有关系的进程不能获得pipe()产生的两个文件描述符，也就不能利用同一个管道进行通信。</p>
<ul>
<li>第一步：父进程创建管道（fork之前创建）</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240908150421026.png" alt="image-20240908150421026"></p>
<ul>
<li>第二步：父进程fork出子进程</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240908150532613.png" alt="image-20240908150532613"></p>
<ul>
<li>第三步：父进程关闭fd[0]&#x2F;fd[1]，子进程关闭fd[1]&#x2F;fd[0]（根据需要）</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240908150903636.png" alt="image-20240908150903636"></p>
<p>例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">pid_t</span> cpid;</span><br><span class="line">    <span class="type">char</span> buf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Usage: %s &lt;string&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pipe</span>(pipefd) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cpid = fork();</span><br><span class="line">    <span class="keyword">if</span> (cpid == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cpid == <span class="number">0</span>) &#123;    <span class="comment">/* Child reads from pipe */</span></span><br><span class="line">        <span class="built_in">close</span>(pipefd[<span class="number">1</span>]);          <span class="comment">/* Close unused write end */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">read</span>(pipefd[<span class="number">0</span>], &amp;buf, <span class="number">1</span>) &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">write</span>(STDOUT_FILENO, &amp;buf, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">write</span>(STDOUT_FILENO, <span class="string">&quot;\n&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">close</span>(pipefd[<span class="number">0</span>]);</span><br><span class="line">        _exit(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;            <span class="comment">/* Parent writes argv[1] to pipe */</span></span><br><span class="line">        <span class="built_in">close</span>(pipefd[<span class="number">0</span>]);          <span class="comment">/* Close unused read end */</span></span><br><span class="line">        <span class="built_in">write</span>(pipefd[<span class="number">1</span>], argv[<span class="number">1</span>], <span class="built_in">strlen</span>(argv[<span class="number">1</span>]));</span><br><span class="line">        <span class="built_in">close</span>(pipefd[<span class="number">1</span>]);          <span class="comment">/* Reader will see EOF */</span></span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">NULL</span>);                <span class="comment">/* Wait for child */</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例：父子进程间完成<code>ps aux | grep bash</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240908155855509.png" alt="image-20240908155855509"></p>
<h4 id="管道的读写行为"><a href="#管道的读写行为" class="headerlink" title="管道的读写行为"></a>管道的读写行为</h4><ul>
<li><p>读操作</p>
<ul>
<li>有数据<ul>
<li>read 正常读，返回读出的字节数</li>
</ul>
</li>
<li>无数据<ul>
<li>写端全部关闭<ul>
<li>read 解除阻塞，返回0,相当于读文件读到了尾部</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>写操作</p>
<ul>
<li>读端全部关闭<ul>
<li>管道破裂，进程终止，内核给当前进程发SIGPIPE信号</li>
</ul>
</li>
<li>读端没全部关闭<ul>
<li>缓冲区写满了<ul>
<li>write 阻塞</li>
</ul>
</li>
<li>缓冲区没有满<ul>
<li>继续 write</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="如何设置管道为非阻塞"><a href="#如何设置管道为非阻塞" class="headerlink" title="如何设置管道为非阻塞"></a>如何设置管道为非阻塞</h4><p>默认情况下，管道的读写两端都是阻塞的，若要设置读或者写端为非阻塞</p>
<ul>
<li>参考下列三个步骤进行:<ul>
<li>第1步:int flags &#x3D; fcntl(fd[O], F GETFL, O);</li>
<li>第2步:flag |&#x3D;O NONBLOCK;</li>
<li>第3步:fcntl(fd[O], F SETFL, flags);</li>
<li>若是读端设置为非阻塞：<ul>
<li>写端没有关闭，管道中没有数据可读，则read 返回-1</li>
<li>写端没有关闭，<strong>管道中有数据可读</strong>，则read 返回实际读到的字节数</li>
<li>写端已经关闭，<strong>管道中有数据可读</strong>，则read 返回实际读到的字节数</li>
<li>写端已经关闭，管道中没有数据可读，则read 返回0</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="查看管道缓冲区大小"><a href="#查看管道缓冲区大小" class="headerlink" title="查看管道缓冲区大小"></a>查看管道缓冲区大小</h4><ul>
<li>命令<ul>
<li>ulimit -a</li>
</ul>
</li>
<li>函数<ul>
<li>long fpathconf(int fd, int name);</li>
<li>printf(“pipe size&#x3D;&#x3D;[%ld]\n”, fpathconf(fd[0],_PC_PIPE BUF));</li>
<li>printf(“pipe size&#x3D;&#x3D;[%d]\n”, fpathconf(fd[1],_PC_PIPE BUF));</li>
</ul>
</li>
</ul>
<h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>​		FIFO 常被称为命名管道，以区分管道(pipe)。管道(pipe)只能用于“有血缘关系”的进程间通信。&#x3D;&#x3D;但通过 FIFO，不相关的进程也能交换数据&#x3D;&#x3D;。<br>​		FIFO 是 Linux 基础文件类型中的一种(文件类型为 p，可通过ls -l查看文件类型)。但 FIFO 文件在磁盘上没有数据块，文件大小为0，仅仅用来标识内核中一条通道。进程可以打开这个文件进行read&#x2F;write，实际上是在读写内核缓冲区，这样就实现了进程间通信。</p>
<h4 id="创建管道"><a href="#创建管道" class="headerlink" title="创建管道"></a>创建管道</h4><ul>
<li>方式 1<ul>
<li>使用命令 mkfifo</li>
<li>命令格式:mkfifo管道名</li>
<li>例如:mkfifo myfifo</li>
</ul>
</li>
<li>方式 2<ul>
<li>使用函数：int mkfifo(const char *pathname, mode t mode);</li>
<li>参数说明和返回值可以查看 man 3 mkfifo</li>
</ul>
</li>
</ul>
<p>当创建了一个FIFO，就可以使用 open 函数打开它，常见的文件I&#x2F;O 函数都可用于FIFO。如:close、read、write、unlink等。</p>
<p>FIFO 严格遵循先进先出(firstinfirstout)，对 FIFO 的读总是从开始处返回数据，对它们的写则把数据添加到末尾。<strong>它们不支持诸如lseek()等文件定位操作</strong>。</p>
<h4 id="使用FIFO完成两个进程通信"><a href="#使用FIFO完成两个进程通信" class="headerlink" title="使用FIFO完成两个进程通信"></a>使用FIFO完成两个进程通信</h4><p>示意图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240908162829165.png" alt="image-20240908162829165"></p>
<p>思路：</p>
<ul>
<li><p>进程 A：</p>
<ul>
<li>创建一个fifo 文件：myfifo</li>
<li>调用 open 函数打开 myfifo 文件</li>
<li>调用 write 函数写入一个字符串如:“hello world”(其实是将数据写入到了内核缓冲区)</li>
<li>调用 close 函数关闭 myfifo 文件</li>
</ul>
</li>
<li><p>进程 B：</p>
<ul>
<li><p>调用 open 函数打开 myfifo 文件</p>
</li>
<li><p>调用 read 函数读取文件内容(其实就是从内核中读取数据)&#x3D;&#x3D;（此时进程A的fifo文件不能关闭，关闭则没有数据）&#x3D;&#x3D;</p>
</li>
<li><p>打印显示读取的内容</p>
</li>
<li><p>调用 close 函数关闭 myfifo 文件</p>
</li>
</ul>
</li>
</ul>
<h3 id="内存映射区"><a href="#内存映射区" class="headerlink" title="内存映射区"></a>内存映射区</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>​		存储映射 I&#x2F;O (Memory-mapped l&#x2F;O)使一个磁盘文件与存储空间中的一个缓冲区相映射。从缓冲区中取数据，就相当于读文件中的相应字节；将数据写入缓冲区，则会将数据写入文件。这样就可在不使用read和 write 函数的情况下，使用地址(指针)完成 I&#x2F;O 操作。</p>
<p>​		使用存储映射这种方法，首先应通知内核，将一个指定文件映射到存储区域中。这个映射工作可以通过 mmap函数来实现。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240908170428423.png" alt="image-20240908170428423"></p>
<h4 id="mmap函数"><a href="#mmap函数" class="headerlink" title="mmap函数"></a>mmap函数</h4><ul>
<li><p>函数作用:</p>
<ul>
<li>建立存储映射区</li>
</ul>
</li>
<li><p>函数原型</p>
<ul>
<li>void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</li>
</ul>
</li>
<li><p>函数返回值:</p>
<ul>
<li>成功：返回创建的映射区首地址;</li>
<li>失败：MAP_FAILED 宏</li>
</ul>
</li>
<li><p>参数:</p>
<ul>
<li><p>addr：指定映射的起始地址，通常设为 NULL，由系统指定</p>
</li>
<li><p>length：映射到内存的文件长度（lseek或者stat函数）</p>
</li>
<li><p>prot：映射区的保护方式，最常用的:</p>
<ul>
<li>读：PROT_READ</li>
<li>写：PROT_WRITE</li>
<li>读写：PROT_READ | PROT_WRITE</li>
</ul>
</li>
<li><p>flags：</p>
<ul>
<li><p>MAP_SHARED：对映射区的修改会反映到文件中(可以对文件进行修改)</p>
</li>
<li><p>MAP_PRIVATE：对映射区的修改不会对文件产生影响</p>
</li>
<li><p>fd：打开的文件描述符fd &#x3D; open();</p>
</li>
<li><p>offset：以文件开始处的偏移量，必须是4k的整数倍,通常为 0,表示从文件头开始映射。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值</p>
<ul>
<li>映射区的首地址</li>
</ul>
</li>
</ul>
<h4 id="munmap函数"><a href="#munmap函数" class="headerlink" title="munmap函数"></a>munmap函数</h4><ul>
<li>函数作用：<ul>
<li>释放由 mmap函数建立的存储映射区</li>
</ul>
</li>
<li>函数原型：<ul>
<li>int munmap(void *addr, size t length);</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功：返回0</li>
<li>失败：返回-1，设置 errno 值</li>
</ul>
</li>
<li>函数参数：<ul>
<li>addr：调用mmap函数成功返回的映射区首地址</li>
</ul>
</li>
</ul>
<h4 id="mmap注意事项"><a href="#mmap注意事项" class="headerlink" title="mmap注意事项"></a>mmap注意事项</h4><ul>
<li>创建映射区的过程中，隐含着一次对映射文件的读操作，将文件内容读取到映射区</li>
<li>当 MAP_SHARED 时，要求：映射区的权限应&lt;&#x3D;文件打开的权限(出于对映射区的保护)。而 MAP_PRIVATE 则无所谓，因为mmap 中的权限是对内存的限制。</li>
<li>映射区的释放与文件关闭无关，只要映射建立成功，文件可以立即关闭。</li>
<li>&#x3D;&#x3D;特别注意，当映射文件大小为0时，不能创建映射区。所以，用于映射的文件必须要有实际大小；mmap使用时常常会出现总线错误，通常是由于共享文件存储空间大小引起的。&#x3D;&#x3D;</li>
<li>munmap 传入的地址一定是mmap 的返回地址。坚决杜绝指针++操作。</li>
<li>文件偏移量必须为0或者4K的整数倍</li>
<li>mmap创建映射区出错概率非常高，一定要检查返回值，确保映射区建立成功再进行后续操作。</li>
</ul>
<h4 id="mmap函数的使用总结"><a href="#mmap函数的使用总结" class="headerlink" title="mmap函数的使用总结"></a>mmap函数的使用总结</h4><ul>
<li>第一个参数写成 NULL</li>
<li>第二个参数要映射的文件大小&gt;0</li>
<li>第三个参数：PROT_READ、PROT_WRITE</li>
<li>第四个参数：MAP SHARED或者 MAP_PRIVATE</li>
<li>第五个参数：打开的文件对应的文件描述符</li>
<li>第六个参数：4k的整数信</li>
</ul>
<h4 id="使用-mmap函数建立匿名映射"><a href="#使用-mmap函数建立匿名映射" class="headerlink" title="使用 mmap函数建立匿名映射"></a>使用 mmap函数建立匿名映射</h4><p>只能用于有血缘关系的进程间通信</p>
<p>mmap(NULL,4096, PROT_READ|PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);</p>
<p>MAP_ANONYMOUS必须与MAP_SHARED一起使用，而且fd指定为-1</p>
<h2 id="信号相关"><a href="#信号相关" class="headerlink" title="信号相关"></a>信号相关</h2><p><strong><code>kill -l</code> 查看所有信号</strong></p>
<h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li><p>信号的概念</p>
<ul>
<li>信号是信息的载体，Linux&#x2F;UNIX 环境下，古老、经典的通信方式，现下依然是主要的通信手段。</li>
</ul>
</li>
<li><p>信号的特点</p>
<ul>
<li>简单</li>
<li>不能携带大量信息</li>
<li>满足某个特点条件才会产生</li>
</ul>
</li>
</ul>
<h3 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h3><p>​		进程A 给进程B 发送信号，进程B收到信号之前执行自己的代码，收到信号后，不管执行到程序的什么位置，都要暂停运行，去处理信号，处理完毕后再继续执行。与硬件中断类似–异步模式。但信号是软件层面上实现的中断,早期常被称为“软中断”。</p>
<p><strong>每个进程收到的所有信号，都是由内核负责发送的。</strong></p>
<p>进程 A 给进程B发送信号示意图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240908180013078.png" alt="image-20240908180013078"></p>
<p><strong>信号优先级高于普通操作</strong></p>
<h4 id="信号的状态"><a href="#信号的状态" class="headerlink" title="信号的状态"></a>信号的状态</h4><ul>
<li><p>信号有三种状态：产生、未决和递达</p>
<ul>
<li><p>信号的产生</p>
<ul>
<li>按键产生，如：Ctrl+c、Ctrl+z、Ctrl+\</li>
<li>系统调用产生，如：kill、raise、abort</li>
<li>软件条件产生，如：定时器 alarm</li>
<li>硬件异常产生，如：非法访问内存(段错误)、除 0(浮点数例外)、内存对齐出错(总线错误)</li>
<li>命令产生，如：kill 命令</li>
</ul>
</li>
<li><p>未决：产生和递达之间的状态。主要由于阻塞(屏蔽)导致该状态。</p>
</li>
<li><p>递达：递送并且到达进程。</p>
</li>
</ul>
</li>
</ul>
<h4 id="信号的处理方式"><a href="#信号的处理方式" class="headerlink" title="信号的处理方式"></a>信号的处理方式</h4><ul>
<li>执行默认动作</li>
<li>忽略信号(丢弃不处理)</li>
<li>捕捉信号（调用用户的自定义的处理函数）</li>
</ul>
<h4 id="信号的特质"><a href="#信号的特质" class="headerlink" title="信号的特质"></a>信号的特质</h4><p>​		信号的实现手段导致信号<strong>有很强的延时性</strong>，但对于用户来说，时间非常短，不易察觉</p>
<p>​		Linux 内核的进程控制块 PCB 是一个结构体，task_struct,除了包含进程id，状态工作目录，用户id，组id，文件描述符表，还包含了信号相关的信息，主要指<strong>阻塞信号集和未决信号集</strong>。</p>
<h4 id="阻塞信号集和未决信号集"><a href="#阻塞信号集和未决信号集" class="headerlink" title="阻塞信号集和未决信号集"></a>阻塞信号集和未决信号集</h4><h4 id="信号的四要素"><a href="#信号的四要素" class="headerlink" title="信号的四要素"></a>信号的四要素</h4><p>通过 man 7 signal 可以查看信号相关信息</p>
<ul>
<li><p>信号的编号</p>
<ul>
<li>使用 kill -l 命令可以查看当前系统有哪些信号，不存在编号为0的信号。其中1-31 号信号称之为常规信号(也叫普通信号或标准信号)，34-64 称之为实时信号，驱动编程与硬件相关</li>
</ul>
</li>
<li><p>信号的名称</p>
</li>
<li><p>产生信号的事件</p>
</li>
<li><p>信号的默认处理动作</p>
<ul>
<li><p>Term：终止进程</p>
</li>
<li><p>Ign：忽略信号(默认即时对该种信号忽略操作)</p>
</li>
<li><p>Core：终止进程，生成 Core 文件。(查验死亡原因，用于gdb 调试)</p>
</li>
<li><p>Stop：停止(暂停)进程</p>
</li>
<li><p>Cont：继续运行进程</p>
</li>
</ul>
</li>
</ul>
<p>特别需要注意的是：The signals SlGKlLL and SlGSTOP cannot be caught, blocked, oignored.</p>
<p>几个常用到的信号<br>SIGINT, SIGQUIT、SIGKILL、SIGSEGV、SIGUSR1、SIGUSR2、SIGPIPE、SIGALRM，SIGTERM，SIGCHLD、SIGSTOP、SIGCONT</p>
<h3 id="信号相关函数"><a href="#信号相关函数" class="headerlink" title="信号相关函数"></a>信号相关函数</h3><h4 id="signal-函数"><a href="#signal-函数" class="headerlink" title="signal 函数"></a>signal 函数</h4><ul>
<li>函数作用<ul>
<li>注册信号捕捉函数</li>
</ul>
</li>
<li>函数原型<ul>
<li>typedef void (*sighandler_t)(int);</li>
<li>sighandler_t signal(int signum, sighandler_t handler)</li>
</ul>
</li>
<li>函数参数<ul>
<li>signum：信号编号</li>
<li>handler：信号处理函数</li>
</ul>
</li>
</ul>
<h4 id="kill-函数-命令"><a href="#kill-函数-命令" class="headerlink" title="kill 函数&#x2F;命令"></a>kill 函数&#x2F;命令</h4><ul>
<li><p>描述：给指定进程发送指定信号</p>
</li>
<li><p>kill 命令：kill -SIGKILL 进程 PID</p>
</li>
<li><p>kill 函数原型：int kill(pid_t pid, int sig);</p>
</li>
<li><p>函数返回值</p>
<ul>
<li>成功：0</li>
<li>失败：-1，设置errno</li>
</ul>
</li>
<li><p>函数参数</p>
<ul>
<li><p>sig信号参数：不推荐直接使用数字，应使用宏名，因为不同操作系统信号编号可能不同，但名称一致。</p>
</li>
<li><p>pid 参数</p>
<ul>
<li><p>pid&gt;0：发送信号给指定的进程</p>
</li>
<li><p>pid&#x3D;0：发送信号给与调用kill 函数进程属于同一进程组的所有进程。</p>
</li>
<li><p>pid&lt;-1：取|pid|发给对应进程组。</p>
</li>
<li><p>pid&#x3D;-1：发送给进程有权限发送的系统中所有进程。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>进程组:每个进程都属于一个进程组，进程组是一个或多个进程集合，他们相互关联，共同完成一个实体任务，每个进程组都有一个进程组长，默认进程组ID与进程组长 ID 相同。</p>
<h4 id="raise-abort函数"><a href="#raise-abort函数" class="headerlink" title="raise&#x2F;abort函数"></a>raise&#x2F;abort函数</h4><ul>
<li><p>raise 函数</p>
<ul>
<li>函数描述：给当前进程发送指定信号(自己给自己发)</li>
<li>函数原型：int raise(int sig);</li>
<li>函数返回值：成功:0，失败非0值</li>
<li>函数拓展：raise(signo)&#x3D;&#x3D;kill(getpid(),signo);</li>
</ul>
</li>
<li><p>abort 函数</p>
<ul>
<li>函数描述：给自己发送异常终止信号 6)SIGABRT，并产生 core 文件</li>
<li>函数原型：void abort(void);</li>
<li>函数拓展：abort()&#x3D;&#x3D; kill(getpid(),SIGABRT);</li>
</ul>
</li>
</ul>
<h4 id="alarm函数"><a href="#alarm函数" class="headerlink" title="alarm函数"></a>alarm函数</h4><ul>
<li>函数原型：unsigned int alarm(unsigned int seconds);</li>
<li>函数描述：设置定时器(闹钟)。在指定seconds 后，内核会给当前进程发送 <code>14)SIGALRM</code> 信号。进程收到该信号，默认动作终止。<strong>每个进程都有且只有唯一的一个定时器</strong>。</li>
<li>函数返回值：调用函数后直接返回0或剩余的秒数，无失败。<ul>
<li>例如:</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240909190612154.png" alt="image-20240909190612154"></p>
<p>常用操作：取消定时器alarm(0)，返回旧闹钟余下秒数。</p>
<p>alarm 使用的是自然定时法，与进程状态无关，就绪、运行、挂起(阻塞、暂停)、终止、僵尸….无论进程处于何种状态，alarm 都计时。</p>
<p>闹钟</p>
<ul>
<li>实际执行时间&#x3D;系统时间+用户时间+损耗时间</li>
<li>损耗时间&#x3D;实际执行时间(系统时间+用户时间)</li>
</ul>
<p>原因是：调用printf函数打印数字遇到\n才会打印，打印过程涉及到从用户区到内核区的切换，切换次数越多消耗的时间越长，效率越低;而使用文件重定向，由于文件操作是带缓冲的，所以涉及到用户区到内核区的切换次数大大减少，从而使损耗降低。</p>
<h4 id="setitimer函数"><a href="#setitimer函数" class="headerlink" title="setitimer函数"></a>setitimer函数</h4><ul>
<li><p>函数原型</p>
<ul>
<li>int setitimer(int which, const struct itimerval *new_value,struct itimerval *old_value);</li>
</ul>
</li>
<li><p>函数描述</p>
<ul>
<li>设置定时器(闹钟)，可代替alarm函数，精度微秒us，可以实现周期定时。</li>
</ul>
</li>
<li><p>函数返回值</p>
<ul>
<li>成功：0;</li>
<li>失败：-1，设置errno 值</li>
</ul>
</li>
<li><p>函数参数</p>
<ul>
<li><p>which：指定定时方式</p>
<ul>
<li><p>自然定时：ITIMER_REAL&gt;<code>14)SIGALRMT</code>计算自然时间</p>
</li>
<li><p>虚拟空间计时(用户空间)：ITIMER_VIRTUAL&gt;26)SIGVTALRM只计算进程占用 cpu 的时间</p>
</li>
<li><p>运行时计时(用户+内核)：ITIMER_PROF →27)SIGPROF 计算占用 cpu 及执行系统调用的时间</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>new_value：struct itimerval，负责设定 timeout 时间。</p>
<ul>
<li><p>itimerval.it_value：设定第一次执行function所延迟的秒数</p>
</li>
<li><p>itimerval.it_interval：设定以后每几秒执行 function</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">itimerval</span> &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">timerval</span> it_interval;	<span class="comment">// 闹钟触发周期</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">timerval</span> it_value;		<span class="comment">//闹钟触发时间</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span> &#123;</span><br><span class="line">	<span class="type">long</span> tv_sec;	<span class="comment">// 秒</span></span><br><span class="line">	<span class="type">long</span> tv_usec	<span class="comment">// 微秒</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>old_value：存放旧的 timeout 值，一般指定为 NULL</li>
</ul>
</li>
</ul>
<h3 id="信号集相关"><a href="#信号集相关" class="headerlink" title="信号集相关"></a>信号集相关</h3><h4 id="未决信号集和阻塞信号集的关系"><a href="#未决信号集和阻塞信号集的关系" class="headerlink" title="未决信号集和阻塞信号集的关系"></a>未决信号集和阻塞信号集的关系</h4><p>阻塞信号集是当前进程要阻塞的信号的集合，未决信号集是当前进程中还处于未决状态的信号的集合，这两个集合存储在内核的PCB中</p>
<ul>
<li>下面以 SIGINT为例说明信号未决信号集和阻塞信号集的关系<ul>
<li>当进程收到一个 SIGINT信号(信号编号为 2)，首先这个信号会保存在未决信号集合中，此时对应的2号编号的这个位置上置为1，表示处于未决状态；在这个信号需要被处理之前首先要在阻塞信号集中的编号为2的位置上去检查该值是否为 1<ul>
<li>如果为 1，表示 SIGINT信号被当前进程阻塞了，这个信号暂时不被处理，所以未决信号集上该位置上的值保持为1，表示该信号处于未决状态</li>
<li>如果为 0，表示 SIGINT信号没有被当前进程阻塞，这个信号需要被处理，内核会对 SIGINT信号进行处理(执行默认动作，忽略或者执行用户自定义的信号处理函数)，并将未决信号集中编号为2的位置上将1变为0，表示该信号已经处理了，这个时间非常短暂，用户感知不到。</li>
</ul>
</li>
<li>当SIGINT信号从阻塞信号集中解除阻塞之后，该信号就会被处理</li>
</ul>
</li>
</ul>
<p>上述变量类型的定义的查找有个小窍门</p>
<p>可以执行gcc的预处理命令：<code>gcc -E test.c -o test.i</code> 这样头文件就会展开,可以直接到 test.i 文件中看到相关变量类型的定义。</p>
<h4 id="信号集相关函数"><a href="#信号集相关函数" class="headerlink" title="信号集相关函数"></a>信号集相关函数</h4><p>由于信号集属于内核的一块区域，用户不能直接操作内核空间，为此内核提供一些信号集相关的接口函数，使用这些函数用户就可以完成对信号集的相关作。信号集是一个能表示多个信号的数据类型，sigset_t set，set即一个信号集。既然一个集合，就需要对集进行添加、删除等操作。</p>
<p>sigset_t类型的定义在 signal.h 文件中的第 49 行处:</p>
<p><code>typedef __sigset_t sigset_t;</code></p>
<p>__sigset_t的定义在 sigset.h文件中的26，27 行处</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIGSET NWORDS(1024/(8*sizeof (unsigned long int)))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> val[ SIGSET NWORDS];</span><br><span class="line">&#125;<span class="type">__sigset_t</span>;</span><br></pre></td></tr></table></figure>



<p>信号集相关函数</p>
<h5 id="sigemptyset"><a href="#sigemptyset" class="headerlink" title="sigemptyset"></a>sigemptyset</h5><p>int sigemptyset(sigset_t *set);</p>
<ul>
<li>函数说明：将某个<strong>信号集</strong>清 0</li>
<li>函数返回值：<ul>
<li>成功：0</li>
<li>失败：-1，设置errno</li>
</ul>
</li>
</ul>
<h5 id="sigfillset"><a href="#sigfillset" class="headerlink" title="sigfillset"></a>sigfillset</h5><p>int sigfillset(sigset_t*set);</p>
<ul>
<li>函数说明：将某个<strong>信号集</strong>置 1</li>
<li>函数返回值<ul>
<li>成功：0</li>
<li>失败：-1，设置errno</li>
</ul>
</li>
</ul>
<h5 id="sigaddset"><a href="#sigaddset" class="headerlink" title="sigaddset"></a>sigaddset</h5><p>int sigaddset(sigset_t *set, int signum)</p>
<ul>
<li><p>函数说明：将某个信号加入信号集合中</p>
</li>
<li><p>函数返回值</p>
<ul>
<li><p>成功：0</p>
</li>
<li><p>失败：-1，设置errno</p>
</li>
</ul>
</li>
</ul>
<h5 id="sigdelset"><a href="#sigdelset" class="headerlink" title="sigdelset"></a>sigdelset</h5><p>int sigdelset(sigset_t *set, int signum);</p>
<ul>
<li>函数说明<ul>
<li>将某信号从信号清出信号集</li>
</ul>
</li>
<li>函数返回值<ul>
<li>成功：0</li>
<li>失败：-1，设置errno</li>
</ul>
</li>
</ul>
<h5 id="sigismember"><a href="#sigismember" class="headerlink" title="sigismember"></a>sigismember</h5><p>int sigismember(const sigset_t *set, int signum);</p>
<ul>
<li>函数说明<ul>
<li>判断某个信号是否在信号集中</li>
</ul>
</li>
</ul>
<p>函数返回值</p>
<ul>
<li>在：1</li>
<li>不在：0</li>
<li>失败：-1，设置errno</li>
</ul>
<h5 id="sigprocmask"><a href="#sigprocmask" class="headerlink" title="sigprocmask"></a>sigprocmask</h5><ul>
<li><p>函数说明</p>
<ul>
<li>用来屏蔽信号，解除屏蔽也使用该函数。其本质，读取或修改进程控制块中的信号屏蔽字(阻塞信号集)。</li>
</ul>
</li>
<li><p>特别注意，屏蔽信号只是将信号处理延后执行(延至解除屏蔽)；而忽略表示将信号丢弃处理。</p>
</li>
<li><p>函数原型</p>
<ul>
<li><p>int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);</p>
</li>
<li><p>函数返回值</p>
<ul>
<li>成功：0</li>
<li>失败：-1，设置errno</li>
</ul>
</li>
<li><p>函数参数</p>
<ul>
<li><p>how 参数取值：假设当前的信号屏蔽字为mask</p>
<ul>
<li>SIG_BLOCk 当 how 设置为此值，set表示需要屏蔽的信号。相当于mask&#x3D;mask | set</li>
<li>SIG_UNBLOCK  当 how 设置为此，set 表示需要解除屏蔽的信号。相当于 <code>mask=mask &amp; ~set</code></li>
<li>SIG_SETMASK  当 how 设置为此，set表示用于替代原始屏蔽及新屏蔽集。相当于<code>mask = set</code>若，调用sigprocmask 解除了对当若千个信号的阻塞，则在 sigprocmask返回前，至少将其中一个信号递达</li>
</ul>
</li>
<li><p>set：传入参数，是一个自定义信号集合。由参数how 来指示如何修改当前信号屏蔽字。</p>
</li>
<li><p>oldset：传出参数，保存旧的信号屏蔽字。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="sigpending"><a href="#sigpending" class="headerlink" title="sigpending"></a>sigpending</h5><ul>
<li>函数原型<ul>
<li>int sigpending(sigset t*set);</li>
</ul>
</li>
<li>函数说明<ul>
<li>读取当前进程的未决信号集</li>
</ul>
</li>
<li>函数参数<ul>
<li>set 传出参数</li>
</ul>
</li>
<li>函数返回值<ul>
<li>成功：0</li>
<li>失败：-1，设置errno</li>
</ul>
</li>
</ul>
<h3 id="信号捕捉函数"><a href="#信号捕捉函数" class="headerlink" title="信号捕捉函数"></a>信号捕捉函数</h3><p>signal 函数</p>
<ul>
<li>sigaction 函数<ul>
<li>函数说明<ul>
<li>注册一个信号处理函数</li>
</ul>
</li>
<li>函数原型<ul>
<li>int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);</li>
</ul>
</li>
<li>函数参数<ul>
<li>signum：捕捉的信号</li>
<li>act：传入参数，新的处理方式。</li>
<li>oldact：传出参数，旧的处理方式</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sigaction</span> &#123;</span><br><span class="line">    <span class="built_in">void</span> (*sa_handler)(<span class="type">int</span>);	<span class="comment">//信号处理函数</span></span><br><span class="line">    <span class="built_in">void</span> (*sa_sigaction)(<span class="type">int</span>,<span class="type">siginfo_t</span> *,<span class="type">void</span> *);<span class="comment">//信号处理函数</span></span><br><span class="line">    <span class="type">sigset_t</span> sa_mask; 		<span class="comment">//信号处理函数执行期间需要阻塞的信号</span></span><br><span class="line">    <span class="type">int</span> sa_flags; 			<span class="comment">//通常为0，表示使用默认标识</span></span><br><span class="line">    <span class="built_in">void</span> (*sa_restorer)(<span class="type">void</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ul>
<li><p>sa_handler：指定信号捕捉后的处理函数名(即注册函数)。也可赋值为 SIG IGN表忽略 或 SIG DFL表执行默认动作</p>
</li>
<li><p>sa_mask：用来指定在信号处理函数执行期间需要被屏蔽的信号，特别是当某个信号被处理时，它自身会被自动放入进程的信号掩码，因此在信号处理函数执行期间这个信号不会再度发生。</p>
</li>
<li><p>注意:仅在处理函数被调用期间屏蔽生效，是临时性设置。</p>
</li>
<li><p>sa_flags：通常设置为0，使用默认属性。</p>
</li>
<li><p>sa_restorer：已不再使用</p>
</li>
<li><p>在xxx信号处理函数执行期间，若xxx信号再次产生多次，则信号处理函数不会被打断，当信号处理函数执行完以后，后来产生的信号只会被处理一次，<strong>信号不支持排队</strong>。</p>
</li>
<li><p>在xxx信号处理函数执行期间(前提是sa_mask中阻塞了yyy信号)，若收到了多次yyy信号，则yyy信号会被阻塞，当xxx信号处理函数执行完毕后，则yyy信号只会被处理一次</p>
</li>
</ul>
<p><strong>内核实现信号捕捉的过程</strong></p>
<p>​		如果信号的处理动作是用户自定义函数，在信号递达时就调用这个函数，这称为捕捉信号。由于信号处理函数的代码是在用户空间的，处理过程比较复杂，举例如下</p>
<ul>
<li>用户程序注册了SIGQUIT信号的处理函数sighandler。</li>
<li>当前正在执行 main函数，这时发生中断或异常切换到内核态。</li>
<li>在中断处理完毕后要返回用户态的 main 函数之前检查到有信号SIGQUIT递达。</li>
<li>内核决定返回用户态后不是恢复 main 函数的上下文继续执行，而是执行sighandler函数，sighandler和main 函数使用不同的堆栈空间，它们之间不存在调用和被调用的关系，是两个独立的控制流程。</li>
<li>sighandler函数返回后自动执行特殊的系统调用sigreturn 再次进入内核态。</li>
<li>如果没有新的信号要递达，这次再返回用户态就是恢复main函数的上下文继续执行了。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240910154957620.png" alt="image-20240910154957620"></p>
<h3 id="SIGCHLD信号"><a href="#SIGCHLD信号" class="headerlink" title="SIGCHLD信号"></a>SIGCHLD信号</h3><h4 id="产生SIGCHLD信号的条件"><a href="#产生SIGCHLD信号的条件" class="headerlink" title="产生SIGCHLD信号的条件"></a>产生SIGCHLD信号的条件</h4><ul>
<li>子进程结束的时候</li>
<li>子进程收到SIGSTOP信号</li>
<li>当子进程停止时，收到SIGCONT信号</li>
</ul>
<h4 id="SIGCHLD-信号的作用"><a href="#SIGCHLD-信号的作用" class="headerlink" title="SIGCHLD 信号的作用"></a>SIGCHLD 信号的作用</h4><p>​		子进程退出后，内核会给它的父进程发送SIGCHLD信号，父进程收到这个信号后可以对子进程进行回收。<br>​		使用SIGCHLD信号完成对子进程的回收可以避免父进程阻塞等待而不能执行其他操作，只有当父进程收到 SIGCHLD信号之后才去调用信号捕捉函数完成对子进程的回收，未收到SIGCHLD信号之前可以处理其他操作。</p>
<h4 id="使用-SIGCHLD-信号完成对子进程的回收"><a href="#使用-SIGCHLD-信号完成对子进程的回收" class="headerlink" title="使用 SIGCHLD 信号完成对子进程的回收"></a>使用 SIGCHLD 信号完成对子进程的回收</h4><p><strong>注意点</strong></p>
<ul>
<li><p>有可能还未完成信号处理函数的注册三个子进程都退出了。</p>
<ul>
<li>解决办法：可以在 fork 之前先将 SIGCHLD 信号阻塞，当完成信号处理函数的注册后在解除阻塞。</li>
</ul>
</li>
<li><p>当 SIGCHLD 信号函数处理期间,SIGCHLD 信号若再次产生是被阻塞的,而且若产生了多次，则该信号只会被处理一次，这样可能会产生僵尸进程。</p>
<ul>
<li><p>解决办法：可以在信号处理函数里面使用 while(1)循环回收，这样就有可能出现捕获一次 SIGCHLD 信号但是回收了多个子进程的情况，从而可以避免产生僵尸进程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">	<span class="type">pid_t</span> wpid = <span class="built_in">waitpid</span>(<span class="number">-1</span>,<span class="literal">NULL</span>,WNOHANG);</span><br><span class="line">    <span class="keyword">if</span>(wpid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child is quit,wpid=[%d]\n&quot;</span>,wpid);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(wpid==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child is alive,wpid=[%d]\n&quot;</span>,wpid);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(wpid==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;none,wpid=[%d]\n&quot;</span>,wpid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="守护进程和线程"><a href="#守护进程和线程" class="headerlink" title="守护进程和线程"></a>守护进程和线程</h2><h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><h4 id="守护进程介绍"><a href="#守护进程介绍" class="headerlink" title="守护进程介绍"></a>守护进程介绍</h4><p>Daemon(精灵)进程，是Linux 中的后台服务进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以d结尾的名字，如vsftpd</p>
<p>Linux 后台的一些系统服务进程，没有控制终端，不能直接和用户交互。不受用户登录、注销的影响，一直在运行着，他们都是守护进程。如：预读入缓输出机制的实现；ftp服务器；nfs服务器等。</p>
<p>总结守护进程的特点</p>
<ul>
<li>Linux 后台服务进程</li>
<li>独立于控制终端</li>
<li>周期性的执行某种任务</li>
<li>不受用户登陆和注销的影响</li>
<li>一般采用以d结尾的名字</li>
</ul>
<h4 id="进程组和会话"><a href="#进程组和会话" class="headerlink" title="进程组和会话"></a>进程组和会话</h4><p>进程组</p>
<p>进程组是一个或者多个进程的集合，每个进程都属于一个进程组，引入进程组是为了简化对进程的管理。当父进程创建子进程的时候，默认子进程与父进程属于同一个进程组。</p>
<p>进程组 ID &#x3D;&#x3D; 第一个进程 ID(组长进程)。如父进程创建了多个子进程，父进程和多个子进程同属于一个组，而由于父进程是进程组里的第一个进程，所以父进程就是这个组的组长，组长ID &#x3D;&#x3D; 父进程 ID。</p>
<ul>
<li>可以使用 <code>kill -SIGKILL -进程组ID(负的)</code> 来将整个进程组内的进程全部杀死。</li>
<li>只要进程组中有一个进程存在，进程组就存在，与组长进程是否终止无关。</li>
<li>进程组生存期：从进程组创建到最后一个进程离开</li>
</ul>
<p>会话</p>
<ul>
<li><p>一个会话是一个或多个进程组的集合。</p>
</li>
<li><p><strong>创建会话的进程不能是进程组组长</strong></p>
</li>
<li><p>创建会话的进程成为一个进程组的组长进程，同时也成为会话的会长。</p>
</li>
<li><p>需要有 root 权限(ubuntu 不需要)</p>
</li>
<li><p>新创建的会话丢弃原有的控制终端建立新会话时，先调用 fork，父进程终止，子进程调用setsid 函数</p>
</li>
</ul>
<p>可以使用 ps ajx，来查看进程组 ID 和会话 ID</p>
<ul>
<li>可以fork 出几个子进程，然后查看进程组ID和会话ID</li>
</ul>
<p>进程组和会话的关系图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240910173258672.png" alt="image-20240910173258672"></p>
<h3 id="创建守护进程的模型"><a href="#创建守护进程的模型" class="headerlink" title="创建守护进程的模型"></a>创建守护进程的模型</h3><ul>
<li><p>第1步：fork 子进程，父进程退出</p>
<ul>
<li>子进程继承了父进程的进程组 ID，但具有一个新的进程 ID,这样就保证了子进程不是一个进程组的组长 ID,这对于下面要做的setsid,函数的调用是必要的前提条件</li>
</ul>
</li>
<li><p>第2步：子进程调用 setsid 函数创建新会话</p>
<ul>
<li>调用这个函数以后<ul>
<li>该进程成为新会话的首进程，是会话的会长</li>
<li>成为一个新进程组的组长进程，是进程组组长</li>
<li>不受控制终端的影响</li>
</ul>
</li>
</ul>
</li>
<li><p>第3步：改变当前工作目录chdir</p>
<ul>
<li>如:a.out在U盘上，启动这个程序，这个程序的当前的工作目录就是这个u盘，如果u盘拔掉后进程的当前工作目录将消失；a.out将不能正常工作。</li>
</ul>
</li>
<li><p>第4步：重设文件掩码 mode &amp; ~umask</p>
<ul>
<li><p>子进程会继承父进程的掩码增加子进程程序操作的灵活性</p>
</li>
<li><p>增加子进程程序操作的灵活性</p>
</li>
<li><p>umask(0000);</p>
</li>
</ul>
</li>
<li><p>第5步：关闭文件描述符</p>
<ul>
<li><p>守护进程不受控制终端的影响所以可以关闭，以释放资源</p>
</li>
<li><p>close(STDIN_FILENO);</p>
<p>close(STDOUT_FILENO);</p>
<p>cIose(STDERR_FILENO);</p>
</li>
</ul>
</li>
<li><p>第6步：执行核心工作</p>
<ul>
<li>守护进程的核心代码逻辑</li>
</ul>
</li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h4><p>轻量级的进程(LWP：lightweightprocess)，在Linux环境下线程的本质仍是进程。</p>
<p>进程：拥有独立的地址空间，拥有PCB，相当于独居</p>
<p>线程：有 PCB，但没有独立的地址空间，多个线程共享进程空间，相当于合租。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240910190704796.png" alt="image-20240910190704796"></p>
<ul>
<li><p>在 Linux 操作系统下</p>
<ul>
<li>线程：最小的执行单位</li>
<li>进程：最小分配资源单位，可看成是只有一个线程的进程。线程的特点</li>
</ul>
</li>
<li><p>线程的特点</p>
<ul>
<li>类 Unix 系统中，早期是没有“线程”概念的，80年代才引入，借助进程机制实现出了线程的概念。因此在这类系统中，进程和线程关系密切。</li>
<li>线程是轻量级进程(light-weight process)，也有PCB，创建线程使用的底层函数和进程一样，都是 clone</li>
<li>从内核里看进程和线程是一样的，都有各自不同的PCB</li>
<li>进程可以蜕变成线程</li>
<li>在 linux下，线程最是小的执行单位；进程是最小的分配资源单位</li>
</ul>
</li>
<li><p>查看指定线程的 LWP 号：<code>ps -Lf pid</code></p>
</li>
</ul>
<p>实际上，无论是创建进程的fork，还是创建线程的pthread_create，底层实现都是调用同一个内核函数 clone。</p>
<ul>
<li>如果复制对方的地址空间，那么就产出一个“进程”</li>
<li>如果共享对方的地址空间，就产生一个“线程</li>
</ul>
<p>Linux内核是不区分进程和线程的，只在用户层面上进行区分。</p>
<p>所以，线程所有操作函数 pthread_ * 是库函数，而非系统调用。</p>
<h4 id="线程共享资源"><a href="#线程共享资源" class="headerlink" title="线程共享资源"></a>线程共享资源</h4><ul>
<li><p>文件描述符表</p>
</li>
<li><p>每种信号的处理方式</p>
</li>
<li><p>当前工作目录</p>
</li>
<li><p>用户ID 和组ID</p>
</li>
<li><p>内存地址空间 (.text&#x2F;.data&#x2F;.bss&#x2F;heap&#x2F;共享库)</p>
</li>
</ul>
<h4 id="线程非共享资源"><a href="#线程非共享资源" class="headerlink" title="线程非共享资源"></a>线程非共享资源</h4><ul>
<li>线程 id</li>
<li>处理器现场和栈指针(内核栈)</li>
<li>独立的栈空间(用户空间栈)</li>
<li>errno 变量</li>
<li>信号屏蔽字</li>
<li>调度优先级</li>
</ul>
<h4 id="线程优、缺点"><a href="#线程优、缺点" class="headerlink" title="线程优、缺点"></a>线程优、缺点</h4><ul>
<li>优点<ul>
<li>提高程序并发性</li>
<li>开销小</li>
<li>数据通信、共享数据方便</li>
</ul>
</li>
<li>缺点<ul>
<li>库函数，不稳定</li>
<li>gdb 调试、编写困难</li>
<li>对信号支持不好</li>
</ul>
</li>
</ul>
<p>优点相对突出，缺点均不是硬伤。Linux下由于实现方法导致进程、线程差别不是很大。</p>
<h4 id="pthread-create"><a href="#pthread-create" class="headerlink" title="pthread_create"></a>pthread_create</h4><ul>
<li><p>函数作用</p>
<ul>
<li>创建一个新线程</li>
</ul>
</li>
<li><p>函数原型</p>
<ul>
<li>int pthread_create(pthread_t *thread,const pthread_attr_t *attr,void *(*start_routine) (void *),void *arg);</li>
</ul>
</li>
<li><p>返回值</p>
<ul>
<li>成功：返回 0</li>
<li>失败：返回 errno</li>
</ul>
</li>
<li><p>函数参数</p>
<ul>
<li><strong>thread</strong>：指向 <code>pthread_t</code> 类型的指针，用于存储新创建的线程的标识符。</li>
<li><strong>attr</strong>：指向 <code>pthread_attr_t</code> 类型的指针，用于指定线程的属性。如果传递 <code>NULL</code>，则使用默认属性。线程属性包括线程栈大小、调度策略、调度参数等。</li>
<li><strong>start_routine</strong>：新线程将执行的函数的地址（函数指针）。该函数必须返回 <code>void *</code> 类型，并接受一个 <code>void *</code> 类型的参数。</li>
<li><strong>arg</strong>：传递给 <code>start_routine</code> 函数的参数。它的类型是 <code>void *</code>，因此可以传递任何类型的数据，但在 <code>start_routine</code> 函数内部需要适当地进行类型转换。</li>
</ul>
</li>
</ul>
<p><strong>注意点</strong></p>
<ul>
<li><p>由于 pthread_create 的错误码不保存在 errno 中，因此不能直接用 perror()打印错误信息，可以先用 strerror()把错误码转换成错误信息再打印。</p>
</li>
<li><p>如果任意一个线程调用了exit或_exit，则整个进程的所有线程都终止，由于从main 函数return 也相当于调用 exit，为了防止新创建的线程还没有得到执行就终止，我们在 main 函数return 之前延时1秒，这只是一种权宜之计，即使主线程等待1秒，内核也不一定会调度新创建的线程执行。</p>
</li>
<li><p>创建多个线程时</p>
<ul>
<li>不能使多个子线种都共享同一块内存空间，应该使每个子线程访问不同的内存空间，可以在主线程定义一个数组 intarr[5];，然后创建线程的时候分别传递不同的数组元素，这样每个子线程访问的就是互不相同的内存空间，这样就可以打印正确的值。</li>
</ul>
</li>
<li><p>如果主线程早于子线程退出，则子线程可能得不到执行，因为主线程退出，整个进程空间都会被回收，子线程没有了生存空间，所以也就得不到执行。</p>
</li>
<li><p>线程之间(包含主线程和子线程)可以共享同一变量，包含全局变量或者非全局变量(但是非全局变量必须在其有效的生存期内)</p>
</li>
</ul>
<h4 id="pthread-exit"><a href="#pthread-exit" class="headerlink" title="pthread_exit"></a>pthread_exit</h4><p>​		在线程中禁止调用exit函数，否则会导致整个进程退出，取而代之的是调用pthread_exit 函数，这个函数是使一个线程退出，如果主线程调用 pthread_exit 函数也不会使整个进程退出，不影响其他线程的执行。</p>
<ul>
<li><p>函数描述</p>
<ul>
<li>将单个线程退出</li>
</ul>
</li>
<li><p>函数原型</p>
<ul>
<li>void pthread_exit(void *retval);</li>
</ul>
</li>
<li><p>函数参数</p>
<ul>
<li>retval 表示线程退出状态，通常传 NULL</li>
</ul>
</li>
<li><p>另注意，pthread_exit 或者 return 返回的指针所指向的内存单元必须是<strong>全局的或者是用 malloc分配的</strong>，不能在线程函数的栈上分配，因为当其它线程得到这个返回指针时线程函数已经退出了，栈空间就会被回收。</p>
</li>
</ul>
<h4 id="pthread-join"><a href="#pthread-join" class="headerlink" title="pthread_join"></a>pthread_join</h4><ul>
<li><p>函数描述</p>
<ul>
<li>阻塞等待线程退出，获取线程退出状态。其作用，对应进程中的 waitpid()函数。</li>
</ul>
</li>
<li><p>函数原型</p>
<ul>
<li>int pthread_join(pthread_t thread, void **retval);</li>
</ul>
</li>
<li><p>函数返回值</p>
<ul>
<li>成功：0</li>
<li>失败：错误号</li>
</ul>
</li>
<li><p>函数参数</p>
<ul>
<li><p>thread：线程 ID</p>
</li>
<li><p>retval：存储线程结束状态，整个指针和 pthread_exit 的参数是同一块内存地址。</p>
</li>
</ul>
</li>
</ul>
<h4 id="pthread-detach"><a href="#pthread-detach" class="headerlink" title="pthread_detach"></a>pthread_detach</h4><p>​		线程分离状态：指定该状态，线程主动与主控线程断开关系。线程结束后，其退出状态不由其他线程获取，而直接自己自动释放。网络、多线程服务器常用。</p>
<p>​		进程若有该机制，将不会产生僵尸进程。僵尸进程的产生主要由于进程死后，大部分资源被释放，一点残留资源仍存于系统中，导致内核认为该进程仍存在。也可使用 pthread_create 函数参 2(线程属性)来设置线程分离。pthread detach 函数是在创建线程之后调用的。</p>
<ul>
<li><p>函数描述</p>
<ul>
<li>实现线程分离</li>
</ul>
</li>
<li><p>函数原型</p>
<ul>
<li>int pthread_detach(pthread_t thread);</li>
</ul>
</li>
<li><p>函数返回值</p>
<ul>
<li>成功：0</li>
<li>失败：错误号</li>
</ul>
</li>
</ul>
<p>一般情况下，线程终止后，其终止状态一直保留到其它线程调用pthread_join 获取它的状态为止。但是<strong>线程也可以被置为 detach 状态，这样的线程一旦终止就立刻回收它占用的所有资源，而不保留终止状态</strong>。不能对一个已经处于detach 状态的线程调用pthread_join，这样的调用将返回 EINVAL错误。也就是说，如果已经对一个线程调里了pthread_detach 就不能再调用 pthread_join 了。</p>
<h4 id="pthread-cancel"><a href="#pthread-cancel" class="headerlink" title="pthread_cancel"></a>pthread_cancel</h4><ul>
<li><p>函数描述</p>
<ul>
<li>杀死(取消)线程。其作用，对应进程中kill()函数。</li>
</ul>
</li>
<li><p>函数原型</p>
<ul>
<li>int pthread_cancel(pthread_t thread);</li>
</ul>
</li>
<li><p>函数返回值</p>
<ul>
<li>成功：0</li>
<li>失败：错误号</li>
</ul>
</li>
</ul>
<p>【注意】：线程的取消并不是实时的,而有一定的延时。需要等待线程到达某个取消点(检查点)。</p>
<p>​		类似于玩游戏存档，必须到达指定的场所(存档点，如:客栈、仓库、城里等)才能存储进度。杀死线程也不是立刻就能完成，必须要到达取消点。</p>
<p>​		取消点：是线程检查是否被取消，并按请求进行动作的一个位置。通常是一些系统调用creat，open，pause，close，read，write. 执行命令man 7 pthreads 可以查看具备这些取消点的系统调用列表。<strong>可粗略认为一个系统调用(进入内核)即为一个取消点</strong>。还以通过调用 pthread_testcancel函数设置一个取消点。</p>
<p>​											<strong>函数原型：void pthread_testcancel(void);</strong></p>
<h4 id="pthread-equal"><a href="#pthread-equal" class="headerlink" title="pthread_equal"></a>pthread_equal</h4><ul>
<li>函数描述<ul>
<li>比较两个线程ID 是否相等。</li>
</ul>
</li>
<li>函数原型<ul>
<li>int pthread_equal(pthread_t t1, pthread_t t2);</li>
</ul>
</li>
</ul>
<p>注意：这个函数是为了以能够扩展使用的，有可能 Linux 在未来线程ID pthread_t 类型被修改为结构体实现。</p>
<h4 id="进程函数和线程函数比较"><a href="#进程函数和线程函数比较" class="headerlink" title="进程函数和线程函数比较"></a>进程函数和线程函数比较</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240915104757913.png" alt="image-20240915104757913"></p>
<h3 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h3><p>​		Linux 下线程的属性是可以根据实际项目需要，进行设置，之前讨论的线程都是采用线程的默认属性，默认属性已经可以解决绝大多数开发时遇到的问题，如果对程序的性能提出更高的要求，则需要设置线程属性，本节以设置线程的分离属性为例讲解设置线程属性。</p>
<ul>
<li><p>线程的分离状态决定一个线程以什么样的方式来终止自己，有两种状态</p>
<ul>
<li>非分离状态：线程的默认属性是非分离状态，这种情况下，原有的线程等待创建的线程结束。只有当 pthread join()函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。</li>
<li>分离状态：分离线程没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。应该根据自己的需要，选择适当的分离状态。</li>
</ul>
</li>
<li><p>设置线程属性分为以下步骤</p>
<ul>
<li><p>第1步：定义线程属性类型类型的变量</p>
<ul>
<li>pthread_attr_t attr;</li>
</ul>
</li>
<li><p>第2步：对线程属性变量进行初始化</p>
<ul>
<li>int pthread_attr_init (pthread_attr_t* attr);</li>
</ul>
</li>
<li><p>第3步：设置线程为分离属性</p>
<ul>
<li><p>int pthread_attr_setdetachstate(pthread_attr_t *attr,int detachstate);</p>
</li>
<li><p>参数</p>
<ul>
<li><p>attr：线程属性</p>
</li>
<li><p>detachstate</p>
<ul>
<li>PTHREAD_CREATE_DETACHED(分离)</li>
<li>PTHREAD_CREATE_JOINABLE(非分离)</li>
</ul>
</li>
</ul>
</li>
<li><p>这一步完成之后调用 pthread_create 函数创建线程,则创建出来的线程就是分离线程;其实上述三步就是pthread_create 的第二个参数做准备工作。</p>
</li>
</ul>
</li>
<li><p>第4步：释放线程属性资源</p>
<ul>
<li>int pthread_attr_destroy(pthread_attr_t *attr),</li>
<li>参数：线程属性</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><h3 id="线程同步的概念"><a href="#线程同步的概念" class="headerlink" title="线程同步的概念"></a>线程同步的概念</h3><p>​		线程同步，指一个线程发出谋一功能调用时，在没有得到结果之前，该调用不返回。同时其它线程为保证数据一致性，不能调用该功能。</p>
<p>​		创建两个线程，让两个线程共享一个全局变量int number，然后让每个线程数5000次数，看最后打印出这个 number 值是多少?</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> number=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">mythread</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">50000</span>;++i)&#123;</span><br><span class="line">    	++number;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;No.[%d] thread. number : [%d]\n&quot;</span>,*(<span class="type">int</span>*)arg,number);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main : id = [%ld], pid = [%d]\n&quot;</span>,<span class="built_in">pthread_self</span>(),<span class="built_in">getpid</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> arr[<span class="number">2</span>];</span><br><span class="line">    <span class="type">pthread_t</span> thread[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i)&#123;</span><br><span class="line">        arr[i] = i;</span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">pthread_create</span>(&amp;thread[i],<span class="literal">NULL</span>,mythread,&amp;arr[i]);</span><br><span class="line">        <span class="keyword">if</span>(ret!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;pthread error : [%s]\n&quot;</span>,<span class="built_in">strerror</span>(ret));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(thread[<span class="number">0</span>],<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(thread[<span class="number">1</span>],<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;number : [%d]\n&quot;</span>,number);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240915111903973.png" alt="image-20240915111903973"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240915112125668.png" alt="image-20240915112125668"></p>
<ul>
<li>数据混乱的原因<ul>
<li>资源共享(独享资源则不会)</li>
<li>调度随机(线程操作共享资源的先后顺序不确定)</li>
<li>线程间缺乏必要的同步机制。</li>
</ul>
</li>
</ul>
<p>线程间缺乏必要的同步机制。</p>
<ul>
<li>如何解决问题<ul>
<li>原子操作的概念<ul>
<li>原子操作指的是该操作要么不做，要么就完成。</li>
</ul>
</li>
<li>使用互斥锁解决同步问题<ul>
<li>使用互斥锁其实是模拟原子操作，互斥锁示意图</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Linux 中提供一把互斥锁 mutex(也称之为互斥量)。每个线程在对资源操作前都尝试先加锁，成功加锁才能操作，操作结束解锁。</p>
<p>资源还是共享的，线程间也还是竞争的，但通过“锁”就将资源的访问变成互斥操作，而后与时间有关的错误也不会再产生了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240915112331830.png" alt="image-20240915112331830"></p>
<p>线程1访问共享资源的时候要先判断锁是否锁着，如果锁着就阻塞等待;若锁是解开的就将这把锁加锁，此时可以访问共享资源，访问完成后释放锁，这样其他线程就有机会获得锁。</p>
<p>应该注意：图中同一时刻，只能有一个线程持有该锁，只要该线程未完成操作就不释放锁。</p>
<p>使用互斥锁之后，两个线程由并行操作变成了串行操作，效率降低了，但是数据不一致的问题得到解决了。</p>
<h3 id="互斥锁主要相关函数"><a href="#互斥锁主要相关函数" class="headerlink" title="互斥锁主要相关函数"></a>互斥锁主要相关函数</h3><h4 id="pthread-mutex-t-类型"><a href="#pthread-mutex-t-类型" class="headerlink" title="pthread_mutex_t 类型"></a>pthread_mutex_t 类型</h4><ul>
<li>其本质是一个结构体，为简化理解，应用时可忽略其实现细节，简单当成整数看待。</li>
<li>pthread_mutex_t mutex;	变量mutex 只有两种取值 1、0。</li>
</ul>
<h4 id="pthread-mutex-init"><a href="#pthread-mutex-init" class="headerlink" title="pthread_mutex_init"></a>pthread_mutex_init</h4><ul>
<li><p>函数描述</p>
<ul>
<li>初始化一个互斥锁(互斥量)—&gt;初值可看作 1</li>
</ul>
</li>
<li><p>函数原型</p>
<ul>
<li>int pthread mutex init(pthread mutex t *re5trict mutex,const pthread mutexattr t *restrict attr),</li>
</ul>
</li>
<li><p>函数参数</p>
<ul>
<li><p>mutex：传出参数，调用时应传&amp;mutex</p>
</li>
<li><p>attr：互斥锁属性。是一个传入参数，通常传NULL，选用默认属性(线程间共享)。</p>
<p>restrict 关键字：只用于限制指针，告诉编译器，所有修改该指针指向内存中内容的操作，只能通过本指针完成。不能通过除本指针以外的其他变量或指针修改互斥量 mutex的两种初始化方式：</p>
<ul>
<li><p>静态初始化：如果互斥锁 mutex 是静态分配的(定义在全局，或加了static 关键字修饰)，可以直接使用宏进行初始化。</p>
<p>pthead_mutex_t muetx&#x3D;PTHREAD_MUTEX_INITIALIZER;</p>
</li>
<li><p>动态初始化：局部变量应采用动态初始化。</p>
<p>pthread_mutex_init(&amp;mutex, NULL)</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="pthread-mutex-destroy"><a href="#pthread-mutex-destroy" class="headerlink" title="pthread_mutex_destroy"></a>pthread_mutex_destroy</h4><ul>
<li><p>函数描述</p>
<ul>
<li>销毁一个互斥锁</li>
</ul>
</li>
<li><p>函数原型</p>
<ul>
<li>int pthread_mutex_destroy(pthread_mutex_t *mutex);</li>
</ul>
</li>
<li><p>函数参数</p>
<ul>
<li>mutex–  互锁变量</li>
</ul>
</li>
</ul>
<h4 id="pthread-mutex-lock"><a href="#pthread-mutex-lock" class="headerlink" title="pthread_mutex_lock"></a>pthread_mutex_lock</h4><ul>
<li>函数描述<ul>
<li>阻塞函数</li>
<li>对互斥所加锁，可理解为将mutex–</li>
</ul>
</li>
<li>函数原型<ul>
<li>int pthread_mutex_lock(pthread_mutex_t *mutex);</li>
</ul>
</li>
<li>函数参数<ul>
<li>mutex	互斥锁变量</li>
</ul>
</li>
</ul>
<h4 id="pthread-mutex-unlock"><a href="#pthread-mutex-unlock" class="headerlink" title="pthread_mutex_unlock"></a>pthread_mutex_unlock</h4><ul>
<li>函数描述<ul>
<li>对互斥所解锁，可理解为将mutex++</li>
</ul>
</li>
<li>函数原型<ul>
<li>int pthread_mutex_unlock(pthread_mutex_t *mutex);</li>
</ul>
</li>
</ul>
<h4 id="pthread-mutex-trylock"><a href="#pthread-mutex-trylock" class="headerlink" title="pthread_mutex_trylock"></a>pthread_mutex_trylock</h4><ul>
<li>函数描述<ul>
<li>尝试加锁</li>
</ul>
</li>
<li>函数原型<ul>
<li>int pthread_mutex_trylock(pthread_mutex_t*mutex);</li>
</ul>
</li>
<li>函数参数<ul>
<li>mutex	互斥锁变量</li>
</ul>
</li>
</ul>
<h3 id="加锁和解锁"><a href="#加锁和解锁" class="headerlink" title="加锁和解锁"></a>加锁和解锁</h3><ul>
<li>lock 尝试加锁，如果加锁不成功，线程阻塞，阻塞到持有该互斥量的其他线程解锁为止。</li>
<li>unlock 主动解锁函数，同时将阻塞在该锁上的所有线程全部唤醒，至于哪个线程先被唤醒，取决于优先级、调度。默认：先阻塞、先唤醒。</li>
</ul>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><h4 id="互斥锁的使用步骤"><a href="#互斥锁的使用步骤" class="headerlink" title="互斥锁的使用步骤"></a>互斥锁的使用步骤</h4><ul>
<li>第1步：创建一把互斥锁<ul>
<li>pthread_mutex_t mutex;</li>
</ul>
</li>
<li>初始化互斥锁<ul>
<li>pthread_mutex_init(&amp;mutex);	相当于mutex&#x3D;1</li>
</ul>
</li>
<li>在代码中寻找共享资源(也称为临界区)<ul>
<li>pthread mutex lock(&amp;mutex);	mutex&#x3D;0</li>
<li>[临界区代码]</li>
<li>pthread_mutex_unlock(&amp;mutex);   mutex&#x3D; 1</li>
</ul>
</li>
<li>释放互斥锁资源<ul>
<li>pthread_mutex_destroy(&amp;mutex);</li>
</ul>
</li>
<li>注意:必须在所有操作共享资源的线程上都加上锁否则不能起到同步的效果。</li>
</ul>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁并不是 Linux 提供给用户的一种使用方法，而是由于用户使用互斥锁不当引起的一种现象</p>
<ul>
<li><p>常见的死锁有两种</p>
<ul>
<li><p>第一种：自己锁自己，如下图代码片段</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">mythread</span><span class="params">(<span class="type">void</span> *args)</span></span></span><br><span class="line"><span class="function"><span class="title">whi1e</span><span class="params">(<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex)</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hellosleep(rand()%3);</span></span><br><span class="line"><span class="string">    printf(&quot;</span>world\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">    //解锁</span></span><br><span class="line"><span class="string">    pthread_mutex_unlock(&amp;mutex)</span></span><br><span class="line"><span class="string">    sleep(rand()%3);</span></span><br><span class="line"><span class="string">    pthread_exit(NULL);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>第二种线程A拥有A锁，请求获得B锁，线程B拥有B锁，请求获得A锁，这样造成线程A和线程B都不释放自己的锁，而且还想得到对方的锁，从而产生死锁，如下图所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240915142214080.png" alt="image-20240915142214080"></p>
</li>
</ul>
</li>
</ul>
<p>​	</p>
<ul>
<li>如何解决死锁<ul>
<li>让线程按照一定的顺序去访问共享资源</li>
<li>在访问其他锁的时候，需要先将自己的锁解开</li>
<li>调用 pthread_mutex_trylock，如果加锁不成功会立刻返回</li>
</ul>
</li>
</ul>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><ul>
<li><p>什么是读写锁</p>
<ul>
<li>读写锁也叫共享-独占锁。当读写锁以读模式锁住时，它是以共享模式锁住的；当它以写模式锁住时，它是以独占模式锁住的。<strong>写独占、读共享。</strong></li>
</ul>
</li>
<li><p>读写锁使用场合</p>
<ul>
<li>读写锁非常适合于对数据结构读的次数远大于写的情况。</li>
</ul>
</li>
<li><p>读写锁特性</p>
<ul>
<li><p>读写锁是“写模式加锁”时，解锁前，所有对该锁加锁的线程都会被阻塞</p>
</li>
<li><p>读写锁是“读模式加锁”时，如果线程以读模式对其加锁会成功;如果线程以写模式加锁会阻塞。</p>
</li>
<li><p>读写锁是“读模式加锁”时， 既有试图以写模式加锁的线程，也有试图以读模式加锁的线程。那么读写锁会阻塞随后的读模式锁请求。优先满足写模式锁。<strong>读锁、写锁并行阻塞，写锁优先级高</strong></p>
</li>
</ul>
</li>
<li><p>读写锁主要操作函数</p>
<ul>
<li>定义一把读写锁<ul>
<li>pthread_rwlock_t rwlock</li>
</ul>
</li>
<li>初始化读写锁<ul>
<li>int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,const pthread_rwlockattr_t *restrict attr);</li>
<li>函数参数<ul>
<li>rwlock	读写锁</li>
<li>attr	读写锁属性，传NULL为默认属性</li>
</ul>
</li>
</ul>
</li>
<li>销毁读写锁<ul>
<li>int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</li>
</ul>
</li>
<li>加读锁<ul>
<li>int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</li>
</ul>
</li>
<li>尝试加读锁<ul>
<li>int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><ul>
<li>条件本身不是锁”但它也可以造成线程阻塞。通常与互斥锁配合使用。给多线程提供一个会合的场所。<ul>
<li>使用互斥量保护共享数据</li>
<li>使用条件变量可以使线程阻塞，等待某个条件的发生，当条件满足的时候解除阻塞</li>
</ul>
</li>
<li>条件变量的两个动作<ul>
<li>条件不满足，阻塞线程</li>
<li>条件满足，通知阻塞的线程解除阻塞，开始工作</li>
</ul>
</li>
</ul>
<h4 id="条件变量相关函数"><a href="#条件变量相关函数" class="headerlink" title="条件变量相关函数"></a>条件变量相关函数</h4><h5 id="pthread-cond-t-cond"><a href="#pthread-cond-t-cond" class="headerlink" title="pthread_cond_t cond;"></a>pthread_cond_t cond;</h5><ul>
<li>定义一个条件变量</li>
</ul>
<h5 id="int-pthread-cond-init"><a href="#int-pthread-cond-init" class="headerlink" title="int pthread_cond_init"></a>int pthread_cond_init</h5><ul>
<li><p>函数原型</p>
<ul>
<li>int pthread_cond_init(pthread_cond_t *restrict cond,const pthread_condattr_t *restrict attr);</li>
</ul>
</li>
<li><p>函数描述：</p>
<ul>
<li>初始化条件变量</li>
</ul>
</li>
<li><p>函数参数</p>
<ul>
<li>cond：条件变量</li>
<li>attr：条件变量属性，通常传 NULL</li>
</ul>
</li>
<li><p>函数返回值</p>
<ul>
<li>成功：返回 0</li>
<li>失败：返回错误号</li>
</ul>
</li>
</ul>
<h5 id="int-pthread-cond-destroy"><a href="#int-pthread-cond-destroy" class="headerlink" title="int pthread_cond_destroy"></a>int pthread_cond_destroy</h5><ul>
<li><p>函数原型</p>
<ul>
<li>int pthread_cond_destroy(pthread_cond_t *cond);</li>
</ul>
</li>
<li><p>函数描述</p>
<ul>
<li>销毁条件变量</li>
</ul>
</li>
<li><p>函数参数</p>
<ul>
<li>条件变量</li>
</ul>
</li>
<li><p>返回值</p>
<ul>
<li>成功：返回 0</li>
<li>失败：返回错误号</li>
</ul>
</li>
</ul>
<h5 id="int-pthread-cond-wait"><a href="#int-pthread-cond-wait" class="headerlink" title="int pthread_cond_wait"></a>int pthread_cond_wait</h5><ul>
<li><p>函数原型</p>
<ul>
<li>int pthread_cond_wait(pthread_cond_t *restrict cond,pthread_mutex_t *restrict mutex);</li>
</ul>
</li>
<li><p>函数描述</p>
<ul>
<li><strong>条件不满足，引起线程阻塞并解锁</strong></li>
<li><strong>条件满足，解除线程阻塞，并加锁</strong></li>
</ul>
</li>
<li><p>函数参数</p>
<ul>
<li><p>cond：条件变量</p>
</li>
<li><p>mutex：互斥锁变量</p>
</li>
</ul>
</li>
<li><p>函数返回值</p>
<ul>
<li><p>成功：返回 0</p>
</li>
<li><p>失败：返回错误号</p>
</li>
</ul>
</li>
</ul>
<h5 id="int-pthread-cond-signal"><a href="#int-pthread-cond-signal" class="headerlink" title="int pthread_cond_signal"></a>int pthread_cond_signal</h5><ul>
<li><p>函数原型</p>
<ul>
<li>int pthread_cond_signal(pthread_cond_t *cond);</li>
</ul>
</li>
<li><p>函数描述</p>
<ul>
<li>唤醒至少一个阻塞在该条件变量上的线程</li>
</ul>
</li>
<li><p>函数参数</p>
<ul>
<li>条件变量</li>
</ul>
</li>
<li><p>函数返回值</p>
<ul>
<li><p>成功：返回 0</p>
</li>
<li><p>失败：返回错误号</p>
</li>
</ul>
</li>
</ul>
<h5 id="使用条件变量的代码片段"><a href="#使用条件变量的代码片段" class="headerlink" title="使用条件变量的代码片段"></a>使用条件变量的代码片段</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240915151409868.png" alt="image-20240915151409868"></p>
<p>上述代码中，生产者线程调用 pthread_cond_signal 函数会使消费者线程pthread_cond_wait 处解除阻塞。</p>
<p>条件变量</p>
<ul>
<li><p>定义条件变量</p>
<ul>
<li>pthread_cont_t cond;</li>
</ul>
</li>
<li><p>初始化条变量</p>
<ul>
<li>pthread_cond_init(&amp;cond,NULL);</li>
</ul>
</li>
<li><p>在生成者线程中调用:</p>
<ul>
<li>pthread_cond_signal(&amp;cond);</li>
</ul>
</li>
<li><p>在消费者线程中调用:</p>
</li>
<li><p>pthread_cond_wait(&amp;cond,&amp;mutex);</p>
</li>
<li><p>释放条件变量</p>
<ul>
<li>pthread_cond_destroy(&amp;cond);</li>
</ul>
</li>
<li><p>多个生成者和多个消费者程序在执行的时候core掉的原因分析</p>
<ul>
<li>假若只有一个生产者生产了一个节点，此时会调用pthread_cond_signal通知消费者线程，此时若有多个消费者被唤醒了，则最终只有一个消费者获得锁，然后进行消费，此时会将head置为NULL，然后其余的几个消费者线程只会有一个线程获得锁然后读取head的内容就会core掉。</li>
</ul>
</li>
<li><p>在使用条件变量的线程中，能够引起线程的阻塞的地方有两个</p>
<ul>
<li>在条件变量处引起阻塞—-&gt;这个阻塞会被pthread_cond_signal解除阻塞</li>
<li>互斥锁也会使线程引起阻塞—–&gt;其他线程解锁会使该线程解除阻塞</li>
</ul>
</li>
</ul>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><h4 id="信号量介绍"><a href="#信号量介绍" class="headerlink" title="信号量介绍"></a>信号量介绍</h4><p>信号量相当于多把锁，可以理解为是加强版的互斥锁</p>
<h4 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h4><ul>
<li>定义信号量 sem_t sem;</li>
</ul>
<h5 id="int-sem-init"><a href="#int-sem-init" class="headerlink" title="int sem_init"></a>int sem_init</h5><ul>
<li><p>函数原型：int sem_init(sem_t *sem, int pshared, unsigned int value);</p>
</li>
<li><p>函数描述：初始化信号量</p>
</li>
<li><p>函数参数</p>
<ul>
<li>sem：信号量变量</li>
<li>pshared<ul>
<li>0表示线程同步</li>
<li>1表示进程同步</li>
</ul>
</li>
<li>value：最多有几个线程操作共享数据</li>
</ul>
</li>
<li><p>函数返回值</p>
<ul>
<li>成功：返回0</li>
<li>失败：返回-1，并设置errno 值</li>
</ul>
</li>
</ul>
<h5 id="int-sem-wait"><a href="#int-sem-wait" class="headerlink" title="int sem_wait"></a>int sem_wait</h5><ul>
<li><p>函数原型：int sem_wait(sem_t *sem);</p>
</li>
<li><p>函数描述：调用该函数一次，相当于sem–，当sem为0的时候，引起阻塞</p>
</li>
<li><p>函数参数：信号量变量</p>
</li>
<li><p>函数返回值：成功返回0，失败返回-1，并设置errno 值</p>
</li>
</ul>
<h5 id="int-sem-post"><a href="#int-sem-post" class="headerlink" title="int sem_post"></a>int sem_post</h5><ul>
<li>函数原型：int sem_post(sem_t *sem);</li>
<li>函数描述：调用一次，相当于sem++</li>
<li>函数参数：信号量变量</li>
<li>函数返回值：成功返回0，失败返回-1，并设置errno值</li>
</ul>
<h5 id="int-sem-trywait"><a href="#int-sem-trywait" class="headerlink" title="int sem_trywait"></a>int sem_trywait</h5><ul>
<li>函数原型</li>
<li>int sem_trywait(sem_t *sem);</li>
<li>函数描述：尝试加锁，若失败直接返回，不阻塞</li>
<li>函数参数：信号量变量</li>
<li>函数返回值：成功返回0，失败返回-1，并设置errno值</li>
</ul>
<h5 id="int-sem-destroy"><a href="#int-sem-destroy" class="headerlink" title="int sem_destroy"></a>int sem_destroy</h5><ul>
<li><p>函数原型：int sem_destroy(sem_t *sem);</p>
</li>
<li><p>函数描述：销毁信号量</p>
</li>
<li><p>函数参数：信号量变量</p>
</li>
<li><p>函教返回值：成功返回0，失败返回1，并设置errno值</p>
</li>
</ul>
<h1 id="Linux网络编程"><a href="#Linux网络编程" class="headerlink" title="Linux网络编程"></a>Linux网络编程</h1><h2 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h2><h3 id="协议概念"><a href="#协议概念" class="headerlink" title="协议概念"></a>协议概念</h3><p>概念：协议事先约定好，大家共同遵守的一组规则。从应用程序的角度看，协议可理解为数据传输和数据解释的规则；可以简单的理解为各个主机之间进行通信所使用的共同语言。</p>
<p><strong>假设</strong>，A、B 双方欲传输文件。规定：</p>
<p>第一次：传输文件名，接收方接收到文件名，应答 OK 给传输方</p>
<p>第二次：发送文件的尺寸，接收方接收到该数据再次应答一个OK</p>
<p>第三次：传输文件内容。同样，接收方接收数据完成后应答 OK表示文件内容接收成功。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240915164206348.png" alt="image-20240915164206348"></p>
<p>​		这种在A和B之间被遵守的协议称之为原始协议，后来经过不断增加完善改进，最终形成了一个稳定的完整的传输协议，被广泛应用于各种文件传输，该协议逐渐就成了一个标准协议</p>
<h3 id="典型协议"><a href="#典型协议" class="headerlink" title="典型协议"></a>典型协议</h3><p>传输层：常见协议有TCP&#x2F;UDP 协议</p>
<p>应用层：常见的协以有HTTP协议，FTP协议</p>
<p>网络层：常见协议有IP协议、ICMP 协议、IGMP 议。</p>
<p>网络接口层：常见办议有ARP协议、RARP协议</p>
<p>TCP 传输控制协议(Transmission ControlProtocol)是一种面向连接的、可靠的、基于字节流的传输层通信协议</p>
<p>UDP 用户数据报协议(User patagram Protocol)是 OSI 参考模型中一种无连接的传输层协议，提供而向事务的简单不可靠信息传送服务。</p>
<p>HTTP 超文本传输协议(Hyper Text Transfer Protocol)是互联网上应用最为广泛的一种网络协议。</p>
<p>FTP 文件传输协议(File Transfer Protocol)</p>
<p>IP 协议是因特网互联协议(intemet Protocol)</p>
<p>ICMP 办议是interet 控制报文协议(internet control Message protocol)它是TCP&#x2F;IP,协议族的一个子协议，用于在P主机、路由器之间传递控制消息。</p>
<p>IGMP 协议是 Intemet 组管理协议(internet Group Management Protocol)，是因特网协议家族中的一个组播协该协议运行在主机和组播路由器之间。</p>
<p>ARP 协议是正向地址解析协议(Address Resolution Protocol)，通过已知的 IP，寻找对应主机的 MAC 地址。</p>
<p>RARP 是反向地址转换协议，通过MAC 地址确定IP地址。</p>
<h3 id="OSI七层模型-TCP-IP四层模型"><a href="#OSI七层模型-TCP-IP四层模型" class="headerlink" title="OSI七层模型 &amp; TCP&#x2F;IP四层模型"></a>OSI七层模型 &amp; TCP&#x2F;IP四层模型</h3><p>OSl是 Open System Interconnection 的缩写，意为开放式系统互联：国际标准化组织(ISO)制定了 OSI模型，该模型定义了不同计算机互联的标准,是设计和描述计算机网络通信的基本框架。</p>
<p>网络分层 OSI 7层模型：<strong>物数网传会表应</strong></p>
<ul>
<li>物理层：双绞线，光纤(传输介质)，将模拟信号转换为数字信号</li>
<li>数据链路层：数据校验，定义了网络传输的基本单位：帧</li>
<li>网络层：定义网络，两台机器之间传输的路径选择点到点的传输</li>
<li>传输层：传输数据 TCP，UDP，端到端的传输</li>
<li>会话层：通过传输层建立数据传输的通道</li>
<li>表示层：编解码，翻译工作</li>
<li>应用层：为客户提供各种应用服务，emaiI服务，ftp服务，ssh服务</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240915165744172.png" alt="image-20240915165744172"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240915170020604.png" alt="image-20240915170020604"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240915170048270.png" alt="image-20240915170048270"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240915173746095.png" alt="image-20240915173746095"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picx.zhimg.com/80/v2-d9b090fa56b7e6730189a6347d37ee33_720w.webp" alt="img"></p>
<h3 id="网络应用程序设计模式"><a href="#网络应用程序设计模式" class="headerlink" title="网络应用程序设计模式"></a>网络应用程序设计模式</h3><h4 id="C-S-模式"><a href="#C-S-模式" class="headerlink" title="C&#x2F;S 模式"></a>C&#x2F;S 模式</h4><p>​		传统的网络应用设计模式，客户机(client)&#x2F;服务器(server)模式。需要在通讯两端各自部署客户机和服务器来完成数据通信。</p>
<h4 id="B-S-模式"><a href="#B-S-模式" class="headerlink" title="B&#x2F;S 模式"></a>B&#x2F;S 模式</h4><p>​		浏览器()&#x2F;服务器(server)模式。只需在一端部署服务器，而另外一端使用每台 PC都默认配置的浏览器即可完成数据的传输。</p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="C-S"><a href="#C-S" class="headerlink" title="C&#x2F;S"></a>C&#x2F;S</h5><p>​		对于 C&#x2F;S 模式来说，其优点明显。客户端位于目标主机上可以保证性能，将数据缓存至客户端本地，从而提高数据传输效率。且一般来说客户端和服务器程序由一个开发团队创作，所以他们之间所采用的协议相对灵活。可以在标准协议的基础上根据需求裁剪及定制。例如，腾讯公司所采用的通信协议，即为ftp 协议的修改剪裁版。</p>
<p>​		因此，传统的网络应用程序及较大型的网络应用程序都首选 C&#x2F;S 模式进行开发。如，知名的网络游戏魔兽世界。3D画面，数据量庞大，使用 C&#x2F;S 模式可以提前在本地进行大量数据的缓存处理，从而提高观感。</p>
<p>C&#x2F;S 模式的缺点也较突出。由于客户端和服务器都需要有一个开发团队来完成开发。工作量将成倍提升，开发周期较长。另外，从用户角度出发，需要将客户端安插至用户主机上，对用户主机的安全性构成威胁。这也是很多用户不愿使用 C&#x2F;S 模式应用程序的重要原因。</p>
<h5 id="B-S"><a href="#B-S" class="headerlink" title="B&#x2F;S"></a>B&#x2F;S</h5><p>​		B&#x2F;S 模式相比 c&#x2F;s 模式而言，由于它没有独立的客户端，使用标准浏览器作为客户端，其工作开发量较小。只需开发服务器端即可。另外由于其采用浏览器显示数据，因此移植性非常好，不受平台限制。如早期的偷菜游戏，在各个平台上都可以完美运行。</p>
<p>B&#x2F;S 模式的缺点也较明量，由于使用第三方浏览器，因此网络应用支持受限。另外，没有客户端放到对方主机上，缓存数据不尽如人意，从而传输数据量受到限制。应用的观感大打折扣。第三，必须与浏览器一样，采用标准 http 协议进行通信，协议选择不灵活</p>
<p>因此在开发式中，模式的选择由上述各自的特点决定，根据实际需求选择应用程序设计模式</p>
<h3 id="以太网帧格式"><a href="#以太网帧格式" class="headerlink" title="以太网帧格式"></a>以太网帧格式</h3><p>以太网帧格式就是包装在网络接口层(数据链路层)的协议</p>
<h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240915171744257.png" alt="image-20240915171744257"></p>
<p>以ARP为例介绍以太网帧格式</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240915172327822.png" alt="image-20240915172327822"></p>
<p>​		目的端mac 地址是通过发送端发送ARP 广播，接收到该ARP 数据的主机先判断是否是自己的 IP，若是则应答一个ARP 应答报文，并将mac 地址填入应答报文中；若目的 IP 不是自己的主机 IP，则直接丢弃该 ARP 请求报文。</p>
<p>例：（不知道目标MAC地址用 ff:ff:ff:ff:ff:ff）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240915173137924.png" alt="image-20240915173137924"></p>
<h3 id="IP-段格式"><a href="#IP-段格式" class="headerlink" title="IP 段格式"></a>IP 段格式</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240915173412687.png" alt="image-20240915173412687"></p>
<p>协议版本：ipv4,ipv6</p>
<p>16 位总长度：最大 65536</p>
<p>8 位生存时间 ttl(网络连接下一跳的次数)：为了防止网络阻塞</p>
<p>32 位源 ip 地址,共个4字节！我们熟悉的 ip 都是点分十进制的4 字节，每字节对应一个点分位，最大为255，实际上就是整形数</p>
<p>32位目的ip地址</p>
<p>8 位协议：用来区分上层协议是TCP,UDP,ICMP 还是IGMP 协议</p>
<p>16位首部校验和：只校验IP首部，数据的校验由更高层协议负责</p>
<h3 id="UDP-数据报格式"><a href="#UDP-数据报格式" class="headerlink" title="UDP 数据报格式"></a>UDP 数据报格式</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240915173926138.png" alt="image-20240915173926138"></p>
<p>通过IP 地址来确定网络环境中的唯一的一台主机</p>
<p>主机上使用端口号来区分不同的应用程序</p>
<p>IP+端口唯一确定唯一一台主机上的一个应用程序</p>
<h3 id="TCP数据流格式"><a href="#TCP数据流格式" class="headerlink" title="TCP数据流格式"></a>TCP数据流格式</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://i-blog.csdnimg.cn/blog_migrate/beb9efd84baa32298713cb642d72811e.png" alt="1"></p>
<ul>
<li><p>SYN(synchronous)：表示请求</p>
</li>
<li><p>ACK(acknowledgement)：表示确认</p>
</li>
<li><p>服务端发送的SYN和客户端发送的SYN本身也会占1位</p>
</li>
<li><p>三次握手和四次挥手的过程都是在内核实现的，</p>
</li>
<li><p>稳定的，安全的，可靠的</p>
</li>
<li><p>序号：TCP 是安全可靠的，每个数据包都带有序号，当数据包丢失的时候，需要重传，要使用序号进行重传，控制数据有序，丢包重传</p>
</li>
<li><p>确认序号：使用确认序号可以知道对方是否已经收到了，通过确认序号可以知道哪个序号的数据需要重传</p>
</li>
<li><p>16 位窗口大小–滑动窗口(主要进行流量控制)</p>
</li>
<li><p>为什么 TCP 是面向连接的安全可靠的传输</p>
<ul>
<li>TCP 是面向连接的安全的数据传输，在客户端与服务端建立建立的时候要经过三次握手的过程，在客户端与服务端断开连接的时候要经历四次挥手的过程下图是客户端与服务端三次握手建立连接，数据传输和断开连接四次挥手的全过程</li>
</ul>
</li>
<li><p>MSS（Maximum Segment Size）是指最大报文段长度，它是TCP协议的一个选项，用于在TCP连接建立时，收发双方协商通信时每一个报文段所能承载的最大数据长度（不包括文段头）。MSS的设定对于TCP连接的传输效率有重要影响，因为它决定了TCP层每次能够传输的最大数据分段大小。（对方一次可以接受多少数据）</p>
</li>
<li><p>MTU：最大传输单元，通信术语及大传输单元 (MaximumTransmission Unit，MTU) 是指一种通信协议的某一层上面所能通过的最大数据包大小(以字节为单位).最大传输单元这个参数通常与通信接口有关(网络接口卡、串口等)，这个值如果设置为太大会导致丢包重传的时候重传的数据量较大，图中的最大值是 1500，其实是一个经验值，</p>
</li>
</ul>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240916172507505.png" alt="image-20240916172507505"></p>
<h4 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://i-blog.csdnimg.cn/blog_migrate/80bfe4da02598a8cd7a04d5268e5c1e5.png" alt="在这里插入图片描述"></p>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240916172618035.png" alt="image-20240916172618035"></p>
<p>测试过程中可以使用 netstat 命令查看监听状态和连接状态</p>
<ul>
<li>netstat 命令<ul>
<li>a：表示显示所有</li>
<li>n：表示显示的时候以数字的方式来显示</li>
<li>p：表示显示进程信息(进程名和进程 PID)</li>
</ul>
</li>
</ul>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>主要作用：滑动窗口主要是进行流量控制的</p>
<p>见下图：如果发送端发送的速度较快，接收端接收到数据后处理的速度较慢，而接收缓冲区的大小是固定的，就会导致接收缓冲区满而丢失数据。TCP 协议通过 “滑动窗口(Sliding Window)” 机制解决这一问题。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://i-blog.csdnimg.cn/blog_migrate/13af72b5441be9a35d8b3b23d0b9ec18.png" alt="在这里插入图片描述"></p>
<h3 id="函数封装思想"><a href="#函数封装思想" class="headerlink" title="函数封装思想"></a>函数封装思想</h3><p>函数封装的思想-处理异常情况</p>
<p>​		结合man-page 和errno 进行封装,</p>
<p>​		在封装的时候起名可以把第一个函数名的字母大写，如 socket 可以封装成Socket，这样可以按 shift+k 进行搜索，shift+k搜索函数说明的时候不区分大小写使用 man page 也可以査看，man page 对大小写不区分，像 accept，read 这样的能够引起阻塞的函数，若被信号打断，由于信号的优先级较高，会优先处理信号，信号处理完成后，会使accept 或者read 解除阻塞，然后返回，此时返回值为 -1，设置errno&#x3D;EINTR;</p>
<p>errno&#x3D;ECONNABORTED 表示连接被打断，异常</p>
<p>errno 宏</p>
<p>在&#x2F;usr&#x2F;include&#x2F;asm-generic&#x2F;errno.h文件中包含了errno 所有的宏和对应的错误描述信息</p>
<h3 id="粘包"><a href="#粘包" class="headerlink" title="粘包"></a>粘包</h3><p>多次数据发送，收尾相连，接收端接收的时候不能正确区分第一次发送多少，第二次发送多少。</p>
<p>即这次读的数据有上一次的数据</p>
<p>粘包问题分析和解决</p>
<ul>
<li>方案 1：包头+数据<ul>
<li>如4位的数据长度+数据—&gt;00101234567890其中 0010 表示数据长度,1234567890 表示 10 个字节长度的数据，另外，发送端和接收端可以协商更为复杂的报文结构，这个报文结构就相当于双方约定的一个协议。</li>
</ul>
</li>
<li>方案2：添加结尾标记<ul>
<li>如结尾最后一个字符为<code>\n \$</code>等</li>
</ul>
</li>
<li>方案3：数据包定长<ul>
<li>如发送方和接收方约定，每次只发送128个字节的内容，接收方接收定长128个字节就可以了</li>
</ul>
</li>
</ul>
<h2 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h2><ul>
<li><p>大端和小端的概念</p>
<ul>
<li>大端（高端字节序，网络字节序）：低位地址存放高位数据，高位地址存放低位数据</li>
<li>小端（低端字节序）：低位地址存放低位数据，高位地址存放高位数据</li>
</ul>
</li>
<li><p>大端和小端的使用使用场合</p>
<ul>
<li>大端和小端只是对数据类型长度是两个及以上的，如int，short，对于单字节没限制，在网络中经常需要考虑大端和小端的是IP 和端口</li>
</ul>
</li>
</ul>
<p>例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span>&#123;</span><br><span class="line">    <span class="type">short</span> s;</span><br><span class="line">    <span class="type">char</span> c[<span class="built_in">sizeof</span>(<span class="type">short</span>)];</span><br><span class="line">&#125;un2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span>&#123;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    <span class="type">char</span> c[<span class="built_in">sizeof</span>(<span class="type">int</span>)];</span><br><span class="line">&#125;un4;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>,<span class="built_in">sizeof</span>(<span class="type">short</span>),<span class="built_in">sizeof</span>(<span class="type">int</span>),<span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    un<span class="number">2.</span>s = <span class="number">0x0102</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>,un<span class="number">2.</span>c[<span class="number">0</span>],un<span class="number">2.</span>c[<span class="number">1</span>],un<span class="number">2.</span>s);</span><br><span class="line"></span><br><span class="line">    un<span class="number">4.</span>s = <span class="number">0x01020304</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d %d\n&quot;</span>,un<span class="number">4.</span>c[<span class="number">0</span>],un<span class="number">4.</span>c[<span class="number">1</span>],un<span class="number">4.</span>c[<span class="number">2</span>],un<span class="number">4.</span>c[<span class="number">3</span>],un<span class="number">4.</span>s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240916141049165.png" alt="image-20240916141049165"></p>
<p>可以看出这台机器是小端，低位 02 放在低位 c[0] 中</p>
<h3 id="大小端转换函数"><a href="#大小端转换函数" class="headerlink" title="大小端转换函数"></a>大小端转换函数</h3><p>网络传输用的是大端法</p>
<p>如果机器用的是小端法，则需要进行大小端的转换</p>
<p>下面4个函数就是进行大小端转换的函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span></span>;</span><br><span class="line"><span class="function"><span class="type">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span></span>;</span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span></span>;</span><br><span class="line"><span class="function"><span class="type">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span></span>;</span><br></pre></td></tr></table></figure>

<p>函数名的h表示主机 host，n表示网络network，s表示short，l表示long</p>
<p>上述的几个函数，如果本来不需要转换函数内部就不会做转换</p>
<h3 id="IP-地址转换函数"><a href="#IP-地址转换函数" class="headerlink" title="IP 地址转换函数"></a>IP 地址转换函数</h3><h4 id="点分十进制IP转网络IP"><a href="#点分十进制IP转网络IP" class="headerlink" title="点分十进制IP转网络IP"></a>点分十进制IP转网络IP</h4><ul>
<li>int inet_pton(int af, const char *src, void *dst);<ul>
<li>函数说明<ul>
<li>将字符串形式的点分十进制 IP 转换为大端模式的网络 IP(整型 4字节数)</li>
</ul>
</li>
<li>p-&gt;表示点分十进制的字符串形式</li>
<li>to-&gt;到</li>
<li>n-&gt;表示network 网络</li>
<li>参数说明<ul>
<li>af：AF_INET（IPV4），AF_INET6（IPV6）</li>
<li>src：字符串形式的点分十进制的IP 地址</li>
<li>dst：存放转换后的变量的地址</li>
</ul>
</li>
</ul>
</li>
<li>例如：inet_pton(AF_INET,”127.0.0.1”,&amp;serv.sin_addr.s_addr);</li>
</ul>
<h4 id="网络IP转点分十进制IP"><a href="#网络IP转点分十进制IP" class="headerlink" title="网络IP转点分十进制IP"></a>网络IP转点分十进制IP</h4><ul>
<li><p>const char *inet_ntop(int af, const void *src, char *dst, socklen t size);</p>
<ul>
<li><p>函数说明</p>
<ul>
<li>网络 IP 转换为字符串形式的点分十进制的IP</li>
</ul>
</li>
<li><p>参数说明</p>
<ul>
<li>af：AF_INET（IPV4），AF_INET6（IPV6）</li>
<li>src：网络的整形的IP 地址</li>
<li>dst：转换后的IP 地址,一般为字符串数组</li>
<li>size：dst 的长度</li>
</ul>
</li>
<li><p>返回值</p>
<ul>
<li><p>成功：返回指向 dst 的指针</p>
</li>
<li><p>失败：返回 NULL，并设置 errno</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>例如：</p>
<p>IP 地址为 010aa8c0，转换为点分十进制的格式</p>
<p>01—-&gt;1	0a—-&gt;10	a8—-&gt;168	c0—-&gt;192</p>
<p>由于从网络中的 IP 地址是高端模式，所以转换为点分十进制后应该为：192.168.10.1</p>
<h2 id="SOCKET编程"><a href="#SOCKET编程" class="headerlink" title="SOCKET编程"></a>SOCKET编程</h2><p>​		传统的进程间通信借助内核提供的IPC机制进行，但是只能限于本机通信，若要跨机通信，就必须使用网络通信(本质上借助内核-内核提供了 socket 伪文件的机制实现通信—实际上是使用文件描述符)，这就需要用到内核提供给用户的 socket APl函数库.</p>
<p>​		既然提到 socket 伪文件，所以可以使用文件描述符相关的函数 read write可以对比 pipe 管道讲述 socket 文件描述符的区别,</p>
<p>​		使用socket 会建立一个socket pair.</p>
<p>​		如下图，一个文件描述符操作两个缓冲区，这点跟管道是不同的，管道是两个文件描述符操作一个内核缓冲区.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240915175536371.png" alt="image-20240915175536371"></p>
<h2 id="SOCKET中结构体"><a href="#SOCKET中结构体" class="headerlink" title="SOCKET中结构体"></a>SOCKET中结构体</h2><p><code>struct sockaddr</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr</span> &#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;</span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> &#123;</span><br><span class="line">    <span class="type">sa_family_t</span>    sin_family; <span class="comment">/* address family: AF_INET */</span></span><br><span class="line">    <span class="type">in_port_t</span>      sin_port;   <span class="comment">/* port in network byte order */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr;   <span class="comment">/* internet address */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Internet address. */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span>       s_addr;     <span class="comment">/* address in network byte order */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240916144302860.png" alt="image-20240916144302860"></p>
<p><strong>通过 <code>man 7 ip</code> 可以查看相关说明</strong></p>
<h2 id="SOCKET主要函数"><a href="#SOCKET主要函数" class="headerlink" title="SOCKET主要函数"></a>SOCKET主要函数</h2><h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><ul>
<li><p>函数原型</p>
<ul>
<li>int socket(int domain, int type, int protocol);</li>
</ul>
</li>
<li><p>函数描述</p>
<ul>
<li>创建socket</li>
</ul>
</li>
<li><p>参数说明</p>
<ul>
<li>domain：协议版本<ul>
<li>AF_INET IPV4</li>
<li>AF_INET6 IPV6</li>
<li>AF_UNIX   AF_LOCAL 本地套接字使用</li>
</ul>
</li>
<li>type：协议类型<ul>
<li>SOCK_STREAM 流式，默认使用的协议是TCP 协议</li>
<li>SOCK_DGRAM 报式，默认使用的是 UDP 协议</li>
</ul>
</li>
<li>protocal<ul>
<li>一般填 0，表示使用对应类型的默认协议</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值</p>
<ul>
<li>成功：返回一个大于0的文件描述符（<strong>用于监听</strong>）</li>
<li>失败：返回-1，并设置 errno</li>
</ul>
</li>
</ul>
<p>当调用 socket 函数以后，返回一个文件描述符，内核会提供与该文件描述符相对应的读和写缓冲区，&#x3D;&#x3D;<strong>同时还有两个队列，分别是请求连接队列和已连接队列</strong>&#x3D;&#x3D;</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240916145116355.png" alt="image-20240916145116355"></p>
<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><ul>
<li><p>函数原型</p>
<ul>
<li><p>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</p>
</li>
<li><p>函数描述：将socket 文件描述符和IP,PORT 绑定</p>
</li>
<li><p>参数说明:</p>
<ul>
<li>socket：调用socket函数返回的文件描述符</li>
<li>addr：本地服务器的IP地址和 PORT</li>
<li>struct sockaddr_in serv;</li>
<li>serv.sin family&#x3D;AF_INET;</li>
<li>serv.sin_port &#x3D;htons(8888);</li>
<li>&#x2F;&#x2F;serv.sin_addrs_addr&#x3D;htonI(INADDR_ANY);</li>
<li>&#x2F;&#x2F;INADDR_ANY：表示使用本机任意有效的可用 IP</li>
<li>inet_pton(AF_INET,”127.0.0.1”,&amp;sery.sin_addrs_addr);</li>
<li>addrlen：addr 变量的占用的内存大小</li>
</ul>
</li>
<li><p>返回值</p>
<ul>
<li><p>成功：返回 0</p>
</li>
<li><p>失败：返回-1，并设置 errno</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h3><ul>
<li>函数原型<ul>
<li>int listen(int sockfd, int backlog);</li>
</ul>
</li>
<li>函数描述：将套接字由主动态变为被动态</li>
<li>参数说明<ul>
<li>sockfd：调用 socket函数返回的文件描述符</li>
<li>backlog：同时请求连接的最大个数(还未建立连接)</li>
</ul>
</li>
<li>返回值<ul>
<li>成功：返回 0</li>
<li>失败：返回-1，并设置 errno</li>
</ul>
</li>
</ul>
<h3 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h3><ul>
<li><p>函数原型</p>
<ul>
<li>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</li>
</ul>
</li>
<li><p>函数说明：获得一个连接，若当前没有连接则会阻塞等待</p>
</li>
<li><p>函数参数：</p>
<ul>
<li>sockfd：调用 socket函数返回的文件描述符</li>
<li>addr：传出参数，保存客户端的地址信息</li>
<li>addrlen：<strong>传入传出参数</strong>，addr变量所占内存空间大小</li>
</ul>
</li>
<li><p>返回值</p>
<ul>
<li><p>成功：返回一个新的文件描述符（<strong>通信描述符</strong>），用于和客户端通信</p>
</li>
<li><p>失败：返回-1，并设置 errno 值.</p>
</li>
</ul>
</li>
</ul>
<p>accept函数是一个阻塞函数，若没有新的连接请求，则一直阻塞，从已连接队列中获取一个新的连接，并获得一个新的文件描述符，该文件描述符用于和客户端通信 (内核会负责将请求队列中的连接拿到已连接队列中)</p>
<h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><ul>
<li>函数原型<ul>
<li>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</li>
</ul>
</li>
<li>函数说明：连接服务器</li>
<li>函数参数<ul>
<li>sockfd：调用 socket 函数返回的文件描述符</li>
<li>addr：服务端的地址信息</li>
<li>addrlen： addr 变量的内存大小</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功：返回 0</li>
<li>失败：返回-1，并设置 errno 值</li>
</ul>
</li>
</ul>
<h3 id="读取数据和发送数据"><a href="#读取数据和发送数据" class="headerlink" title="读取数据和发送数据"></a>读取数据和发送数据</h3><ul>
<li>ssize_t read(int fd, void *buf, size_t count);</li>
<li>ssize_t write(int fd, const void *buf, size_t count);</li>
<li>ssize_t recv(int sockfd, void *buf, size_t len, int flags);</li>
<li>ssize_t send(int sockfd, const void *buf, size_t len, int flags)</li>
<li>对应 recv和send 这两个函数flags 直接填0就可以了</li>
</ul>
<p>​	&#x3D;&#x3D;注意：如果写缓冲区已满, write 也会阻塞，read 读操作的时候，若读缓冲区没有数据会引起阻塞&#x3D;&#x3D;</p>
<p>当read 读文件描述符为非阻塞状态的时候，若对方没有发送数据，会立刻返回，errno设置为EAGAIN，这个错误我们要忽略</p>
<h2 id="服务端开发流程"><a href="#服务端开发流程" class="headerlink" title="服务端开发流程"></a>服务端开发流程</h2><ol>
<li><p>创建socket，返回一个文件描述符lfd—socket()–该文件描述符用于监听客户端连接</p>
</li>
<li><p>将 lfd 和 IP PORT 进行绑定—-bind()</p>
</li>
<li><p>将 lfd 由主动变为被动监听—-listen()</p>
</li>
<li><p>接受一个新的连接，得到一个文件描述符cfd—-accept()—该文件描述符是用于和客户端进行通信的</p>
</li>
<li><p>while(1){</p>
<p>​		接收数据—read或者recv</p>
<p>​		发送数据—write或者send</p>
<p>}</p>
</li>
<li><p>关闭文件描述符—-close(lfd)	close(cfd)</p>
</li>
</ol>
<h2 id="客户端的开发流程"><a href="#客户端的开发流程" class="headerlink" title="客户端的开发流程"></a>客户端的开发流程</h2><ol>
<li><p>创建socket，返回一个文件描述符cfd—socket()—该文件描述符是用于和服务端通信</p>
</li>
<li><p>连接服务端—connect()</p>
</li>
<li><p>while(1){</p>
<p>​		&#x2F;&#x2F;发送数据—write或者send</p>
<p>​		&#x2F;&#x2F;接收数据—read或者recv</p>
<p>}</p>
</li>
<li><p>close(cfd)</p>
</li>
</ol>
<h2 id="高并发服务器"><a href="#高并发服务器" class="headerlink" title="高并发服务器"></a>高并发服务器</h2><p>如何支持多个客户端—支持多并发的服务器</p>
<p>由于 accept 和 read 函数都会阻塞，如当 read 的时候，不能调用 accept 接受新的连接，当 accept 阻塞等待的时候不能 read 读数据</p>
<ul>
<li>第一种方案：使用多进程，可以让父进程接受新连接，让子进程处理与客户端通信<ul>
<li>思路：让父进程 accept 接受新连接，然后fork子进程，让子进程处理通信，子进程处理完成后退出，父进程使用 SIGCHLD 信号回收子进程</li>
</ul>
</li>
</ul>
<p>代码实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    cfd = <span class="built_in">accept</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建子进程</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//关闭通信文件描述符</span></span><br><span class="line">        <span class="built_in">close</span>(cfd);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//关闭监听文件描述符</span></span><br><span class="line">        <span class="built_in">close</span>(lfd);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//收发数据</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            n = <span class="built_in">read</span>(cfd,buff,<span class="built_in">sizeof</span>(buff));</span><br><span class="line">            <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">write</span>(cfd,buff,n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(cfd);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//防止子进程继续创建进程</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注意点：accept或者read函数是阻塞函数，会被信号打断，此时不应该视为一个错误errno=EINTR */</span></span><br></pre></td></tr></table></figure>







<ul>
<li>第二种方案：使用多线程，让主线程接受新连接，让子线程处理与客户端通信；使用多线程要将线程设置为分离属性，让线程在退出之后自己回收资源</li>
</ul>
<p>多线程版本的服务器开发流程</p>
<ol>
<li><p>创建socket，得到一个监听的文件描述符 lfd—socket()</p>
</li>
<li><p>将 lfd，IP 和端口 port 进行绑定—–bind();</p>
</li>
<li><p>设置监听—-listen()</p>
</li>
<li><pre><code class="cpp">while(1)&#123;
    //接受新的客户端连接请求
    cfd = accept();
    //创建一个子线程
    pthread create(&amp;threadID, NULL,thread_work, &amp;cfd);
    //设置线程为分离属性
    pthread_detach(threadID);
&#125;
close(lfd);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">5. 子线程执行函数</span><br><span class="line"></span><br><span class="line">   ~~~cP</span><br><span class="line">   void *thread_work(void *arg)&#123;</span><br><span class="line">   	//获得参数:通信文件描述符</span><br><span class="line">   	int cfd =*(int*)arg;</span><br><span class="line">   	while(1)&#123;</span><br><span class="line">           //读数据</span><br><span class="line">           n=read(cfd, buff, sizeof(buff));</span><br><span class="line">           if(n&lt;=0)</span><br><span class="line">               break;</span><br><span class="line">   		write(cfd,buff,n);</span><br><span class="line">   	&#125;</span><br><span class="line">   	close(cfd);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<ul>
<li>通过数组开辟不同内存</li>
</ul>
<h2 id="TCP状态转换图"><a href="#TCP状态转换图" class="headerlink" title="TCP状态转换图"></a>TCP状态转换图</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img-blog.csdn.net/20160423144456154" alt="这里写图片描述"></p>
<ul>
<li><p>三次握手过程</p>
<ul>
<li>客户端：SYN_SENT—connect()</li>
<li>服务端：LISTEN–listen()SYN_RCVD当三次握手完成后，都处于ESTABLISHED状态数据传输过程中状态不发生变化，都是ESTABLISHED状态</li>
</ul>
</li>
<li><p>四次挥手过程</p>
<ul>
<li>主动关闭方：FIN_WAIT_T 	FIN_WAIT_2 	TIME_WAIT</li>
<li>被动关闭方：CLOSE_WAIT 	LAST_ACK</li>
</ul>
</li>
<li><p>TCP的11种状态及其含义</p>
<ul>
<li><strong>LISTEN</strong>：服务器端等待来自客户端的连接请求。</li>
<li><strong>SYN_SENT</strong>：客户端发送连接请求后等待服务器的确认。</li>
<li><strong>SYN_RECEIVED</strong>：服务器收到客户端的连接请求并发送确认，等待客户端的最终确认。</li>
<li><strong>ESTABLISHED</strong>：客户端和服务器的连接已经建立，可以开始数据传输。</li>
<li><strong>FIN_WAIT_1</strong>：发起连接终止请求，等待对方的确认。</li>
<li><strong>FIN_WAIT_2</strong>：在FIN_WAIT_1状态下，收到对方的确认后进入此状态，等待对方的连接终止请求。</li>
<li><strong>CLOSE_WAIT</strong>：对方发起连接终止请求，本地端等待关闭连接。</li>
<li><strong>CLOSING</strong>：双方同时尝试关闭连接，等待对方确认关闭请求。</li>
<li><strong>LAST_ACK</strong>：等待对方确认最后的关闭请求。</li>
<li><strong>TIME_WAIT</strong>：等待足够的时间以确保对方收到连接终止请求的确认。</li>
<li><strong>CLOSED</strong>：连接完全关闭，不再处于任何其他状态。</li>
</ul>
</li>
</ul>
<h3 id="为什么需要2MSL"><a href="#为什么需要2MSL" class="headerlink" title="为什么需要2MSL"></a>为什么需要2MSL</h3><ul>
<li>原因之一<ul>
<li>让四次挥手的过程更可靠,确保最后一个发送给对方的ACK到达;若对方没有收到ACK应答，对方会再次发送FIN请求关闭，此时在2MS时间内被动关闭方仍然可以发送ACK给对方.</li>
</ul>
</li>
<li>原因之二<ul>
<li>为了保证在 2MS 时间内，不能启动相同的SOCKET-PAIR。TIME_WAIT 一定是出现在主动关闭的一方,也就是说 2MS 是针对主动关闭一方来说的;由于TCP 有可能存在丢包重传，丢包重传若发给了已经断开连接之后相同的 socket-pair(该连接是新建的，与原来的 socket-pair 完全相同，双方使用的是相同的IP和端口)，这样会对之后的连接造成困扰,严重可能引起程序异常。</li>
<li>socket-pair 的概念<ul>
<li>客户端与服务端连接其实是一个连接对，可以通过使用netstat-anp|grep 端口号 进行查看.</li>
</ul>
</li>
</ul>
</li>
<li>如何避免问题2呢<ul>
<li>很多操作系统实现的时候，只要端口被占用，服务就不能启动</li>
</ul>
</li>
</ul>
<h2 id="端口复用"><a href="#端口复用" class="headerlink" title="端口复用"></a>端口复用</h2><p>解决端口复用的问题：<code>bind error: Address alreadyin use</code> 发生这种情况是在服务端主动关闭连接以后，接着立刻启动就会报这种错误</p>
<p>setsockopt 函数</p>
<p>int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);</p>
<ul>
<li><p>setsockopt(lfd, SOL_SOCKET, <strong>SO_REUSEADDR</strong>, &amp;opt, sizeof(int));</p>
</li>
<li><p>setsockopt(Ifd, SOL_SOCKET, <strong>SO_REUSEPORT</strong>, &amp;opt, sizeof(int));</p>
</li>
</ul>
<p>参数level标识了选项应用的协议。如果选项是通用的套接字层选项，level设置成SOL_SOCKET。否则，level设置成控制这个选项的协议号。例如，对于TCP选项，这是IPPROTO_TCP，对于IP选项，这是IPPROTO_IP。</p>
<p>参数val根据选项的不同指向一个数据结构或者一个整数。一些选项是on&#x2F;off开关。如果整数非零，那么选项被启用。如果整数为零，那么该选项被禁止。参数len指定了val指向的对象的大小。</p>
<p>可以使用getsockopt函数来发现选项的当前值</p>
<p>套接字选项</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240921095536283.png" alt="image-20240921095536283"></p>
<p>例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> reuse=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>((fd=<span class="built_in">socket</span>(addr-&gt;sa family,type,<span class="number">0</span>))&lt;<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>(-l);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">setsockopt</span>(fd,SOL SOCKET,SO REUSEADDR，&amp;<span class="built_in">reusesizeof</span>(<span class="type">int</span>))&lt;<span class="number">0</span>)&#123;</span><br><span class="line">	err =errno;</span><br><span class="line"><span class="built_in">bind</span>();</span><br></pre></td></tr></table></figure>



<h2 id="半关闭状态"><a href="#半关闭状态" class="headerlink" title="半关闭状态"></a>半关闭状态</h2><h3 id="半关闭的概念"><a href="#半关闭的概念" class="headerlink" title="半关闭的概念"></a>半关闭的概念</h3><ul>
<li>如果一方 close,另一方没有 close,则认为是半关闭状态，处于半关闭状态的时候，可以接收数据，但是不能发送数据，相当于把文件描述符的写缓冲区操作关闭了.</li>
<li>注意：半关闭一定是出现在主动关闭的一方</li>
</ul>
<h3 id="shutdown-函数"><a href="#shutdown-函数" class="headerlink" title="shutdown 函数"></a>shutdown 函数</h3><ul>
<li><p>长连接和端连接的概念</p>
<ul>
<li>连接建立之后一直不关闭为长连接;</li>
<li>连接收发数据完毕之后就关闭为短连接;</li>
</ul>
</li>
<li><p>shutdown和close的区别</p>
<ul>
<li>shutdown可以实现半关闭</li>
<li>close不行shutdown关闭的时候，不考虑文件描述符的引用计数，是直接彻底关闭close考虑文件描述符的引用计数，调用一次close只是将引用计数减1，只有减小到0的时候才会真正关闭</li>
</ul>
</li>
</ul>
<h2 id="心跳包"><a href="#心跳包" class="headerlink" title="心跳包"></a>心跳包</h2><p>主要用于检测与对方的网络连接是否正常</p>
<p>主要用于长连接</p>
<ul>
<li>方法 1<ul>
<li>keepAlive &#x3D; 1;</li>
<li>setsockopt(listenfd,SOL SOCKET,SO_KEEPALIVE,(void*)&amp;keepAlive,sizeof(keepAlive));</li>
<li>由于不能实时的检测网络情况，一般不用这种方法</li>
</ul>
</li>
<li>方法 2<ul>
<li>在应用程序中自己定义心跳包，使用灵活，能实时把控</li>
</ul>
</li>
</ul>
<h3 id="发送心跳过程"><a href="#发送心跳过程" class="headerlink" title="发送心跳过程"></a>发送心跳过程</h3><ul>
<li>服务A给B发送心跳数据AAAA,服务B收到AAAA之后,给A回复BBBB,此时A收到BBBB之后,认为连接正常;</li>
<li>假如A连续发送了多次(如3-5次)之后,仍然没有收到B的回复,则认为连接异常；异常之后,A应该重建连接;<br>先close原来的连接,然后在重新connect连接就可以了.</li>
</ul>
<h3 id="如何让心跳数据和正常的业务数据不混淆"><a href="#如何让心跳数据和正常的业务数据不混淆" class="headerlink" title="如何让心跳数据和正常的业务数据不混淆?"></a>如何让心跳数据和正常的业务数据不混淆?</h3><p>解决办法:</p>
<p>双方可以<strong>协商协议</strong>,如: 4个字节长度+具体数据如果发送心跳数据应该: 0004AAAA</p>
<p>如果发送业务数据: 00101234567890</p>
<p>对方收数据的时候先收4个字节的报头数据,然后计算长度,若最后计算长度为4,且数据为AAAA,则认为是心跳数据，则B服务会组织应答数据给A: 0004BBBB</p>
<h2 id="高并发服务器模型–select"><a href="#高并发服务器模型–select" class="headerlink" title="高并发服务器模型–select"></a>高并发服务器模型–select</h2><p>多路 IO 技术：select 同时监听多个文件描述符,将监控的操作交给内核去处理</p>
<p>数据类型 fd_set：文件描述符集合–本质是位图(关于集合可联想一个信号集sigset_t)</p>
<p>int select(int nfds,fd_set * readfds, fd_set *writefds, fd_set *exceptfds, structtimeval *timeout);</p>
<ul>
<li><p>函数介绍</p>
<ul>
<li>委托内核监控该文件描述符对应的读，写或者错误事件的发生</li>
</ul>
</li>
<li><p>参数说明</p>
<ul>
<li><p>nfds：最大的文件描述符+1</p>
</li>
<li><p>readfds：读集合，是一个传入传出参数</p>
<ul>
<li>传入：指的是告诉内核哪些文件描述符需要监控</li>
<li>输出参数：内核告诉应用程序哪些文件描述符有变化</li>
</ul>
</li>
<li><p>writefds</p>
<ul>
<li>输入参数：告诉内核要监控哪些文件描述符</li>
<li>输出参数：内核告诉应用程序哪些文件描述符有变化</li>
</ul>
</li>
<li><p>Exceptfds</p>
<ul>
<li>输入输出参数,一般表示异常事件</li>
</ul>
</li>
<li><p>Timeout</p>
<ul>
<li><p>超时时间</p>
</li>
<li><p>NULL：表示永久阻塞,直到有事件发生</p>
</li>
<li><p>0：表示不阻塞,不管有没有事件发生,都会立刻返回</p>
</li>
<li><p><code>&gt;0</code>：表示阻塞的时长,若没有超过时长,则一直阻塞若在时长内,有事件发生,则立刻返回若超过时长,则立刻返回</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值</p>
<ul>
<li>成功返回发生变化的文件描述符个数.</li>
</ul>
</li>
</ul>
<h3 id="配套函数"><a href="#配套函数" class="headerlink" title="配套函数"></a>配套函数</h3><p>fd_set set;</p>
<ul>
<li>void FD_CLR(int fd, fd _set *set);<ul>
<li>说明:从set集合中清除fd</li>
</ul>
</li>
<li>int FD_ISSET(int fd, fd_set *set);<ul>
<li>说明: 判断fd是否在set集合中</li>
</ul>
</li>
<li>void FD_SET(int fd, fd_set *set);<ul>
<li>说明: 将fd添加到set集合中</li>
</ul>
</li>
<li>void FD_ZERO(fd_set *set);<ul>
<li>说明: 清空文件描述符集</li>
</ul>
</li>
</ul>
<p>问题：如果有效的文件描述符比较少，会使循环的次数太多</p>
<p>解决办法：可以将有效的文件描述符放到一个数组当中，这样遍历效率就高</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>一个进程可以支持多个客户端</li>
<li>select 支持跨平台</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li><p>代码编写困难</p>
</li>
<li><p>会涉及到用户区到内核区的来回拷贝</p>
</li>
<li><p>当客户端多个连接，但少数活跃的情况,select 效率较低</p>
<ul>
<li>例如：作为极端的一种情况，3-1023 文件描述符全部打开，但是只有1023有发送数据,select就显得效率低下</li>
</ul>
</li>
<li><p>最大支持 1024 个客户端连接</p>
<ul>
<li><p>select 最大支持 1024 个客户端连接不是有文件描述符表最多可以支持1024 个文件描述符限制的，而是由FD SETSIZE&#x3D;1024 限制的.</p>
</li>
<li><p>FD_SETSIZE&#x3D;1024， fd_set使用了该宏，当然可以修改内核，然后再重新编译内核，一般不建议这么做.</p>
</li>
</ul>
</li>
</ul>
<p>注意：select 不仅可以监控 socket 文件描述符，也可以监视标准输入.</p>
<h2 id="多路-IO"><a href="#多路-IO" class="headerlink" title="多路 IO"></a>多路 IO</h2><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><ul>
<li><p>函数原型</p>
<ul>
<li>int poll(struct pollfd *fds, nfds_t nfds, int timeout);</li>
</ul>
</li>
<li><p>函数说明</p>
<ul>
<li>跟select 类似，监控多路 IO，但 poll 不能跨平台</li>
</ul>
</li>
<li><p>参数说明</p>
<ul>
<li><p>fds：传入传出参数，实际上是一个结构体数组</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">pollfd</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd; 		<span class="comment">/* file descriptor */</span></span><br><span class="line">	<span class="type">short</span>  events;	<span class="comment">/* requested events (输入参数，表示告诉内核要监控的事件，读写事件，异常事件)*/</span></span><br><span class="line">	<span class="type">short</span> revents;	<span class="comment">/* returned events (输出参数，表示内核告诉应用程序有哪些文件描述符有事情发生)*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>fds.fd：要监控的文件描述符</p>
</li>
<li><p>fds.events：</p>
<ul>
<li>POLLIN—-&gt;读事件</li>
<li>POLLOUT—-&gt;写事件</li>
</ul>
</li>
</ul>
</li>
<li><p>fds.revents：返回的事件</p>
</li>
<li><p>nfds：数组实际有效内容的个数（告诉内核监控的范围，具体是数组下标的最大值+1）</p>
</li>
<li><p>timeout：超时时间，单位是毫秒</p>
<ul>
<li><p>-1：永久阻塞，直到监控的事件发生</p>
</li>
<li><p>0：不管是否有事件发生，立刻返回</p>
</li>
<li><p><code>&gt;0</code>：表示阻塞时长，在时长范围内若有事件发生会立刻返回;如果超过了时长也会立刻返回</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>函数返回值</p>
<ul>
<li><p><code>&gt;0</code>：发生变化的文件描述符的个数</p>
</li>
<li><p>&#x3D;0:没有文件描述符发生变化</p>
</li>
<li><p>-1：表示异常</p>
</li>
</ul>
</li>
<li><p>说明<br>当poll函数返回的时候,结构体当中的fd和events 没有发生变化，究竟有没有事件发生由revents 来判断，所以 poll 是请求和返回分离</p>
</li>
<li><p>struct pollfd 结构体中的 fd 成员若赋值为-1，则 poll 不会监控</p>
</li>
<li><p>相对于 select, poll 没有本质上的改变;但是 poll 可以突破 1024 的限制在&#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max 查看一个进程可以打开的 socket 描述符上限.如果需要可以修改配置文件：&#x2F;etc&#x2F;security&#x2F;limits.conf<br>加入如下配置信息，然后重启终端即可生效</p>
<ul>
<li><p>soft nofile 1024</p>
</li>
<li><p>hard nofile 100000</p>
</li>
</ul>
<ul>
<li>soft 和 hard 分别表示 ulimit,命令可以修改的最小限制和最大限制</li>
</ul>
</li>
</ul>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>​		将检测文件描述符的变化委托给内核去处理，然后内核将发生变化的文件描述符对应的事件返回给应用程序</p>
<p><code>#include &lt;sys/epoll.h&gt;</code></p>
<h4 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h4><ul>
<li>函数原型<ul>
<li>int epoll_create(int size);</li>
</ul>
</li>
<li>函数说明<ul>
<li>创建一个树根</li>
</ul>
</li>
<li>参数说明</li>
<li>size：最大节点数，此参数在 linux2.6.8已被忽略，但必须传递一个大于0的数</li>
<li>返回值<ul>
<li>成功：返回一个大于0的文件描述符，代表整个树的树根</li>
<li>失败：返回-1，并设置 errno值</li>
</ul>
</li>
</ul>
<h4 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h4><ul>
<li><p>函数原型</p>
<ul>
<li>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</li>
</ul>
</li>
<li><p>函数说明</p>
<ul>
<li>将要监听的节点在epoll树上添加，删除和修改</li>
</ul>
</li>
<li><p>参数说明</p>
<ul>
<li><p>epfd：epoll 树根</p>
</li>
<li><p>op：</p>
<ul>
<li>EPOLL_CTL_ADD：添加事件节点到树上</li>
<li>EPOLL_CTL_DEL：从树上删除事件节点</li>
<li>EPOLL_CTL_MOD：修改树上对应的事件节点</li>
</ul>
</li>
<li><p>fd：事件节点对应的文件描述符</p>
</li>
<li><p>event：要操作的事件节点</p>
<p>EPOLLIN：可读事件</p>
<p>EPOLLOUT：可写事件</p>
<p>EPOLLERR：异常事件</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epoll_data</span> &#123;</span><br><span class="line">    <span class="type">void</span>        *ptr;</span><br><span class="line">    <span class="type">int</span>          fd;</span><br><span class="line">    <span class="type">uint32_t</span>     u32;</span><br><span class="line">    <span class="type">uint64_t</span>     u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h4><ul>
<li><p>函数原型</p>
<ul>
<li>int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout);</li>
</ul>
</li>
<li><p>函数说明</p>
<ul>
<li>委托内核监控epoll树的事件节点</li>
</ul>
</li>
<li><p>参数说明</p>
<ul>
<li><p>epfd：epoll树根节点</p>
</li>
<li><p>events：传出参数,结构体数组</p>
</li>
<li><p>maxevents：events数组大小</p>
</li>
<li><p>timeout</p>
<ul>
<li><p>-1：表示阻塞</p>
</li>
<li><p>0：表示不阻塞</p>
</li>
<li><p><code>&gt;0</code>：表示阻塞超时时长</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="进阶epoll"><a href="#进阶epoll" class="headerlink" title="进阶epoll"></a>进阶epoll</h3><p>介绍epoll 的两种工作模式</p>
<p>epoll的两种模式 LT 和 ET 模式</p>
<ul>
<li>水平触发(Level Triggered)：高电平代表1<ul>
<li>只要缓冲区中有数据，就一直通知</li>
<li>epoll 默认情况下是LT模式，在这种模式下，若读数据一次性没有读完，缓冲区中还有可读数据，则epollwait还会再次通知</li>
</ul>
</li>
<li>边缘触发（Edge Triggered）：电平有变化就代表1<ul>
<li>缓冲区中有数据只会通知一次，之后再有数据才会通知（若是读数据的时候没有读完，则剩余的数据不会再通知，直到有断的数据到来）</li>
<li>若将epoll设置为ET模式，若读数据的时候一次性没有读完，则epoll_wait不再通知，直到下次有新的数据发来</li>
</ul>
</li>
</ul>
<p>边缘非阻寒模式：提高效率</p>
<ul>
<li>在ET模式下，如何在epoll_wait返回一次的情况下读完数据<ul>
<li>循环读数据，直到读完数据，但是读完数据之后会阻塞</li>
</ul>
</li>
<li>若能够一次性读完还需要设置什么<ul>
<li>将通信文件描述符设置为非阻塞模式</li>
</ul>
</li>
</ul>
<h3 id="epoll反应堆"><a href="#epoll反应堆" class="headerlink" title="epoll反应堆"></a>epoll反应堆</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240922160136504.png" alt="image-20240922160136504"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240922161500430.png" alt="image-20240922161500430"></p>
<p>或</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240922162603627.png" alt="image-20240922162603627"></p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ul>
<li><p>什么是线程池</p>
<ul>
<li>是一个抽象的概念，若干个线程组合到一起，形成线程池</li>
</ul>
</li>
<li><p>为什么需要线程池</p>
<ul>
<li>多线程版服务器一个客户端就需要创建一个线程！若客户端太多，显然不太合适</li>
</ul>
</li>
<li><p>什么时候需要创建线程池</p>
<ul>
<li>简单的说，如果一个应用需要频繁的创建和销毁线程，而任务执行的时间又非常短，这样线程创建和销毁的带来的开销就不容忽视，这时也是线程池该出场的机会了。如果线程创建和销毁时间相比任务执行时间可以忽略不计，则没有必要使用线程池了。</li>
<li>实现的时候类似于生产者和消费者</li>
</ul>
</li>
<li><p>线程池和任务池</p>
<ul>
<li>任务池相当于共享资源，所以需要使用互斥锁，当任务池中没有任务的时候需要让线程阻塞，所以需要使用条件变量</li>
</ul>
</li>
<li><p>如何让线程执行不同的任务</p>
<ul>
<li>使用回到函数，在任务中设置任务执行函数，这样可以起到不同的任务执行不同的函数.</li>
</ul>
</li>
</ul>
<p>子线程负责从任务池冲获取任务，每一个任务有一个回调函数，每于个回调函数执行不同操作</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\Kayer\AppData\Roaming\Typora\typora-user-images\image-20240922164137612.png" alt="image-20240922164137612"></p>
<p>p55 0:44:56</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2021/01/15/45dcf1dc05d9b.png" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2021/01/15/45dcf1dc05d9b.png" title="头像" alt="头像"></a><div class="post-copyright__author_name">Kayer</div><div class="post-copyright__author_desc">Just do it.</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2024/09/22/Linux/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2024/09/22/Linux/')">Linux</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2024/09/22/Linux/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=Linux&amp;url=http://example.com/2024/09/22/Linux/&amp;pic=/img/404.jpg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">KAYER</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/CPP/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>CPP<span class="tagsPageCount">2</span></a><a class="post-meta__box__tags" href="/tags/Linux/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>Linux<span class="tagsPageCount">2</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="/img/404.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/10/19/hello-world/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/404.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Hello World</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2024/10/19/hello-world/" title="Hello World"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/404.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-10-19</div><div class="title">Hello World</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div></div><div class="comment-wrap"><div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2021/01/15/45dcf1dc05d9b.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description"></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">Kayer</h1><div class="author-info__desc">Just do it.</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/anzhiyu-c" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来看我的博客鸭~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">Linux系统基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Shell"><span class="toc-number">1.1.</span> <span class="toc-text">Shell</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.</span> <span class="toc-text">Linux基础命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%89%E6%A0%87%E4%BD%8D%E7%BD%AE%E7%A7%BB%E5%8A%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">光标位置移动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%88%A0%E9%99%A4"><span class="toc-number">1.2.2.</span> <span class="toc-text">字符删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9B%AE%E5%BD%95"><span class="toc-number">1.2.3.</span> <span class="toc-text">常见目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.4.</span> <span class="toc-text">文件和目录操作相关命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tree%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">tree命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ls%EF%BC%88list%EF%BC%89%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">ls（list）命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cd%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">cd命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwd%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.4.4.</span> <span class="toc-text">pwd命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#which%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.4.5.</span> <span class="toc-text">which命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#touch%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.4.6.</span> <span class="toc-text">touch命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mkdir%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.4.7.</span> <span class="toc-text">mkdir命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rmdir%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.4.8.</span> <span class="toc-text">rmdir命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rm%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.4.9.</span> <span class="toc-text">rm命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cp%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.4.10.</span> <span class="toc-text">cp命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mv%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.4.11.</span> <span class="toc-text">mv命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cat%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.4.12.</span> <span class="toc-text">cat命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#more%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.4.13.</span> <span class="toc-text">more命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#less%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.4.14.</span> <span class="toc-text">less命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#head%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.4.15.</span> <span class="toc-text">head命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tail%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.4.16.</span> <span class="toc-text">tail命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E9%93%BE%E6%8E%A5"><span class="toc-number">1.2.4.17.</span> <span class="toc-text">软链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E9%93%BE%E6%8E%A5"><span class="toc-number">1.2.4.18.</span> <span class="toc-text">硬链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#wc%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.4.19.</span> <span class="toc-text">wc命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#whoami"><span class="toc-number">1.2.4.20.</span> <span class="toc-text">whoami</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%EF%BC%8C%E7%94%A8%E6%88%B7%EF%BC%8C%E7%94%A8%E6%88%B7%E7%BB%84"><span class="toc-number">1.2.5.</span> <span class="toc-text">用户权限，用户，用户组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90chmod"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">修改文件权限chmod</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E6%89%80%E6%9C%89%E8%80%85%E5%92%8C%E6%89%80%E5%B1%9E%E7%BB%84chown"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">修改文件所有者和所属组chown</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#find%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.6.</span> <span class="toc-text">find命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#grep%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.7.</span> <span class="toc-text">grep命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#find%E5%92%8Cgrep%E5%91%BD%E4%BB%A4%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8"><span class="toc-number">1.2.8.</span> <span class="toc-text">find和grep命令结合使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD"><span class="toc-number">1.2.9.</span> <span class="toc-text">软件安装与卸载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CentOS"><span class="toc-number">1.2.9.1.</span> <span class="toc-text">CentOS</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E7%BA%BF%E5%AE%89%E8%A3%85"><span class="toc-number">1.2.9.1.1.</span> <span class="toc-text">在线安装</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8RPM%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">1.2.9.1.2.</span> <span class="toc-text">使用RPM包管理器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%AE%89%E8%A3%85"><span class="toc-number">1.2.9.1.3.</span> <span class="toc-text">使用压缩包安装</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B8%85%E7%90%86%E5%AE%89%E8%A3%85%E5%8C%85"><span class="toc-number">1.2.9.1.4.</span> <span class="toc-text">清理安装包</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Ubuntu"><span class="toc-number">1.2.9.2.</span> <span class="toc-text">Ubuntu</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E7%BA%BF%E5%AE%89%E8%A3%85-1"><span class="toc-number">1.2.9.2.1.</span> <span class="toc-text">在线安装</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%8C%85%E5%AE%89%E8%A3%85"><span class="toc-number">1.2.9.2.2.</span> <span class="toc-text">软件包安装</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%B7%A5%E5%85%B7"><span class="toc-number">1.2.10.</span> <span class="toc-text">常用的压缩工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gzip%E5%92%8Cbzip2"><span class="toc-number">1.2.10.1.</span> <span class="toc-text">gzip和bzip2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tar%E5%B7%A5%E5%85%B7"><span class="toc-number">1.2.10.2.</span> <span class="toc-text">tar工具</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rar%E5%B7%A5%E5%85%B7"><span class="toc-number">1.2.10.3.</span> <span class="toc-text">rar工具</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#zip%E5%B7%A5%E5%85%B7"><span class="toc-number">1.2.10.4.</span> <span class="toc-text">zip工具</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vi-%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.</span> <span class="toc-text">vi 使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">命令模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%89%E6%A0%87%E7%A7%BB%E5%8A%A8"><span class="toc-number">1.3.0.1.1.</span> <span class="toc-text">光标移动</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.0.1.2.</span> <span class="toc-text">删除命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%92%A4%E9%94%80%E5%92%8C%E5%8F%8D%E6%92%A4%E9%94%80"><span class="toc-number">1.3.0.1.3.</span> <span class="toc-text">撤销和反撤销</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4"><span class="toc-number">1.3.0.1.4.</span> <span class="toc-text">复制粘贴</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E8%A7%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.0.1.5.</span> <span class="toc-text">可视模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2"><span class="toc-number">1.3.0.1.6.</span> <span class="toc-text">替换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-number">1.3.0.1.7.</span> <span class="toc-text">查找</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%87%E6%8D%A2%E5%88%B0%E6%96%87%E6%9C%AC%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.0.1.8.</span> <span class="toc-text">切换到文本输入模式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AB%E8%A1%8C%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.0.2.</span> <span class="toc-text">末行模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%9D%E5%AD%98%E9%80%80%E5%87%BA"><span class="toc-number">1.3.0.2.1.</span> <span class="toc-text">保存退出</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2-1"><span class="toc-number">1.3.0.2.2.</span> <span class="toc-text">替换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E7%BF%BB%E5%B1%9B"><span class="toc-number">1.3.0.2.3.</span> <span class="toc-text">快速翻屛</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E6%9C%AB%E8%A1%8C%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.0.3.</span> <span class="toc-text">在末行模式下执行命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B1%8F%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.0.4.</span> <span class="toc-text">分屏操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vim%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">1.3.0.5.</span> <span class="toc-text">vim的配置文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gcc%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-number">1.4.</span> <span class="toc-text">gcc编译器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.4.1.</span> <span class="toc-text">工作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gcc%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0"><span class="toc-number">1.4.2.</span> <span class="toc-text">gcc常用参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%85%B1%E4%BA%AB%EF%BC%88%E5%8A%A8%E6%80%81%EF%BC%89%E5%BA%93"><span class="toc-number">1.4.3.</span> <span class="toc-text">静态库和共享（动态）库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%93%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">库的介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">库的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%BA%93"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">静态库</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C"><span class="toc-number">1.4.3.3.1.</span> <span class="toc-text">静态库的制作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.4.3.3.2.</span> <span class="toc-text">静态库的使用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93"><span class="toc-number">1.4.3.4.</span> <span class="toc-text">动态库</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C"><span class="toc-number">1.4.3.4.1.</span> <span class="toc-text">动态库的制作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.4.3.4.2.</span> <span class="toc-text">动态库的使用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E5%BA%93%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.4.3.5.</span> <span class="toc-text">两种库的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%BA%93-1"><span class="toc-number">1.4.3.5.1.</span> <span class="toc-text">静态库</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93-1"><span class="toc-number">1.4.3.5.2.</span> <span class="toc-text">动态库</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#makefile%E7%BC%96%E5%86%99%E5%92%8Cgdb%E8%B0%83%E8%AF%95"><span class="toc-number">1.5.</span> <span class="toc-text">makefile编写和gdb调试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#makefile"><span class="toc-number">1.5.1.</span> <span class="toc-text">makefile</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">基本规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#makefile%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">makefile工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#makefile%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">makefile中的变量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%8F%98%E9%87%8F"><span class="toc-number">1.5.1.3.1.</span> <span class="toc-text">普通变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%8F%98%E9%87%8F"><span class="toc-number">1.5.1.3.2.</span> <span class="toc-text">自动变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E8%A7%84%E5%88%99"><span class="toc-number">1.5.1.3.3.</span> <span class="toc-text">模式规则</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#makefile%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.1.4.</span> <span class="toc-text">makefile函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#makefile%E7%9A%84%E6%B8%85%E7%90%86%E6%93%8D%E4%BD%9C"><span class="toc-number">1.5.1.5.</span> <span class="toc-text">makefile的清理操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gdb%E8%B0%83%E8%AF%95"><span class="toc-number">1.5.2.</span> <span class="toc-text">gdb调试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E8%B0%83%E8%AF%95%E4%BF%A1%E6%81%AF"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">生成调试信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8gdb"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">启动gdb</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">显示源代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%AD%E7%82%B9%E6%93%8D%E4%BD%9C"><span class="toc-number">1.5.2.4.</span> <span class="toc-text">断点操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E4%BB%A3%E7%A0%81"><span class="toc-number">1.5.2.5.</span> <span class="toc-text">调试代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC"><span class="toc-number">1.5.2.6.</span> <span class="toc-text">查看变量的值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E4%BF%AE%E6%94%B9%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC"><span class="toc-number">1.5.2.7.</span> <span class="toc-text">查看修改变量的值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6IO%E6%93%8D%E4%BD%9C"><span class="toc-number">1.6.</span> <span class="toc-text">文件IO操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C%E5%BA%93IO%E5%87%BD%E6%95%B0%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.6.1.</span> <span class="toc-text">C库IO函数的工作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.2.</span> <span class="toc-text">C语言操作文件相关问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%93%E5%87%BD%E6%95%B0%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.6.3.</span> <span class="toc-text">库函数与系统函数的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PCB%E5%92%8C%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8"><span class="toc-number">1.6.4.</span> <span class="toc-text">PCB和文件描述符表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#open-close"><span class="toc-number">1.6.5.</span> <span class="toc-text">open&#x2F;close</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">1.6.5.1.</span> <span class="toc-text">文件描述符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#open%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.5.2.</span> <span class="toc-text">open函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#close%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.5.3.</span> <span class="toc-text">close函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#read-write"><span class="toc-number">1.6.6.</span> <span class="toc-text">read&#x2F;write</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#read%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.6.1.</span> <span class="toc-text">read函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#write%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.6.2.</span> <span class="toc-text">write函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lseek"><span class="toc-number">1.6.7.</span> <span class="toc-text">lseek</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#perror-errno"><span class="toc-number">1.6.8.</span> <span class="toc-text">perror&#x2F;errno</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-number">1.6.9.</span> <span class="toc-text">阻塞和非阻塞</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95"><span class="toc-number">1.7.</span> <span class="toc-text">文件和目录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.1.</span> <span class="toc-text">文件操作相关函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#stat-lstat%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">stat&#x2F;lstat函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#access%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">access函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">目录操作相关函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#opendir%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.1.3.1.</span> <span class="toc-text">opendir函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#readdir%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.1.3.2.</span> <span class="toc-text">readdir函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#closedir%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.1.3.3.</span> <span class="toc-text">closedir函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E7%9B%AE%E5%BD%95%E5%86%85%E5%AE%B9%E7%9A%84%E4%B8%80%E8%88%AC%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.7.1.3.4.</span> <span class="toc-text">读取目录内容的一般步骤</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dup-dup2-fcntl"><span class="toc-number">1.7.2.</span> <span class="toc-text">dup&#x2F;dup2&#x2F;fcntl</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dup"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">dup</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dup2"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">dup2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fcntl"><span class="toc-number">1.7.2.3.</span> <span class="toc-text">fcntl</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3"><span class="toc-number">1.8.</span> <span class="toc-text">进程相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">1.8.1.</span> <span class="toc-text">进程相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%92%8C%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">程序和进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">并行和并发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PCB-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-number">1.8.1.3.</span> <span class="toc-text">PCB-进程控制块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.8.2.</span> <span class="toc-text">创建进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fork%E5%87%BD%E6%95%B0"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">fork函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ps-kill"><span class="toc-number">1.8.2.2.</span> <span class="toc-text">ps&#x2F;kill</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getpid-getppid"><span class="toc-number">1.8.2.3.</span> <span class="toc-text">getpid&#x2F;getppid</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exec%E5%87%BD%E6%95%B0%E6%97%8F"><span class="toc-number">1.8.3.</span> <span class="toc-text">exec函数族</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%92%8C%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">函数作用和函数介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#execl%E5%87%BD%E6%95%B0"><span class="toc-number">1.8.3.2.</span> <span class="toc-text">execl函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#execlp%E5%87%BD%E6%95%B0"><span class="toc-number">1.8.3.3.</span> <span class="toc-text">execlp函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%9B%9E%E6%94%B6"><span class="toc-number">1.8.4.</span> <span class="toc-text">进程回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90%E5%9B%9E%E6%94%B6"><span class="toc-number">1.8.4.1.</span> <span class="toc-text">为什么要进行进程资源回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.8.4.2.</span> <span class="toc-text">孤儿进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.8.4.3.</span> <span class="toc-text">僵尸进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%9B%9E%E6%94%B6%E5%87%BD%E6%95%B0"><span class="toc-number">1.8.4.4.</span> <span class="toc-text">进程回收函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#wait-%E5%87%BD%E6%95%B0"><span class="toc-number">1.8.4.4.1.</span> <span class="toc-text">wait 函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#waitpid%E5%87%BD%E6%95%B0"><span class="toc-number">1.8.4.4.2.</span> <span class="toc-text">waitpid函数</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">1.9.</span> <span class="toc-text">进程间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">1.9.1.</span> <span class="toc-text">进程间通信相关概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.9.2.</span> <span class="toc-text">进程间通信的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93pipe"><span class="toc-number">1.9.3.</span> <span class="toc-text">管道pipe</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.9.3.1.</span> <span class="toc-text">管道的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.9.3.2.</span> <span class="toc-text">管道的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">1.9.3.3.</span> <span class="toc-text">管道的局限性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%AE%A1%E9%81%93pipe%E5%87%BD%E6%95%B0"><span class="toc-number">1.9.3.4.</span> <span class="toc-text">创建管道pipe函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1"><span class="toc-number">1.9.3.5.</span> <span class="toc-text">父子进程使用管道通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E7%9A%84%E8%AF%BB%E5%86%99%E8%A1%8C%E4%B8%BA"><span class="toc-number">1.9.3.6.</span> <span class="toc-text">管道的读写行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E7%AE%A1%E9%81%93%E4%B8%BA%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-number">1.9.3.7.</span> <span class="toc-text">如何设置管道为非阻塞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%AE%A1%E9%81%93%E7%BC%93%E5%86%B2%E5%8C%BA%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.9.3.8.</span> <span class="toc-text">查看管道缓冲区大小</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FIFO"><span class="toc-number">1.9.4.</span> <span class="toc-text">FIFO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.9.4.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%AE%A1%E9%81%93"><span class="toc-number">1.9.4.2.</span> <span class="toc-text">创建管道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8FIFO%E5%AE%8C%E6%88%90%E4%B8%A4%E4%B8%AA%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">1.9.4.3.</span> <span class="toc-text">使用FIFO完成两个进程通信</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%8C%BA"><span class="toc-number">1.9.5.</span> <span class="toc-text">内存映射区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">1.9.5.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mmap%E5%87%BD%E6%95%B0"><span class="toc-number">1.9.5.2.</span> <span class="toc-text">mmap函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#munmap%E5%87%BD%E6%95%B0"><span class="toc-number">1.9.5.3.</span> <span class="toc-text">munmap函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mmap%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.9.5.4.</span> <span class="toc-text">mmap注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mmap%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93"><span class="toc-number">1.9.5.5.</span> <span class="toc-text">mmap函数的使用总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-mmap%E5%87%BD%E6%95%B0%E5%BB%BA%E7%AB%8B%E5%8C%BF%E5%90%8D%E6%98%A0%E5%B0%84"><span class="toc-number">1.9.5.6.</span> <span class="toc-text">使用 mmap函数建立匿名映射</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E7%9B%B8%E5%85%B3"><span class="toc-number">1.10.</span> <span class="toc-text">信号相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-2"><span class="toc-number">1.10.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%BA%E5%88%B6"><span class="toc-number">1.10.2.</span> <span class="toc-text">机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">1.10.2.1.</span> <span class="toc-text">信号的状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.10.2.2.</span> <span class="toc-text">信号的处理方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%89%B9%E8%B4%A8"><span class="toc-number">1.10.2.3.</span> <span class="toc-text">信号的特质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E4%BF%A1%E5%8F%B7%E9%9B%86%E5%92%8C%E6%9C%AA%E5%86%B3%E4%BF%A1%E5%8F%B7%E9%9B%86"><span class="toc-number">1.10.2.4.</span> <span class="toc-text">阻塞信号集和未决信号集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%9B%9B%E8%A6%81%E7%B4%A0"><span class="toc-number">1.10.2.5.</span> <span class="toc-text">信号的四要素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">1.10.3.</span> <span class="toc-text">信号相关函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#signal-%E5%87%BD%E6%95%B0"><span class="toc-number">1.10.3.1.</span> <span class="toc-text">signal 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kill-%E5%87%BD%E6%95%B0-%E5%91%BD%E4%BB%A4"><span class="toc-number">1.10.3.2.</span> <span class="toc-text">kill 函数&#x2F;命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#raise-abort%E5%87%BD%E6%95%B0"><span class="toc-number">1.10.3.3.</span> <span class="toc-text">raise&#x2F;abort函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#alarm%E5%87%BD%E6%95%B0"><span class="toc-number">1.10.3.4.</span> <span class="toc-text">alarm函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setitimer%E5%87%BD%E6%95%B0"><span class="toc-number">1.10.3.5.</span> <span class="toc-text">setitimer函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%9B%86%E7%9B%B8%E5%85%B3"><span class="toc-number">1.10.4.</span> <span class="toc-text">信号集相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AA%E5%86%B3%E4%BF%A1%E5%8F%B7%E9%9B%86%E5%92%8C%E9%98%BB%E5%A1%9E%E4%BF%A1%E5%8F%B7%E9%9B%86%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.10.4.1.</span> <span class="toc-text">未决信号集和阻塞信号集的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%9B%86%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">1.10.4.2.</span> <span class="toc-text">信号集相关函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#sigemptyset"><span class="toc-number">1.10.4.2.1.</span> <span class="toc-text">sigemptyset</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sigfillset"><span class="toc-number">1.10.4.2.2.</span> <span class="toc-text">sigfillset</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sigaddset"><span class="toc-number">1.10.4.2.3.</span> <span class="toc-text">sigaddset</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sigdelset"><span class="toc-number">1.10.4.2.4.</span> <span class="toc-text">sigdelset</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sigismember"><span class="toc-number">1.10.4.2.5.</span> <span class="toc-text">sigismember</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sigprocmask"><span class="toc-number">1.10.4.2.6.</span> <span class="toc-text">sigprocmask</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sigpending"><span class="toc-number">1.10.4.2.7.</span> <span class="toc-text">sigpending</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89%E5%87%BD%E6%95%B0"><span class="toc-number">1.10.5.</span> <span class="toc-text">信号捕捉函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SIGCHLD%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.10.6.</span> <span class="toc-text">SIGCHLD信号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A7%E7%94%9FSIGCHLD%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.10.6.1.</span> <span class="toc-text">产生SIGCHLD信号的条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SIGCHLD-%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.10.6.2.</span> <span class="toc-text">SIGCHLD 信号的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-SIGCHLD-%E4%BF%A1%E5%8F%B7%E5%AE%8C%E6%88%90%E5%AF%B9%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9B%9E%E6%94%B6"><span class="toc-number">1.10.6.3.</span> <span class="toc-text">使用 SIGCHLD 信号完成对子进程的回收</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.11.</span> <span class="toc-text">守护进程和线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.11.1.</span> <span class="toc-text">守护进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.11.1.1.</span> <span class="toc-text">守护进程介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%84%E5%92%8C%E4%BC%9A%E8%AF%9D"><span class="toc-number">1.11.1.2.</span> <span class="toc-text">进程组和会话</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.11.2.</span> <span class="toc-text">创建守护进程的模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.11.3.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.11.3.1.</span> <span class="toc-text">什么是线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90"><span class="toc-number">1.11.3.2.</span> <span class="toc-text">线程共享资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%9D%9E%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90"><span class="toc-number">1.11.3.3.</span> <span class="toc-text">线程非共享资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%98%E3%80%81%E7%BC%BA%E7%82%B9"><span class="toc-number">1.11.3.4.</span> <span class="toc-text">线程优、缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-create"><span class="toc-number">1.11.3.5.</span> <span class="toc-text">pthread_create</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-exit"><span class="toc-number">1.11.3.6.</span> <span class="toc-text">pthread_exit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-join"><span class="toc-number">1.11.3.7.</span> <span class="toc-text">pthread_join</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-detach"><span class="toc-number">1.11.3.8.</span> <span class="toc-text">pthread_detach</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-cancel"><span class="toc-number">1.11.3.9.</span> <span class="toc-text">pthread_cancel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-equal"><span class="toc-number">1.11.3.10.</span> <span class="toc-text">pthread_equal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%87%BD%E6%95%B0%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%87%BD%E6%95%B0%E6%AF%94%E8%BE%83"><span class="toc-number">1.11.3.11.</span> <span class="toc-text">进程函数和线程函数比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7"><span class="toc-number">1.11.4.</span> <span class="toc-text">线程属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">1.12.</span> <span class="toc-text">线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.12.1.</span> <span class="toc-text">线程同步的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E4%B8%BB%E8%A6%81%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">1.12.2.</span> <span class="toc-text">互斥锁主要相关函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-mutex-t-%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.12.2.1.</span> <span class="toc-text">pthread_mutex_t 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-mutex-init"><span class="toc-number">1.12.2.2.</span> <span class="toc-text">pthread_mutex_init</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-mutex-destroy"><span class="toc-number">1.12.2.3.</span> <span class="toc-text">pthread_mutex_destroy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-mutex-lock"><span class="toc-number">1.12.2.4.</span> <span class="toc-text">pthread_mutex_lock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-mutex-unlock"><span class="toc-number">1.12.2.5.</span> <span class="toc-text">pthread_mutex_unlock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-mutex-trylock"><span class="toc-number">1.12.2.6.</span> <span class="toc-text">pthread_mutex_trylock</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E9%94%81%E5%92%8C%E8%A7%A3%E9%94%81"><span class="toc-number">1.12.3.</span> <span class="toc-text">加锁和解锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">1.12.4.</span> <span class="toc-text">互斥锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.12.4.1.</span> <span class="toc-text">互斥锁的使用步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">1.12.4.2.</span> <span class="toc-text">死锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">1.12.5.</span> <span class="toc-text">读写锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">1.12.6.</span> <span class="toc-text">条件变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">1.12.6.1.</span> <span class="toc-text">条件变量相关函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#pthread-cond-t-cond"><span class="toc-number">1.12.6.1.1.</span> <span class="toc-text">pthread_cond_t cond;</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#int-pthread-cond-init"><span class="toc-number">1.12.6.1.2.</span> <span class="toc-text">int pthread_cond_init</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#int-pthread-cond-destroy"><span class="toc-number">1.12.6.1.3.</span> <span class="toc-text">int pthread_cond_destroy</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#int-pthread-cond-wait"><span class="toc-number">1.12.6.1.4.</span> <span class="toc-text">int pthread_cond_wait</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#int-pthread-cond-signal"><span class="toc-number">1.12.6.1.5.</span> <span class="toc-text">int pthread_cond_signal</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5"><span class="toc-number">1.12.6.1.6.</span> <span class="toc-text">使用条件变量的代码片段</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">1.12.7.</span> <span class="toc-text">信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.12.7.1.</span> <span class="toc-text">信号量介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">1.12.7.2.</span> <span class="toc-text">相关函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#int-sem-init"><span class="toc-number">1.12.7.2.1.</span> <span class="toc-text">int sem_init</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#int-sem-wait"><span class="toc-number">1.12.7.2.2.</span> <span class="toc-text">int sem_wait</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#int-sem-post"><span class="toc-number">1.12.7.2.3.</span> <span class="toc-text">int sem_post</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#int-sem-trywait"><span class="toc-number">1.12.7.2.4.</span> <span class="toc-text">int sem_trywait</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#int-sem-destroy"><span class="toc-number">1.12.7.2.5.</span> <span class="toc-text">int sem_destroy</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">Linux网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80"><span class="toc-number">2.1.</span> <span class="toc-text">网络基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.1.</span> <span class="toc-text">协议概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.1.2.</span> <span class="toc-text">典型协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B-TCP-IP%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.1.3.</span> <span class="toc-text">OSI七层模型 &amp; TCP&#x2F;IP四层模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.1.4.</span> <span class="toc-text">网络应用程序设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C-S-%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.1.4.1.</span> <span class="toc-text">C&#x2F;S 模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-S-%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.1.4.2.</span> <span class="toc-text">B&#x2F;S 模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.1.4.3.</span> <span class="toc-text">优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#C-S"><span class="toc-number">2.1.4.3.1.</span> <span class="toc-text">C&#x2F;S</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-S"><span class="toc-number">2.1.4.3.2.</span> <span class="toc-text">B&#x2F;S</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.1.5.</span> <span class="toc-text">以太网帧格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ARP"><span class="toc-number">2.1.6.</span> <span class="toc-text">ARP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IP-%E6%AE%B5%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.1.7.</span> <span class="toc-text">IP 段格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP-%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.1.8.</span> <span class="toc-text">UDP 数据报格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E6%95%B0%E6%8D%AE%E6%B5%81%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.1.9.</span> <span class="toc-text">TCP数据流格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">2.1.9.1.</span> <span class="toc-text">三次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE"><span class="toc-number">2.1.9.2.</span> <span class="toc-text">发送数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">2.1.9.3.</span> <span class="toc-text">四次挥手</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">2.1.10.</span> <span class="toc-text">滑动窗口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%B0%81%E8%A3%85%E6%80%9D%E6%83%B3"><span class="toc-number">2.1.11.</span> <span class="toc-text">函数封装思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B2%98%E5%8C%85"><span class="toc-number">2.1.12.</span> <span class="toc-text">粘包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="toc-number">2.2.</span> <span class="toc-text">网络字节序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F%E7%AB%AF%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.1.</span> <span class="toc-text">大小端转换函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IP-%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.2.</span> <span class="toc-text">IP 地址转换函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%82%B9%E5%88%86%E5%8D%81%E8%BF%9B%E5%88%B6IP%E8%BD%AC%E7%BD%91%E7%BB%9CIP"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">点分十进制IP转网络IP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9CIP%E8%BD%AC%E7%82%B9%E5%88%86%E5%8D%81%E8%BF%9B%E5%88%B6IP"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">网络IP转点分十进制IP</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SOCKET%E7%BC%96%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text">SOCKET编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SOCKET%E4%B8%AD%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">2.4.</span> <span class="toc-text">SOCKET中结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SOCKET%E4%B8%BB%E8%A6%81%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.</span> <span class="toc-text">SOCKET主要函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#socket"><span class="toc-number">2.5.1.</span> <span class="toc-text">socket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bind"><span class="toc-number">2.5.2.</span> <span class="toc-text">bind</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#listen"><span class="toc-number">2.5.3.</span> <span class="toc-text">listen</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#accept"><span class="toc-number">2.5.4.</span> <span class="toc-text">accept</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#connect"><span class="toc-number">2.5.5.</span> <span class="toc-text">connect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E5%92%8C%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE"><span class="toc-number">2.5.6.</span> <span class="toc-text">读取数据和发送数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="toc-number">2.6.</span> <span class="toc-text">服务端开发流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="toc-number">2.7.</span> <span class="toc-text">客户端的开发流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">2.8.</span> <span class="toc-text">高并发服务器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE"><span class="toc-number">2.9.</span> <span class="toc-text">TCP状态转换图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%812MSL"><span class="toc-number">2.9.1.</span> <span class="toc-text">为什么需要2MSL</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8"><span class="toc-number">2.10.</span> <span class="toc-text">端口复用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8A%E5%85%B3%E9%97%AD%E7%8A%B6%E6%80%81"><span class="toc-number">2.11.</span> <span class="toc-text">半关闭状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8A%E5%85%B3%E9%97%AD%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">2.11.1.</span> <span class="toc-text">半关闭的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shutdown-%E5%87%BD%E6%95%B0"><span class="toc-number">2.11.2.</span> <span class="toc-text">shutdown 函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%83%E8%B7%B3%E5%8C%85"><span class="toc-number">2.12.</span> <span class="toc-text">心跳包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E5%BF%83%E8%B7%B3%E8%BF%87%E7%A8%8B"><span class="toc-number">2.12.1.</span> <span class="toc-text">发送心跳过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A9%E5%BF%83%E8%B7%B3%E6%95%B0%E6%8D%AE%E5%92%8C%E6%AD%A3%E5%B8%B8%E7%9A%84%E4%B8%9A%E5%8A%A1%E6%95%B0%E6%8D%AE%E4%B8%8D%E6%B7%B7%E6%B7%86"><span class="toc-number">2.12.2.</span> <span class="toc-text">如何让心跳数据和正常的业务数据不混淆?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%9E%8B%E2%80%93select"><span class="toc-number">2.13.</span> <span class="toc-text">高并发服务器模型–select</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E5%A5%97%E5%87%BD%E6%95%B0"><span class="toc-number">2.13.1.</span> <span class="toc-text">配套函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">2.13.2.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">2.13.3.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF-IO"><span class="toc-number">2.14.</span> <span class="toc-text">多路 IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#poll"><span class="toc-number">2.14.1.</span> <span class="toc-text">poll</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#epoll"><span class="toc-number">2.14.2.</span> <span class="toc-text">epoll</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll-create"><span class="toc-number">2.14.2.1.</span> <span class="toc-text">epoll_create</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll-ctl"><span class="toc-number">2.14.2.2.</span> <span class="toc-text">epoll_ctl</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll-wait"><span class="toc-number">2.14.2.3.</span> <span class="toc-text">epoll_wait</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6epoll"><span class="toc-number">2.14.3.</span> <span class="toc-text">进阶epoll</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#epoll%E5%8F%8D%E5%BA%94%E5%A0%86"><span class="toc-number">2.14.4.</span> <span class="toc-text">epoll反应堆</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">2.15.</span> <span class="toc-text">线程池</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/10/19/hello-world/" title="Hello World"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/404.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/2024/10/19/hello-world/" title="Hello World">Hello World</a><time datetime="2024-10-19T15:33:10.678Z" title="发表于 2024-10-19 23:33:10">2024-10-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/22/Linux/" title="Linux"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/404.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux"/></a><div class="content"><a class="title" href="/2024/09/22/Linux/" title="Linux">Linux</a><time datetime="2024-09-22T08:42:21.000Z" title="发表于 2024-09-22 16:42:21">2024-09-22</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="footer_deal"><a class="deal_link" target="_blank" rel="noopener" href="https://www.helloimg.com/i/2024/10/21/67161f06299a2.jpg" title="WeChat"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://x.com/GodSath" title="X"></a><a class="deal_link" target="_blank" rel="noopener" href="https://www.facebook.com/catandsaltedfish/" title="Facebook"><i class="anzhiyufont anzhiyu-icon-facebook1"></i></a><img class="footer_mini_logo" title="返回顶部" alt="返回顶部" onclick="anzhiyu.scrollToDest(0, 500)" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2021/01/15/45dcf1dc05d9b.png" size="50px"/><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/Kacovi" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://www.douyin.com/user/MS4wLjABAAAAmZRCXylY8pwZrFn7BT6v7unbuS3r7dHjURszXjnRu6E" title="抖音"><i class="anzhiyufont anzhiyu-icon-tiktok"></i></a><a class="deal_link" href="mailto:kacovic@qq.com" title="email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a></div><div id="workboard"><div id="runtimeTextTip"></div></div><div class="footer_custom_text">Just do it.</div><div id="anzhiyu-footer"><div class="footer-group"><div class="footer-title">服务</div><div class="footer-links"><a class="footer-item" title="51la统计" target="_blank" rel="noopener" href="https://v6.51.la/">51la统计</a><a class="footer-item" title="十年之约" target="_blank" rel="noopener" href="https://www.foreverblog.cn/">十年之约</a><a class="footer-item" title="开往" target="_blank" rel="noopener" href="https://github.com/travellings-link/travellings">开往</a></div></div><div class="footer-group"><div class="footer-title">导航</div><div class="footer-links"><a class="footer-item" title="即刻短文" href="/essay/">即刻短文</a><a class="footer-item" title="友链文章" href="/fcircle/">友链文章</a><a class="footer-item" title="留言板" href="/comments/">留言板</a></div></div><div class="footer-group"><div class="footer-title">协议</div><div class="footer-links"><a class="footer-item" title="隐私协议" href="/privacy/">隐私协议</a><a class="footer-item" title="Cookies" href="/cookies/">Cookies</a><a class="footer-item" title="版权协议" href="/copyright/">版权协议</a></div></div><div class="footer-group"><div class="footer-title-group"><div class="footer-title">友链</div><a class="random-friends-btn" id="footer-random-friends-btn" href="javascript:addFriendLinksInFooter();" title="换一批友情链接"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right"></i></a></div><div class="footer-links" id="friend-links-in-footer"></div></div></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v5.4.0"/></a><a class="github-badge" target="_blank" href="https://blog.anheyu.com/" style="margin-inline:5px" data-title="本站使用AnZhiYu主题" title="本站使用AnZhiYu主题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.9/img/Theme-AnZhiYu-2E67D3.svg" alt="本站使用AnZhiYu主题"/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title="本站项目由Github托管"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Source-Github.svg" alt="本站项目由Github托管"/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/Copyright-BY-NC-SA.svg" alt="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"/></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2024 By <a class="footer-bar-link" href="/" title="Kayer" target="_blank">Kayer</a></div></div><div id="footer-type-tips"></div><div class="js-pjax"><script>function subtitleType () {
  getScript('https://sdk.jinrishici.com/v2/browser/jinrishici.js').then(() => {
    jinrishici.load(result =>{
      if (true) {
        const sub = ["衣带渐宽终不悔，为伊消得人憔悴。"]
        const content = result.data.content
        sub.unshift(content)
        window.typed = new Typed('#footer-type-tips', {
          strings: sub,
          startDelay: 300,
          typeSpeed: 150,
          loop: true,
          backSpeed: 50,
        })
      } else {
        document.getElementById('footer-type-tips').innerHTML = result.data.content
      }
    })
  })
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.cbd.int/typed.js@2.1.0/dist/typed.umd.js').then(subtitleType)
  }
} else {
  subtitleType()
}
</script></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a><a class="footer-bar-link cc" href="/copyright" title="cc协议"><i class="anzhiyufont anzhiyu-icon-copyright-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-by-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-nc-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-nd-line"></i></a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">2</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://kayer.cn/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=9350162041&amp;server=tencent"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/CPP/" style="font-size: 0.88rem;">CPP<sup>2</sup></a><a href="/tags/Linux/" style="font-size: 0.88rem;">Linux<sup>2</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="9350162041" server="tencent" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.cbd.int/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("10/20/2024 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用KAYER!\n`,
    `   █╗  ██╗ █████╗ ██╗   ██╗███████╗██████╗ 
     ██║ ██╔╝██╔══██╗╚██╗ ██╔╝██╔════╝██╔══██╗
     █████╔╝ ███████║ ╚████╔╝ █████╗  ██████╔╝
     ██╔═██╗ ██╔══██║  ╚██╔╝  ██╔══╝  ██╔══██╗
     ██║  ██╗██║  ██║   ██║   ███████╗██║  ██║
     ╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝   ╚══════╝╚═╝  ╚═╝`,
    `\n衣带渐宽终不悔，为伊消得人憔悴`,
    "\n已上线",
    dnum,
    "天",
    "©2024 By KAYER",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by KAYER %c 你正在访问 Kayer 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("10/20/2024 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      if (img != null) {
        img.src = "";
        img.title = "下班了就该开开心心的玩耍，嘿嘿~";
        img.alt = "下班了就该开开心心的玩耍，嘿嘿~";
      }

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>